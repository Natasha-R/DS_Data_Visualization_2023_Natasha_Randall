name,source,style,version,code,num_chars,num_lines,avg_line_length,max_line_length,num_scaled_comments,num_scaled_if,num_scaled_for,num_scaled_switch,num_scaled_digits,num_scaled_exceptions,num_scaled_empty_lines,num_scaled_prints,used_boolean,used_List,used_Integer,used_Point,used_ArrayList,used_StringBuilder,num_files,num_scaled_method_declarations,num_scaled_declared_fields,num_scaled_local_variables,num_scaled_classes,num_scaled_field_references,num_scaled_method_invocations,num_scaled_imports,avg_name_length,max_name_length,avg_comment_length,max_comment_length
1,bard,plain,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Moveable {

    private int x = 7;
    private int y = 7;
    private int width = 11;
    private int height = 8;
    private String[] barriers = {""(2,1)-(10,1)"", ""(2,1)-(2,6)"", ""(2,6)-(7,6)"", ""(10,1)-(10,8)""};

    @Override
    public String move(String moveCommandString) {
        String[] parts = moveCommandString.substring(1, moveCommandString.length() - 1).split("","");
        String direction = parts[0];
        int steps = Integer.parseInt(parts[1]);

        if (direction.equals(""no"")) {
            for (int i = 0; i < steps; i++) {
                if (y > 0 && !isBarrier(x, y - 1)) {
                    y--;
                } else {
                    break;
                }
            }
        } else if (direction.equals(""ea"")) {
            for (int i = 0; i < steps; i++) {
                if (x < width - 1 && !isBarrier(x + 1, y)) {
                    x++;
                } else {
                    break;
                }
            }
        } else if (direction.equals(""so"")) {
            for (int i = 0; i < steps; i++) {
                if (y < height - 1 && !isBarrier(x, y + 1)) {
                    y++;
                } else {
                    break;
                }
            }
        } else if (direction.equals(""we"")) {
            for (int i = 0; i < steps; i++) {
                if (x > 0 && !isBarrier(x - 1, y)) {
                    x--;
                } else {
                    break;
                }
            }
        }

        return ""("" + x + "","" + y + "")"";
    }

    private boolean isBarrier(int x, int y) {
        for (String barrier : barriers) {
            String[] parts = barrier.replace(""("", """").replace("")"", """").replace("","", """").split(""-"");
            int x1 = Integer.parseInt(parts[0].substring(1, parts[0].length()));
            int y1 = Integer.parseInt(parts[0].substring(parts[0].length() - 1));
            int x2 = Integer.parseInt(parts[1].substring(1, parts[1].length()));
            int y2 = Integer.parseInt(parts[1].substring(parts[1].length() - 1));
            if (x >= x1 && x <= x2 && y >= y1 && y <= y2) {
                return true;
            }
        }
        return false;
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String move(String moveCommandString);
}
",2393,72,35.707692307692305,99,0.0,0.125,0.06944444444444445,0.0,0.875,0.0,0.09722222222222222,0.0,False,False,False,False,False,False,2,0.041666666666666664,0.06944444444444445,0.1111111111111111,0.013888888888888888,0.7083333333333334,0.3888888888888889,0.0,3.3333333333333335,8,0.0,0
1,bing,plain,balanced,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Walkable {
    private int[][] walls = {{3,0},{3,1},{3,2},{3,3},{4,3},{5,3},{6,3},{7,3},{7,2},{7,1},{7,0},{1,4},{2,4},{3,4},{4,4},{5,4},{6,4},{7,4}};
    private int[] currentPos = {3,0};
    private int[] roomSize = {12,8};

    public String walkTo(String walkCommandString) {
        String[] walkCommand = walkCommandString.substring(1,walkCommandString.length()-1).split("","");
        int steps = Integer.parseInt(walkCommand[1]);
        switch(walkCommand[0]) {
            case ""no"":
                for(int i=0; i<steps; i++) {
                    if(currentPos[1]+1>=roomSize[1] || isWall(currentPos[0],currentPos[1]+1)) break;
                    currentPos[1]++;
                }
                break;
            case ""ea"":
                for(int i=0; i<steps; i++) {
                    if(currentPos[0]+1>=roomSize[0] || isWall(currentPos[0]+1,currentPos[1])) break;
                    currentPos[0]++;
                }
                break;
            case ""so"":
                for(int i=0; i<steps; i++) {
                    if(currentPos[1]-1<0 || isWall(currentPos[0],currentPos[1]-1)) break;
                    currentPos[1]--;
                }
                break;
            case ""we"":
                for(int i=0; i<steps; i++) {
                    if(currentPos[0]-1<0 || isWall(currentPos[0]-1,currentPos[1])) break;
                    currentPos[0]--;
                }
                break;
        }
        return ""(""+currentPos[0]+"",""+currentPos[1]+"")"";
    }

    private boolean isWall(int x,int y) {
        for(int[] wall : walls) {
            if(wall[0]==x && wall[1]==y) return true;
        }
        return false;
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);
}
",1873,51,38.765957446808514,138,0.0,0.09803921568627451,0.09803921568627451,0.0196078431372549,1.6470588235294117,0.0,0.0784313725490196,0.0,False,False,False,False,False,False,2,0.058823529411764705,0.058823529411764705,0.0392156862745098,0.0196078431372549,0.7647058823529411,0.1568627450980392,0.0,5.111111111111111,11,0.0,0
1,gpt3.5,plain,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements GoAble {
    private int x; // current x-coordinate
    private int y; // current y-coordinate
    private int[][] obstacles; // array to store obstacle coordinates

    // Constructor
    public Exercise0() {
        x = 11; // starting x-coordinate
        y = 7; // starting y-coordinate
        // Initialize obstacle coordinates
        obstacles = new int[][]{{6, 2, 6, 5}, {5, 5, 6, 5}, {5, 5, 5, 6}, {5, 6, 12, 6}};
    }

    @Override
    public String goTo(String goCommandString) {
        // Parse goCommandString to extract direction and steps
        String direction = goCommandString.substring(1, 3);
        int steps = Integer.parseInt(goCommandString.substring(4, goCommandString.length() - 1));

        // Update coordinates based on direction and steps
        switch (direction) {
            case ""no"": // Move north
                for (int i = 0; i < steps; i++) {
                    if (isObstacle(x, y + 1)) { // Check for obstacle
                        break;
                    }
                    y++;
                }
                break;
            case ""ea"": // Move east
                for (int i = 0; i < steps; i++) {
                    if (isObstacle(x + 1, y)) { // Check for obstacle
                        break;
                    }
                    x++;
                }
                break;
            case ""so"": // Move south
                for (int i = 0; i < steps; i++) {
                    if (isObstacle(x, y - 1)) { // Check for obstacle
                        break;
                    }
                    y--;
                }
                break;
            case ""we"": // Move west
                for (int i = 0; i < steps; i++) {
                    if (isObstacle(x - 1, y)) { // Check for obstacle
                        break;
                    }
                    x--;
                }
                break;
            default:
                throw new IllegalArgumentException(""Invalid direction: "" + direction);
        }

        // Clamp coordinates within spaceship deck boundaries
        x = Math.max(0, Math.min(x, 11));
        y = Math.max(0, Math.min(y, 7));

        // Return current coordinates as string
        return ""("" + x + "","" + y + "")"";
    }

    // Helper method to check if given coordinates are part of an obstacle
    private boolean isObstacle(int x, int y) {
        for (int[] obstacle : obstacles) {
            if (x >= obstacle[0] && x <= obstacle[2] && y >= obstacle[1] && y <= obstacle[3]) {
                return true;
            }
        }
        return false;
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String goTo(String goCommandString);
}
",2800,82,36.729729729729726,97,0.24390243902439024,0.07317073170731707,0.10975609756097561,0.012195121951219513,0.5487804878048781,0.012195121951219513,0.0975609756097561,0.0,False,False,False,False,False,False,2,0.036585365853658534,0.036585365853658534,0.024390243902439025,0.012195121951219513,0.5365853658536586,0.14634146341463414,0.0,4.857142857142857,9,26.05,67
1,gpt4,plain,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Walkable {
    private int x = 0;
    private int y = 2;
    private final int fieldWidth = 12;
    private final int fieldHeight = 9;

    @Override
    public String walk(String walkCommandString) {
        String[] parts = walkCommandString.substring(1, walkCommandString.length() - 1).split("","");
        String direction = parts[0].trim();
        int steps = Integer.parseInt(parts[1].trim());

        switch (direction) {
            case ""no"":
                y += steps;
                if (x >= 4 && x < 7 && y > 4) y = 4;
                if (y >= fieldHeight) y = fieldHeight - 1;
                break;

            case ""ea"":
                x += steps;
                if (y >= 0 && y < 3 && x > 2) x = 2;
                if (y >= 0 && y < 4 && x > 4) x = 4;
                if (y > 4 && y <= 8 && x > 6) x = 6;
                if (x >= fieldWidth) x = fieldWidth - 1;
                break;

            case ""so"":
                y -= steps;
                if (x >= 4 && x < 7 && y < 5 && y > 0) y = 5;
                if (x >= 3 && x <= 5 && y >= 3) y = 3;
                if (y < 0) y = 0;
                break;

            case ""we"":
                x -= steps;
                if (x < 0) x = 0;
                break;
        }

        return ""("" + x + "","" + y + "")"";
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",1494,50,34.38095238095238,99,0.0,0.2,0.0,0.02,0.86,0.0,0.16,0.0,False,False,False,False,False,False,2,0.04,0.08,0.06,0.02,1.0,0.12,0.0,6.0,11,0.0,0
10,bard,styled,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Moveable {

    private static final int START_X = 7;
    private static final int START_Y = 7;
    private static final int WIDTH = 11;
    private static final int HEIGHT = 8;
    private static final int[][] BARRIERS = {{2, 1}, {10, 1}, {2, 6}, {7, 6}, {10, 8}};

    private int x = START_X;
    private int y = START_Y;

    public Exercise0() {
        // Nothing here
    }

    @Override
    public String move(String moveCommandString) {
        // Parse the command string
        String[] tokens = moveCommandString.substring(1, moveCommandString.length() - 1).split("","");
        String direction = tokens[0];
        int steps = Integer.parseInt(tokens[1]);

        // Move the device
        switch (direction) {
            case ""no"":
                for (int i = 0; i < steps; i++) {
                    if (y - 1 < 0 || isBarrier(x, y - 1)) {
                        break;
                    }
                    y--;
                }
                if (y < 0) {
                    y = 0;
                }
                break;
            case ""ea"":
                for (int i = 0; i < steps; i++) {
                    if (x + 1 >= WIDTH || isBarrier(x + 1, y)) {
                        break;
                    }
                    x++;
                }
                break;
            case ""so"":
                for (int i = 0; i < steps; i++) {
                    if (y + 1 >= HEIGHT || isBarrier(x, y + 1)) {
                        break;
                    }
                    y++;
                }
                break;
            case ""we"":
                for (int i = 0; i < steps; i++) {
                    if (x - 1 < 0 || isBarrier(x - 1, y)) {
                        break;
                    }
                    x--;
                }
                break;
        }

        // Return the new location of the device
        return ""("" + x + "","" + y + "")"";
    }

    private boolean isBarrier(int x, int y) {
        for (int[] barrier : BARRIERS) {
            if (barrier[0] == x && barrier[1] == y) {
                return true;
            }
        }
        return false;
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String move(String moveCommandString);
}
",2345,81,31.444444444444443,100,0.04938271604938271,0.07407407407407407,0.06172839506172839,0.012345679012345678,0.5308641975308642,0.0,0.1111111111111111,0.0,False,False,False,False,False,False,2,0.037037037037037035,0.08641975308641975,0.037037037037037035,0.012345679012345678,0.5432098765432098,0.09876543209876543,0.0,5.25,9,22.0,37
10,bing,styled,creative,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Walkable {

    public static final String NORTH = ""no"";
    public static final String EAST = ""ea"";
    public static final String SOUTH = ""so"";
    public static final String WEST = ""we"";

    public static final int ROOM_WIDTH = 12;
    public static final int ROOM_HEIGHT = 8;
    public static final int[][] WALLS = {{3,0,3,3}, {4,3,7,3}, {7,0,7,2}, {1,4,8,4}};

    private int x;
    private int y;

    public Exercise0() {
        x = 3;
        y = 0;
    }

    @Override
    public String walkTo(String walkCommandString) {
        walkCommandString = walkCommandString.replace(""["", """").replace(""]"", """");
        String[] parts = walkCommandString.split("","");
        String direction = parts[0];
        int steps = Integer.parseInt(parts[1]);

        switch (direction) {
            case NORTH:
                y += moveVertical(steps,true);
                break;
            case EAST:
                x += moveHorizontal(steps,true);
                break;
            case SOUTH:
                y -= moveVertical(steps,false);
                break;
            case WEST:
                x -= moveHorizontal(steps,false);
                break;
            default:
                return null;
        }

        return ""("" + x + "","" + y + "")"";
    }

    private int moveVertical(int steps, boolean up) {
        int target = y + (up ? steps : -steps);

        if (target < 0 || target >= ROOM_HEIGHT) {
            target = up ? ROOM_HEIGHT - 1 : 0;
        }

        for (int[] wall : WALLS) {
            if (wall[0] == wall[2] && wall[0] == x && ((up && wall[1] <= y && wall[3] > y && wall[3] <= target) ||
                    (!up && wall[1] >= y && wall[1] < y && wall[1] >= target))) {
                target = up ? wall[3] : wall[1];
            }
        }

        return up ? target - y : y - target;
    }

    private int moveHorizontal(int steps, boolean right) {
        int target = x + (right ? steps : -steps);

        if (target < 0 || target >= ROOM_WIDTH) {
            target = right ? ROOM_WIDTH - 1 : 0;
        }

        for (int[] wall : WALLS) {
            if (wall[1] == wall[3] && wall[1] == y && ((right && wall[0] <= x && wall[2] > x && wall[2] <= target) ||
                    (!right && wall[0] >= x && wall[0] < x && wall[0] >= target))) {
                target = right ? wall[2] : wall[0];
            }
        }

        return right ? target - x : x - target;
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);
}
",2632,87,36.357142857142854,117,0.0,0.04597701149425287,0.022988505747126436,0.011494252873563218,0.632183908045977,0.0,0.19540229885057472,0.0,False,False,False,False,False,False,2,0.04597701149425287,0.10344827586206896,0.05747126436781609,0.011494252873563218,1.0574712643678161,0.09195402298850575,0.0,6.230769230769231,17,0.0,0
10,gpt3.5,plain,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements GoAble {
    // Define the size of the spaceship deck
    private static final int WIDTH = 12;
    private static final int HEIGHT = 8;

    // Define the locations of the obstacles
    private static final int[][] OBSTACLES = {
            {6, 2, 6, 5},
            {5, 5, 6, 5},
            {5, 5, 5, 6},
            {5, 6, 12, 6}
    };

    // Define the initial position of the maintenance droid
    private int x = 11;
    private int y = 7;

    @Override
    public String goTo(String goCommandString) {
        // Parse the command string
        String[] parts = goCommandString.replaceAll(""[\\[\\]]"", """").split("","");
        String direction = parts[0];
        int steps = Integer.parseInt(parts[1]);

        // Move the maintenance droid in the specified direction
        switch (direction) {
            case ""no"":
                y += steps;
                break;
            case ""ea"":
                x += steps;
                break;
            case ""so"":
                y -= steps;
                break;
            case ""we"":
                x -= steps;
                break;
        }

        // Check for collisions with obstacles or the spaceship deck boundary
        for (int[] obstacle : OBSTACLES) {
            if (x >= obstacle[0] && x <= obstacle[2] && y >= obstacle[1] && y <= obstacle[3]) {
                // Collision detected, adjust the position of the droid
                if (direction.equals(""no"")) {
                    y = obstacle[1] - 1;
                } else if (direction.equals(""ea"")) {
                    x = obstacle[0] - 1;
                } else if (direction.equals(""so"")) {
                    y = obstacle[3] + 1;
                } else if (direction.equals(""we"")) {
                    x = obstacle[2] + 1;
                }
                break;
            }
        }

        // Check if the maintenance droid has moved out of the spaceship deck boundary
        if (x < 0) {
            x = 0;
        } else if (x >= WIDTH) {
            x = WIDTH - 1;
        }
        if (y < 0) {
            y = 0;
        } else if (y >= HEIGHT) {
            y = HEIGHT - 1;
        }

        // Return the current position of the maintenance droid
        return ""("" + x + "","" + y + "")"";
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String goTo(String goCommandString);
}
",2451,81,33.38028169014085,95,0.1111111111111111,0.13580246913580246,0.024691358024691357,0.012345679012345678,0.5679012345679012,0.0,0.12345679012345678,0.0,False,False,False,False,False,False,2,0.024691358024691357,0.06172839506172839,0.037037037037037035,0.012345679012345678,0.5185185185185185,0.08641975308641975,0.0,5.444444444444445,9,49.77777777777778,75
10,gpt4,plain,,"package thkoeln.st.st2praktikum.exercise;

import java.awt.Point;
import java.util.Arrays;
import java.util.List;

public class Exercise0 implements Walkable {

    private static final int FIELD_WIDTH = 12;
    private static final int FIELD_HEIGHT = 9;
    private Point miningMachineLocation;
    private List<String> walls;

    public Exercise0() {
        miningMachineLocation = new Point(0, 2);
        walls = Arrays.asList(""3,0-3,3"", ""5,0-5,4"", ""4,5-7,5"", ""7,5-7,9"");
    }

    @Override
    public String walk(String walkCommandString) {
        String[] commandParts = walkCommandString.substring(1, walkCommandString.length() - 1).split("","");
        String direction = commandParts[0];
        int steps = Integer.parseInt(commandParts[1]);

        for (int i = 0; i < steps; i++) {
            Point newPosition = new Point(miningMachineLocation);
            switch (direction) {
                case ""no"":
                    newPosition.y++;
                    break;
                case ""ea"":
                    newPosition.x++;
                    break;
                case ""so"":
                    newPosition.y--;
                    break;
                case ""we"":
                    newPosition.x--;
                    break;
            }

            if (isValidPosition(newPosition)) {
                miningMachineLocation = newPosition;
            } else {
                break;
            }
        }

        return String.format(""(%d,%d)"", miningMachineLocation.x, miningMachineLocation.y);
    }

    private boolean isValidPosition(Point position) {
        if (position.x < 0 || position.x >= FIELD_WIDTH || position.y < 0 || position.y >= FIELD_HEIGHT) {
            return false;
        }

        for (String wall : walls) {
            String[] coordinates = wall.split(""-"");
            String[] startCoords = coordinates[0].split("","");
            String[] endCoords = coordinates[1].split("","");

            int startX = Integer.parseInt(startCoords[0]);
            int startY = Integer.parseInt(startCoords[1]);
            int endX = Integer.parseInt(endCoords[0]);
            int endY = Integer.parseInt(endCoords[1]);

            if (startX == endX) {
                if (position.x == startX && position.y >= startY && position.y < endY) {
                    return false;
                }
            } else if (startY == endY) {
                if (position.y == startY && position.x >= startX && position.x < endX) {
                    return false;
                }
            }
        }

        return true;
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",2710,85,36.971830985915496,106,0.0,0.07058823529411765,0.03529411764705882,0.011764705882352941,0.4470588235294118,0.0,0.16470588235294117,0.0,False,True,False,True,False,False,2,0.03529411764705882,0.047058823529411764,0.12941176470588237,0.011764705882352941,0.5529411764705883,0.16470588235294117,0.03529411764705882,7.777777777777778,21,0.0,0
11,bard,styled,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Moveable{
    private static final int WIDTH = 11;
    private static final int HEIGHT = 8;
    private static final int START_X = 7;
    private static final int START_Y = 7;
    private static final int[] BARRIERS_X = {2, 10};
    private static final int[] BARRIERS_Y = {1, 6, 7};

    private int x;
    private int y;

    public Exercise0(){
        this.x=START_X;
        this.y=START_Y;
    }

    @Override
    public String move(String moveCommandString){
        String[] parts = moveCommandString.substring(1, moveCommandString.length()-1).split("","");
        String direction = parts[0];
        int steps = Integer.parseInt(parts[1]);

        for(int i=0; i<steps; i++){
            switch(direction){
                case ""no"":
                    if(y-1<0 || isBarrier(x, y-1)){
                        break;
                    }
                    y--;
                    break;
                case ""ea"":
                    if(x+1>=WIDTH || isBarrier(x+1, y)){
                        break;
                    }
                    x++;
                    break;
                case ""so"":
                    if(y+1>=HEIGHT || isBarrier(x, y+1)){
                        break;
                    }
                    y++;
                    break;
                case ""we"":
                    if(x-1<0 || isBarrier(x-1, y)){
                        break;
                    }
                    x--;
                    break;
            }
        }

        return ""(""+x+"",""+y+"")"";
    }

    private boolean isBarrier(int x, int y){
        for(int i=0; i<BARRIERS_X.length; i++){
            if(x==BARRIERS_X[i]){
                if(y<=BARRIERS_Y[i] || y>=BARRIERS_Y[i+1]){
                    return true;
                }
            }
        }
        return false;
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String move(String moveCommandString);
}
",2014,72,30.34375,97,0.0,0.08333333333333333,0.027777777777777776,0.013888888888888888,0.4444444444444444,0.0,0.1111111111111111,0.0,False,False,False,False,False,False,2,0.041666666666666664,0.1111111111111111,0.041666666666666664,0.013888888888888888,0.5833333333333334,0.1111111111111111,0.0,5.615384615384615,10,0.0,0
11,bing,plain,creative,"package thkoeln.st.st2praktikum.exercise;

// A class that implements the Walkable interface
public class Exercise0 implements Walkable {

    // A nested class that represents a cell in the room
    public static class Cell {
        // The x and y coordinates of the cell
        private int x;
        private int y;

        // A constructor that takes the x and y coordinates as parameters
        public Cell(int x, int y) {
            this.x = x;
            this.y = y;
        }

        // A getter method for the x coordinate
        public int getX() {
            return x;
        }

        // A getter method for the y coordinate
        public int getY() {
            return y;
        }

        // A setter method for the x coordinate
        public void setX(int x) {
            this.x = x;
        }

        // A setter method for the y coordinate
        public void setY(int y) {
            this.y = y;
        }

        // A method that returns a string representation of the cell
        public String toString() {
            return ""("" + x + "","" + y + "")"";
        }
    }

    // A nested class that represents a wall in the room
    public static class Wall {
        // The start and end cells of the wall
        private Cell start;
        private Cell end;

        // A constructor that takes the start and end cells as parameters
        public Wall(Cell start, Cell end) {
            this.start = start;
            this.end = end;
        }

        // A getter method for the start cell
        public Cell getStart() {
            return start;
        }

        // A getter method for the end cell
        public Cell getEnd() {
            return end;
        }
    }

    // The width and height of the room
    private int width;
    private int height;

    // The array of walls in the room
    private Wall[] walls;

    // The current cell of the tidy-up robot
    private Cell current;

    // A constructor that takes no parameters and uses hardcoded values
    public Exercise0() {
        // The width and height of the room are 12 and 8 respectively
        this.width = 12;
        this.height = 8;

        // The array of walls in the room has four elements
        this.walls = new Wall[4];

        // The first wall is between (3,0) and (3,3)
        this.walls[0] = new Wall(new Cell(3, 0), new Cell(3, 3));

        // The second wall is between (4,3) and (7,3)
        this.walls[1] = new Wall(new Cell(4, 3), new Cell(7, 3));

        // The third wall is between (7,0) and (7,2)
        this.walls[2] = new Wall(new Cell(7, 0), new Cell(7, 2));

        // The fourth wall is between (1,4) and (8,4)
        this.walls[3] = new Wall(new Cell(1, 4), new Cell(8, 4));

        // The current cell of the tidy-up robot is (3,0)
        this.current = new Cell(3, 0);
    }

    // A method that implements the walkTo interface
    public String walkTo(String walkCommandString) {

        // Parse the walk command string into direction and steps
        String direction = walkCommandString.substring(1, 3);
        int steps = Integer.parseInt(walkCommandString.substring(4, walkCommandString.length() - 1));

        // Initialize variables for the new x and y coordinates of the robot
        int newX = current.getX();
        int newY = current.getY();

        // Switch on the direction and update the new coordinates accordingly
        switch (direction) {
            case ""no"":
                newY += steps; // Move north by adding steps to y coordinate
                break;
            case ""ea"":
                newX += steps; // Move east by adding steps to x coordinate
                break;
            case ""so"":
                newY -= steps; // Move south by subtracting steps from y coordinate
                break;
            case ""we"":
                newX -= steps; // Move west by subtracting steps from x coordinate
                break;
            default:
                return ""Invalid direction""; // Return an error message if direction is invalid
        }
        // Check if the new coordinates are within the room boundaries, and adjust them if not
        if (newX < 0) {
            newX = 0; // Cannot move beyond the left boundary
        }
        if (newX >= width) {
            newX = width - 1; // Cannot move beyond the right boundary
        }
        if (newY < 0) {
            newY = 0; // Cannot move beyond the bottom boundary
        }
        if (newY >= height) {
            newY = height - 1; // Cannot move beyond the top boundary
        }

// Create a new cell object with the new coordinates
        Cell newCell = new Cell(newX, newY);

// Check if there is a wall between the current cell and the new cell, and adjust them if there is
        for (Wall wall : walls) {

            // Get the start and end cells of the wall
            Cell wallStart = wall.getStart();
            Cell wallEnd = wall.getEnd();

            // Check if the wall is horizontal or vertical
            boolean horizontal = wallStart.getY() == wallEnd.getY();
            boolean vertical = wallStart.getX() == wallEnd.getX();

            if (horizontal) {
                // If horizontal, check if it blocks any movement along y axis

                // Get the minimum and maximum x coordinates of the wall segment
                int minX = Math.min(wallStart.getX(), wallEnd.getX());
                int maxX = Math.max(wallStart.getX(), wallEnd.getX());

                // Get the y coordinate of the wall segment
                int y = wallStart.getY();

                if (current.getY() < y && newCell.getY() >= y && newX >= minX && newX <= maxX) {
                    newCell.setY(y - 1); // If moving up and hitting a horizontal wall, stop below it
                }
                if (current.getY() > y && newCell.getY() <= y && newX >= minX && newX <= maxX) {
                    newCell.setY(y + 1); // If moving down and hitting a horizontal wall, stop above it
                }

            } else if (vertical) {
                // If vertical, check if it blocks any movement along x axis

                // Get the minimum and maximum y coordinates of the wall segment
                int minY = Math.min(wallStart.getY(), wallEnd.getY());
                int maxY = Math.max(wallStart.getY(), wallEnd.getY());

                // Get the x coordinate of the wall segment
                int x = wallStart.getX();

                if (current.getX() < x && newCell.getX() >= x && newY >= minY && newY <= maxY) {
                    newCell.setX(x - 1); // If moving right and hitting a vertical wall, stop left of it
                }
                if (current.getX() > x && newCell.getX() <= x && newY >= minY && newY <= maxY) {
                    newCell.setX(x + 1); // If moving left and hitting a vertical wall, stop right of it
                }

            }
        }

// Update the current cell with the new cell
        current = newCell;

// Return a string representation of the current cell
        return current.toString();
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);
}
",7216,206,42.74390243902439,104,0.2669902912621359,0.08737864077669903,0.038834951456310676,0.0048543689320388345,0.3155339805825243,0.0,0.20388349514563106,0.0,True,False,False,False,False,False,2,0.043689320388349516,0.038834951456310676,0.07281553398058252,0.014563106796116505,0.39805825242718446,0.18932038834951456,0.0,5.052631578947368,10,48.054545454545455,95
11,gpt3.5,cc,,"package thkoeln.st.st2praktikum.exercise;

import java.util.Arrays;
import java.util.List;

public class Exercise0 implements GoAble {

    private static final int GRID_WIDTH = 12;
    private static final int GRID_HEIGHT = 8;
    private static final int[][] OBSTACLES = {{6, 2, 6, 5}, {5, 5, 6, 5}, {5, 5, 5, 6}, {5, 6, 12, 6}};
    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

    private int[] position = {11, 7};

    public String goTo(String goCommandString) throws IllegalArgumentException {
        int[] newPosition = Arrays.copyOf(position, position.length);
        String[] goCommand = goCommandString.replaceAll(""[^A-Za-z0-9]"", """").split(""(?<=\\D)(?=\\d)|(?<=\\d)(?=\\D)"");

        if (goCommand.length != 2) {
            throw new IllegalArgumentException(""Invalid command: "" + goCommandString);
        }

        int steps = Integer.parseInt(goCommand[1]);
        int directionIndex = getDirectionIndex(goCommand[0]);

        while (steps > 0) {
            int[] nextPosition = Arrays.copyOf(newPosition, newPosition.length);
            nextPosition[0] += DIRECTIONS[directionIndex][0];
            nextPosition[1] += DIRECTIONS[directionIndex][1];

            if (isOutOfBounds(nextPosition) || collidesWithObstacle(newPosition, nextPosition)) {
                break;
            }

            newPosition = nextPosition;
            steps--;
        }

        position = newPosition;
        return ""("" + position[0] + "","" + position[1] + "")"";
    }

    private boolean isOutOfBounds(int[] position) {
        return position[0] < 0 || position[0] >= GRID_WIDTH || position[1] < 0 || position[1] >= GRID_HEIGHT;
    }

    private boolean collidesWithObstacle(int[] currentPosition, int[] nextPosition) {
        for (int[] obstacle : OBSTACLES) {
            if (currentPosition[0] == nextPosition[0] && currentPosition[0] == obstacle[0]
                    && obstacle[1] <= Math.max(currentPosition[1], nextPosition[1]) && obstacle[3] >= Math.min(currentPosition[1], nextPosition[1])) {
                return true;
            }
            if (currentPosition[1] == nextPosition[1] && currentPosition[1] == obstacle[1]
                    && obstacle[0] <= Math.max(currentPosition[0], nextPosition[0]) && obstacle[2] >= Math.min(currentPosition[0], nextPosition[0])) {
                return true;
            }
        }
        return false;
    }

    private int getDirectionIndex(String direction) throws IllegalArgumentException {
        List<String> directions = Arrays.asList(""no"", ""ea"", ""so"", ""we"");
        int directionIndex = directions.indexOf(direction.toLowerCase());
        if (directionIndex == -1) {
            throw new IllegalArgumentException(""Invalid direction: "" + direction);
        }
        return directionIndex;
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String goTo(String goCommandString);
}
",2936,75,48.49152542372882,150,0.0,0.06666666666666667,0.013333333333333334,0.0,0.9733333333333334,0.02666666666666667,0.21333333333333335,0.0,False,True,False,False,False,False,2,0.06666666666666667,0.06666666666666667,0.09333333333333334,0.013333333333333334,0.7333333333333333,0.2,0.02666666666666667,10.133333333333333,15,0.0,0
11,gpt4,plain,,"package thkoeln.st.st2praktikum.exercise;

import java.awt.Point;

public class Exercise0 implements Walkable {
    private int width = 12;
    private int height = 9;
    private Point currentLocation = new Point(0, 2);

    private static final String NORTH = ""no"";
    private static final String EAST = ""ea"";
    private static final String SOUTH = ""so"";
    private static final String WEST = ""we"";

    private boolean[][] horizontalWalls = new boolean[width + 1][height];
    private boolean[][] verticalWalls = new boolean[width][height + 1];

    public Exercise0() {
        initializeWalls();
    }

    private void initializeWalls() {
        for (int i = 0; i <= width; i++) {
            verticalWalls[i][0] = true;
            verticalWalls[i][height] = true;
        }

        for (int i = 0; i <= height; i++) {
            horizontalWalls[0][i] = true;
            horizontalWalls[width][i] = true;
        }

        addWall(3, 0, 3, 3);
        addWall(5, 0, 5, 4);
        addWall(4, 5, 7, 5);
        addWall(7, 5, 7, 9);
    }

    private void addWall(int x1, int y1, int x2, int y2) {
        if (x1 == x2) {
            for (int i = y1; i <= y2; i++) {
                verticalWalls[x1][i] = true;
            }
        } else if (y1 == y2) {
            for (int i = x1; i <= x2; i++) {
                horizontalWalls[i][y1] = true;
            }
        }
    }

    @Override
    public String walk(String walkCommandString) {
        String[] commandParts = walkCommandString.substring(1, walkCommandString.length() - 1).split("","");

        String direction = commandParts[0];
        int steps = Integer.parseInt(commandParts[1]);

        for (int i = 0; i < steps; i++) {
            if (!move(direction)) {
                break;
            }
        }

        return currentLocation.toString();
    }

    private boolean move(String direction) {
        int x = currentLocation.x;
        int y = currentLocation.y;

        switch (direction) {
            case NORTH:
                if (!horizontalWalls[x][y + 1]) {
                    currentLocation.y++;
                    return true;
                }
                break;
            case EAST:
                if (!verticalWalls[x + 1][y]) {
                    currentLocation.x++;
                    return true;
                }
                break;
            case SOUTH:
                if (!horizontalWalls[x][y]) {
                    currentLocation.y--;
                    return true;
                }
                break;
            case WEST:
                if (!verticalWalls[x][y]) {
                    currentLocation.x--;
                    return true;
                }
                break;
        }
        return false;
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",2887,105,31.613636363636363,106,0.0,0.06666666666666667,0.047619047619047616,0.009523809523809525,0.49523809523809526,0.0,0.1619047619047619,0.0,True,False,False,True,False,False,2,0.047619047619047616,0.08571428571428572,0.047619047619047616,0.009523809523809525,0.6,0.10476190476190476,0.009523809523809525,5.428571428571429,15,0.0,0
12,bard,styled,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Moveable {
    private static final int W = 11;
    private static final int H = 8;
    private static final int Sx = 7;
    private static final int Sy = 7;
    private static final int[][] B = {{2, 1, 10, 1}, {2, 1, 2, 6}, {2, 6, 7, 6}, {10, 1, 10, 8}};
    private int x = Sx;
    private int y = Sy;
    public Exercise0() {}
    @Override
    public String move(String moveCommandString) {
        String[] tokens = moveCommandString.substring(1, moveCommandString.length() - 1).split("","");
        String d = tokens[0];
        int s = Integer.parseInt(tokens[1]);
        if (d.equals(""no"")) {
            for (int i = 0; i < s; i++) {
                if (y - 1 < 0 || isBarrier(x, y - 1)) {
                    break;
                }
                y--;
            }
        } else if (d.equals(""ea"")) {
            for (int i = 0; i < s; i++) {
                if (x + 1 >= W || isBarrier(x + 1, y)) {
                    break;
                }
                x++;
            }
        } else if (d.equals(""so"")) {
            for (int i = 0; i < s; i++) {
                if (y + 1 >= H || isBarrier(x, y + 1)) {
                    break;
                }
                y++;
            }
        } else if (d.equals(""we"")) {
            for (int i = 0; i < s; i++) {
                if (x - 1 < 0 || isBarrier(x - 1, y)) {
                    break;
                }
                x--;
            }
        }
        return ""("" + x + "","" + y + "")"";
    }
    private boolean isBarrier(int x, int y) {
        for (int[] barrier : B) {
            if (x >= barrier[0] && x <= barrier[2] && y >= barrier[1] && y <= barrier[3]) {
                return true;
            }
        }
        return false;
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String move(String moveCommandString);
}
",1930,61,31.677966101694917,100,0.0,0.14754098360655737,0.08196721311475409,0.0,0.819672131147541,0.0,0.03278688524590164,0.0,False,False,False,False,False,False,2,0.04918032786885246,0.11475409836065574,0.04918032786885246,0.01639344262295082,0.7377049180327869,0.19672131147540983,0.0,2.1818181818181817,7,0.0,0
12,bing,styled,creative,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Walkable {

    private static final String NORTH = ""no"";
    private static final String EAST = ""ea"";
    private static final String SOUTH = ""so"";
    private static final String WEST = ""we"";

    private static final int WIDTH = 12;
    private static final int HEIGHT = 8;
    private static final int[][] WALLS = {{3, 0, 3, 3}, {4, 3, 7, 3}, {7, 0, 7, 2}, {1, 4, 8, 4}};

    private int x;
    private int y;

    public Exercise0() {
        x = 3;
        y = 0;
    }

    public String walkTo(String c) {
        c = c.replace(""["", """").replace(""]"", """");
        String[] p = c.split("","");
        String d = p[0];
        int s = Integer.parseInt(p[1]);

        switch (d) {
            case NORTH:
                moveNorth(s);
                break;
            case EAST:
                moveEast(s);
                break;
            case SOUTH:
                moveSouth(s);
                break;
            case WEST:
                moveWest(s);
                break;
            default:
                break;
        }

        return ""("" + x + "","" + y + "")"";
    }

    private void moveNorth(int s) {
        for (int i = 0; i < s; i++) {
            if (y == HEIGHT - 1 || hasWall(x, y + 1)) {
                break;
            } else {
                y++;
            }
        }
    }

    private void moveEast(int s) {
        for (int i = 0; i < s; i++) {
            if (x == WIDTH - 1 || hasWall(x + 1, y)) {
                break;
            } else {
                x++;
            }
        }
    }

    private void moveSouth(int s) {
        for (int i = 0; i < s; i++) {
            if (y == 0 || hasWall(x, y - 1)) {
                break;
            } else {
                y--;
            }
        }
    }

    private void moveWest(int s) {
        for (int i = 0; i < s; i++) {
            if (x == 0 || hasWall(x - 1, y)) {
                break;
            } else {
                x--;
            }
        }
    }

    private boolean hasWall(int x, int y) {
        for (int[] w : WALLS) {
            int x1 = w[0];
            int y1 = w[1];
            int x2 = w[2];
            int y2 = w[3];
            if (x1 == x2 && x == x1 && y >= y1 && y <= y2) {
                return true;
            }
            if (y1 == y2 && y == y1 && x >= x1 && x <= x2) {
                return true;
            }
        }
        return false;
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);
}
",2602,108,26.53191489361702,98,0.0,0.05555555555555555,0.046296296296296294,0.009259259259259259,0.5277777777777778,0.0,0.12962962962962962,0.0,False,False,False,False,False,False,2,0.06481481481481481,0.08333333333333333,0.06481481481481481,0.009259259259259259,0.5833333333333334,0.1111111111111111,0.0,2.1333333333333333,6,0.0,0
12,gpt3.5,cc,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements GoAble {
    private static final int WIDTH = 12;
    private static final int HEIGHT = 8;
    private static final int[][] OBSTACLES = {{6,2,6,5}, {5,5,6,5}, {5,5,5,6}, {5,6,12,6}};
    private static final int[][] DIRECTIONS = {{0,1}, {1,0}, {0,-1}, {-1,0}}; // {dx, dy} for each direction
    private int x;
    private int y;

    public Exercise0() {
        this.x = 11;
        this.y = 7;
    }

    public String goTo(String goCommandString) {
        String[] commandParts = goCommandString.replaceAll(""[\\[\\]]"", """").split("","");
        int directionIndex = getDirectionIndex(commandParts[0]);
        int steps = Integer.parseInt(commandParts[1]);

        int dx = DIRECTIONS[directionIndex][0];
        int dy = DIRECTIONS[directionIndex][1];

        for (int i = 0; i < steps; i++) {
            int newX = x + dx;
            int newY = y + dy;
            boolean obstacleHit = false;

            // Check if new position hits an obstacle or boundary
            for (int[] obstacle : OBSTACLES) {
                if (dx == 0 && obstacle[0] <= newX && newX <= obstacle[2] && obstacle[1] <= y && y <= obstacle[3]) {
                    newX = obstacle[0] - 1;
                    obstacleHit = true;
                } else if (dy == 0 && obstacle[1] <= newY && newY <= obstacle[3] && obstacle[0] <= x && x <= obstacle[2]) {
                    newY = obstacle[1] - 1;
                    obstacleHit = true;
                }
            }
            if (newX < 0) newX = 0;
            if (newX >= WIDTH) newX = WIDTH - 1;
            if (newY < 0) newY = 0;
            if (newY >= HEIGHT) newY = HEIGHT - 1;

            if (obstacleHit) {
                break; // Stop if obstacle hit
            } else {
                x = newX;
                y = newY;
            }
        }

        return ""("" + (x+1) + "","" + (y+1) + "")"";
    }

    private int getDirectionIndex(String direction) {
        switch (direction) {
            case ""no"":
                return 0;
            case ""ea"":
                return 1;
            case ""so"":
                return 2;
            case ""we"":
                return 3;
            default:
                throw new IllegalArgumentException(""Invalid direction: "" + direction);
        }
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String goTo(String goCommandString);
}
",2456,74,37.21875,123,0.04054054054054054,0.12162162162162163,0.04054054054054054,0.013513513513513514,0.8918918918918919,0.013513513513513514,0.13513513513513514,0.0,True,False,False,False,False,False,2,0.04054054054054054,0.08108108108108109,0.10810810810810811,0.013513513513513514,0.8243243243243243,0.05405405405405406,0.0,6.117647058823529,14,32.333333333333336,50
12,gpt4,plain,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Walkable {

    private int x = 0;
    private int y = 2;
    private final int maxX = 11;
    private final int maxY = 8;
    private final int[][] walls = {
            {3, 0, 3, 3},
            {5, 0, 5, 4},
            {4, 5, 7, 5},
            {7, 5, 7, 9}
    };

    @Override
    public String walk(String walkCommandString) {
        String[] commandParts = walkCommandString.substring(1, walkCommandString.length() - 1).split("","");
        String direction = commandParts[0].trim();
        int steps = Integer.parseInt(commandParts[1].trim());

        switch (direction) {
            case ""no"":
                y += steps;
                for (int[] wall : walls) {
                    if (wall[0] == wall[2] && y >= wall[1] && y <= wall[3] && x == wall[0] - 1) {
                        y = wall[1] - 1;
                        break;
                    }
                }
                if (y > maxY) y = maxY;
                break;

            case ""ea"":
                x += steps;
                for (int[] wall : walls) {
                    if (wall[0] == wall[2] && x == wall[0] && y >= wall[1] - 1 && y < wall[3]) {
                        x = wall[0] - 1;
                        break;
                    }
                }
                if (x > maxX) x = maxX;
                break;

            case ""so"":
                y -= steps;
                for (int[] wall : walls) {
                    if (wall[0] == wall[2] && y <= wall[3] && y >= wall[1] && x == wall[0] - 1) {
                        y = wall[3] + 1;
                        break;
                    }
                }
                if (y < 0) y = 0;
                break;

            case ""we"":
                x -= steps;
                for (int[] wall : walls) {
                    if (wall[0] == wall[2] && x == wall[2] && y >= wall[1] - 1 && y < wall[3]) {
                        x = wall[2] + 1;
                        break;
                    }
                }
                if (x < 0) x = 0;
                break;
        }

        return String.format(""(%d,%d)"", x, y);
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",2301,75,33.72727272727273,106,0.0,0.10666666666666667,0.06666666666666667,0.013333333333333334,0.8533333333333334,0.0,0.12,0.0,False,False,False,False,False,False,2,0.02666666666666667,0.06666666666666667,0.04,0.013333333333333334,0.92,0.09333333333333334,0.0,5.0,12,0.0,0
13,bard,cc,,"package thkoeln.st.st2praktikum.exercise;

import java.util.Arrays;

public class Exercise0 implements Moveable {

    private static final int SPACE_WIDTH = 11;
    private static final int SPACE_HEIGHT = 8;
    private static final int START_X = 7;
    private static final int START_Y = 7;
    private static final int[][] BARRIERS = {{2, 1, 10, 1}, {2, 1, 2, 6}, {2, 6, 7, 6}, {10, 1, 10, 8}};

    private int x;
    private int y;

    public Exercise0() {
        this.x = START_X;
        this.y = START_Y;
    }

    @Override
    public String move(String moveCommandString) {
        // Parse the move command string.
        String[] parts = moveCommandString.substring(1, moveCommandString.length() - 1).split("","");
        String direction = parts[0];
        int steps = Integer.parseInt(parts[1]);

        // Check if the direction is valid.
        if (!isValidDirection(direction)) {
            throw new IllegalArgumentException(""Invalid direction: "" + direction);
        }

        // Check if the steps are valid.
        if (steps < 1) {
            throw new IllegalArgumentException(""Invalid steps: "" + steps);
        }

        // Move the cleaning device.
        for (int i = 0; i < steps; i++) {
            // Check if the cleaning device will hit a barrier.
            if (isBarrier(x, y + (direction.equals(""no"") ? -1 : direction.equals(""so"") ? 1 : 0))) {
                break;
            }

            // Move the cleaning device.
            if (direction.equals(""no"")) {
                y--;
            } else if (direction.equals(""ea"")) {
                x++;
            } else if (direction.equals(""so"")) {
                y++;
            } else if (direction.equals(""we"")) {
                x--;
            }
        }

        // Return the new coordinates of the cleaning device.
        return ""("" + x + "", "" + y + "")"";
    }

    // Check if the given direction is valid.
    private boolean isValidDirection(String direction) {
        return Arrays.asList(""no"", ""ea"", ""so"", ""we"").contains(direction);
    }

    // Check if the given coordinates are within the bounds of the space.
    private boolean isWithinBounds(int x, int y) {
        return 0 <= x && x < SPACE_WIDTH && 0 <= y && y < SPACE_HEIGHT;
    }

    // Check if the given coordinates are within a barrier.
    private boolean isBarrier(int x, int y) {
        for (int[] barrier : BARRIERS) {
            if (isWithinBounds(x, y) && x >= barrier[0] && x <= barrier[2] && y >= barrier[1] && y <= barrier[3]) {
                return true;
            }
        }
        return false;
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String move(String moveCommandString);
}
",2729,85,37.77142857142857,115,0.11764705882352941,0.16470588235294117,0.023529411764705882,0.0,0.5058823529411764,0.023529411764705882,0.17647058823529413,0.0,False,False,False,False,False,False,2,0.058823529411764705,0.08235294117647059,0.03529411764705882,0.011764705882352941,0.4588235294117647,0.17647058823529413,0.011764705882352941,6.166666666666667,12,39.5,66
13,bing,plain,creative,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Walkable {

    // The width and height of the room in cells
    private static final int ROOM_WIDTH = 12;
    private static final int ROOM_HEIGHT = 8;

    // The initial x and y coordinates of the robot in cells
    private static final int INITIAL_X = 3;
    private static final int INITIAL_Y = 0;

    // The current x and y coordinates of the robot in cells
    private int x;
    private int y;

    // A two-dimensional array that represents the room grid
    // A cell is true if it is blocked by a wall or a boundary, false otherwise
    private boolean[][] grid;

    // A constructor that initializes the robot and the grid
    public Exercise0() {
        // Set the initial position of the robot
        x = INITIAL_X;
        y = INITIAL_Y;

        // Create the grid with the given width and height
        grid = new boolean[ROOM_WIDTH][ROOM_HEIGHT];

        // Mark the boundaries of the room as blocked cells
        for (int i = 0; i < ROOM_WIDTH; i++) {
            grid[i][0] = true; // bottom boundary
            grid[i][ROOM_HEIGHT - 1] = true; // top boundary
        }
        for (int j = 0; j < ROOM_HEIGHT; j++) {
            grid[0][j] = true; // left boundary
            grid[ROOM_WIDTH - 1][j] = true; // right boundary
        }

        // Mark the walls as blocked cells
        for (int j = 0; j <= 3; j++) {
            grid[3][j] = true; // wall between (3,0) and (3,3)
        }
        for (int i = 4; i <= 7; i++) {
            grid[i][3] = true; // wall between (4,3) and (7,3)
        }
        for (int j = 0; j <= 2; j++) {
            grid[7][j] = true; // wall between (7,0) and (7,2)
        }
        for (int i = 1; i <= 8; i++) {
            grid[i][4] = true; // wall between (1,4) and (8,4)
        }
    }

    // A method that implements the Walkable interface
    public String walkTo(String walkCommandString) {
        // Parse the walk command string into direction and steps
        String direction = walkCommandString.substring(1, 3); // e.g. ""no""
        int steps = Integer.parseInt(walkCommandString.substring(4, walkCommandString.length() - 1)); // e.g. 2

        // Move the robot according to the direction and steps
        switch (direction) {
            case ""no"": // north
                for (int i = 0; i < steps; i++) {
                    if (y < ROOM_HEIGHT - 1 && !grid[x][y + 1]) { // check if the robot is not at the top boundary and the next cell is not blocked
                        y++; // move one cell up
                    } else {
                        break; // stop moving if at the boundary or blocked by a wall
                    }
                }
                break;
            case ""ea"": // east
                for (int i = 0; i < steps; i++) {
                    if (x < ROOM_WIDTH - 1 && !grid[x + 1][y]) { // check if the robot is not at the right boundary and the next cell is not blocked
                        x++; // move one cell right
                    } else {
                        break; // stop moving if at the boundary or blocked by a wall
                    }
                }
                break;
            case ""so"": // south
                for (int i = 0; i < steps; i++) {
                    if (y > 0 && !grid[x][y - 1]) { // check if the robot is not at the bottom boundary and the next cell is not blocked
                        y--; // move one cell down
                    } else {
                        break; // stop moving if at the boundary or blocked by a wall
                    }
                }
                break;
            case ""we"": // west
                for (int i = 0; i < steps; i++) {
                    if (x > 0 && !grid[x - 1][y]) { // check if the robot is not at the left boundary and the next cell is not blocked
                        x--; // move one cell left
                    } else {
                        break; // stop moving if at the boundary or blocked by a wall
                    }
                }
                break;
            default: // invalid direction
                throw new IllegalArgumentException(""Invalid direction: "" + direction);
        }

        // Return the current position of the robot as a string
        return ""("" + x + "","" + y + "")"";
    }
}


package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);
}
",4479,113,44.55102040816327,148,0.36283185840707965,0.11504424778761062,0.08849557522123894,0.008849557522123894,0.5309734513274337,0.008849557522123894,0.12389380530973451,0.0,True,False,False,False,False,False,2,0.017699115044247787,0.061946902654867256,0.017699115044247787,0.008849557522123894,0.6814159292035398,0.035398230088495575,0.0,5.545454545454546,11,36.609756097560975,81
13,gpt3.5,cc,,"package thkoeln.st.st2praktikum.exercise;

import java.util.Arrays;
import java.util.List;

public class Exercise0 implements GoAble {

    private static final int GRID_WIDTH = 12;
    private static final int GRID_HEIGHT = 8;
    private static final int[][] OBSTACLES = {{6, 2, 6, 5}, {5, 5, 6, 5}, {5, 5, 5, 6}, {5, 6, 12, 6}};
    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

    private int[] position = {11, 7};

    public String goTo(String goCommandString) throws IllegalArgumentException {
        int[] newPosition = Arrays.copyOf(position, position.length);
        String[] goCommand = goCommandString.replaceAll(""[^A-Za-z0-9]"", """").split(""(?<=\\D)(?=\\d)|(?<=\\d)(?=\\D)"");

        if (goCommand.length != 2) {
            throw new IllegalArgumentException(""Invalid command: "" + goCommandString);
        }

        int steps = Integer.parseInt(goCommand[1]);
        int directionIndex = getDirectionIndex(goCommand[0]);

        while (steps > 0) {
            int[] nextPosition = Arrays.copyOf(newPosition, newPosition.length);
            nextPosition[0] += DIRECTIONS[directionIndex][0];
            nextPosition[1] += DIRECTIONS[directionIndex][1];

            if (isOutOfBounds(nextPosition) || collidesWithObstacle(newPosition, nextPosition)) {
                break;
            }

            newPosition = nextPosition;
            steps--;
        }

        position = newPosition;
        return ""("" + position[0] + "","" + position[1] + "")"";
    }

    private boolean isOutOfBounds(int[] position) {
        return position[0] < 0 || position[0] >= GRID_WIDTH || position[1] < 0 || position[1] >= GRID_HEIGHT;
    }

    private boolean collidesWithObstacle(int[] currentPosition, int[] nextPosition) {
        for (int[] obstacle : OBSTACLES) {
            if (currentPosition[0] == nextPosition[0] && currentPosition[0] == obstacle[0]
                    && obstacle[1] <= Math.max(currentPosition[1], nextPosition[1]) && obstacle[3] >= Math.min(currentPosition[1], nextPosition[1])) {
                return true;
            }
            if (currentPosition[1] == nextPosition[1] && currentPosition[1] == obstacle[1]
                    && obstacle[0] <= Math.max(currentPosition[0], nextPosition[0]) && obstacle[2] >= Math.min(currentPosition[0], nextPosition[0])) {
                return true;
            }
        }
        return false;
    }

    private int getDirectionIndex(String direction) throws IllegalArgumentException {
        List<String> directions = Arrays.asList(""no"", ""ea"", ""so"", ""we"");
        int directionIndex = directions.indexOf(direction.toLowerCase());
        if (directionIndex == -1) {
            throw new IllegalArgumentException(""Invalid direction: "" + direction);
        }
        return directionIndex;
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String goTo(String goCommandString);
}
",2936,75,48.49152542372882,150,0.0,0.06666666666666667,0.013333333333333334,0.0,0.9733333333333334,0.02666666666666667,0.21333333333333335,0.0,False,True,False,False,False,False,2,0.06666666666666667,0.06666666666666667,0.09333333333333334,0.013333333333333334,0.7333333333333333,0.2,0.02666666666666667,10.133333333333333,15,0.0,0
13,gpt4,plain,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Walkable {
    private int x;
    private int y;
    private final int maxX = 12;
    private final int maxY = 9;
    private final int[][] walls = {
            {3, 0, 3, 3},
            {5, 0, 5, 4},
            {4, 5, 7, 5},
            {7, 5, 7, 9},
    };

    public Exercise0() {
        this.x = 0;
        this.y = 2;
    }

    @Override
    public String walk(String walkCommandString) {
        String[] commandParts = walkCommandString.replace(""["", """").replace(""]"", """").split("","");
        String direction = commandParts[0].trim();
        int steps = Integer.parseInt(commandParts[1].trim());

        switch (direction) {
            case ""no"":
                for (int i = 0; i < steps; i++) {
                    if (canMove(x, y + 1)) {
                        y++;
                    } else {
                        break;
                    }
                }
                break;
            case ""ea"":
                for (int i = 0; i < steps; i++) {
                    if (canMove(x + 1, y)) {
                        x++;
                    } else {
                        break;
                    }
                }
                break;
            case ""so"":
                for (int i = 0; i < steps; i++) {
                    if (canMove(x, y - 1)) {
                        y--;
                    } else {
                        break;
                    }
                }
                break;
            case ""we"":
                for (int i = 0; i < steps; i++) {
                    if (canMove(x - 1, y)) {
                        x--;
                    } else {
                        break;
                    }
                }
                break;
        }

        return ""("" + x + "","" + y + "")"";
    }

    private boolean canMove(int newX, int newY) {
        if (newX < 0 || newY < 0 || newX >= maxX || newY >= maxY) {
            return false;
        }

        for (int[] wall : walls) {
            if ((wall[0] == wall[2] && wall[0] == newX && ((newY >= wall[1] && newY < wall[3]) || (newY + 1 > wall[1] && newY + 1 <= wall[3]))) ||
                    (wall[1] == wall[3] && wall[1] == newY + 1 && ((newX >= wall[0] && newX < wall[2]) || (newX + 1 > wall[0] && newX + 1 <= wall[2])))) {
                return false;
            }
        }

        return true;
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",2545,87,31.512820512820515,154,0.0,0.06896551724137931,0.05747126436781609,0.011494252873563218,0.6436781609195402,0.0,0.10344827586206896,0.0,False,False,False,False,False,False,2,0.034482758620689655,0.05747126436781609,0.034482758620689655,0.011494252873563218,0.7126436781609196,0.11494252873563218,0.0,4.5,12,0.0,0
14,bard,cc,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Moveable {

    private static final int WIDTH = 11;
    private static final int HEIGHT = 8;
    private static final int START_X = 7;
    private static final int START_Y = 7;

    private static final int[][] BARRIERS = {
            {2, 1, 10, 1},
            {2, 1, 2, 6},
            {2, 6, 7, 6},
            {10, 1, 10, 8}
    };

    private int x;
    private int y;

    public Exercise0() {
        this.x = START_X;
        this.y = START_Y;
    }

    @Override
    public String move(String moveCommandString) {
        // Parse the move command string.
        String[] tokens = moveCommandString.substring(1, moveCommandString.length() - 1).split("","");
        String direction = tokens[0];
        int steps = Integer.parseInt(tokens[1]);

        // Check if the direction is valid.
        if (!isValidDirection(direction)) {
            throw new IllegalArgumentException(""Invalid direction: "" + direction);
        }

        // Move the cleaning device in the specified direction.
        for (int i = 0; i < steps; i++) {
            if (!moveInDirection(direction)) {
                break;
            }
        }

        // Return the new coordinates of the cleaning device.
        return ""("" + x + "","" + y + "")"";
    }

    private boolean moveInDirection(String direction) {
        switch (direction) {
            case ""no"":
                if (isBarrier(x, y - 1)) {
                    return false;
                }
                y--;
                break;
            case ""ea"":
                if (isBarrier(x + 1, y)) {
                    return false;
                }
                x++;
                break;
            case ""so"":
                if (isBarrier(x, y + 1)) {
                    return false;
                }
                y++;
                break;
            case ""we"":
                if (isBarrier(x - 1, y)) {
                    return false;
                }
                x--;
                break;
            default:
                return false;
        }

        return true;
    }

    private boolean isValidDirection(String direction) {
        return direction.equals(""no"") || direction.equals(""ea"") || direction.equals(""so"") || direction.equals(""we"");
    }

    private boolean isBarrier(int x, int y) {
        for (int[] barrier : BARRIERS) {
            if (x >= barrier[0] && x <= barrier[2] && y >= barrier[1] && y <= barrier[3]) {
                return true;
            }
        }

        return false;
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String move(String moveCommandString);
}
",2710,99,31.083333333333332,116,0.04040404040404041,0.09090909090909091,0.020202020202020204,0.010101010101010102,0.41414141414141414,0.010101010101010102,0.15151515151515152,0.0,False,False,False,False,False,False,2,0.050505050505050504,0.0707070707070707,0.030303030303030304,0.010101010101010102,0.36363636363636365,0.1414141414141414,0.0,5.2,9,41.0,52
14,bing,plain,precise,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Walkable {
    private int x = 3;
    private int y = 0;
    private int width = 12;
    private int height = 8;
    private boolean[][] walls = new boolean[width][height];

    public Exercise0() {
        for (int i = 0; i <= 3; i++) walls[3][i] = true;
        for (int i = 4; i <= 7; i++) walls[i][3] = true;
        for (int i = 0; i <= 2; i++) walls[7][i] = true;
        for (int i = 1; i <= 8; i++) walls[i][4] = true;
    }

    @Override
    public String walkTo(String walkCommandString) {
        String[] parts = walkCommandString.split("","");
        String direction = parts[0].substring(1);
        int steps = Integer.parseInt(parts[1].substring(0, parts[1].length() - 1));
        switch (direction) {
            case ""no"":
                while (steps > 0 && y + 1 < height && !walls[x][y + 1]) {
                    y++;
                    steps--;
                }
                break;
            case ""ea"":
                while (steps > 0 && x + 1 < width && !walls[x + 1][y]) {
                    x++;
                    steps--;
                }
                break;
            case ""so"":
                while (steps > 0 && y > 0 && !walls[x][y - 1]) {
                    y--;
                    steps--;
                }
                break;
            case ""we"":
                while (steps > 0 && x > 0 && !walls[x][y]) {
                    x--;
                    steps--;
                }
                break;
        }
        return ""("" + x + "","" + y + "")"";
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);
}
",1717,55,32.588235294117645,83,0.0,0.0,0.07272727272727272,0.01818181818181818,0.6909090909090909,0.0,0.07272727272727272,0.0,True,False,False,False,False,False,2,0.03636363636363636,0.09090909090909091,0.05454545454545454,0.01818181818181818,0.9818181818181818,0.09090909090909091,0.0,4.222222222222222,9,0.0,0
14,gpt3.5,cc,,"package thkoeln.st.st2praktikum.exercise;

import java.util.Arrays;
import java.util.List;

public class Exercise0 implements GoAble {

    private final int SPACESHIP_WIDTH = 12;
    private final int SPACESHIP_HEIGHT = 8;

    private final List<int[]> OBSTACLES = Arrays.asList(
            new int[]{6, 2, 6, 5},
            new int[]{5, 5, 6, 5},
            new int[]{5, 5, 5, 6},
            new int[]{5, 6, 12, 6}
    );

    private int[] droidPosition = new int[]{11, 7};

    @Override
    public String goTo(String goCommandString) throws IllegalArgumentException {
        int[] newDroidPosition = Arrays.copyOf(droidPosition, droidPosition.length);
        String[] goCommand = parseCommand(goCommandString);

        int steps = Integer.parseInt(goCommand[1]);

        switch (goCommand[0]) {
            case ""no"":
                newDroidPosition[1] += steps;
                break;
            case ""ea"":
                newDroidPosition[0] += steps;
                break;
            case ""so"":
                newDroidPosition[1] -= steps;
                break;
            case ""we"":
                newDroidPosition[0] -= steps;
                break;
            default:
                throw new IllegalArgumentException(""Invalid direction: "" + goCommand[0]);
        }

        if (isPositionOutOfBounds(newDroidPosition)) {
            throw new IllegalArgumentException(""New position is out of bounds: "" + Arrays.toString(newDroidPosition));
        }

        if (doesIntersectObstacle(newDroidPosition)) {
            return formatCoordinateString(droidPosition);
        } else {
            droidPosition = newDroidPosition;
            return formatCoordinateString(droidPosition);
        }
    }

    private boolean doesIntersectObstacle(int[] position) {
        for (int[] obstacle : OBSTACLES) {
            if (doesOverlap(obstacle, position)) {
                return true;
            }
        }
        return false;
    }

    private boolean doesOverlap(int[] obstacle, int[] position) {
        // Obstacle is horizontal and overlaps with position
        if (obstacle[1] == obstacle[3] && obstacle[1] == position[1] && position[0] >= obstacle[0] && position[0] <= obstacle[2]) {
            return true;
        }
        // Obstacle is vertical and overlaps with position
        if (obstacle[0] == obstacle[2] && obstacle[0] == position[0] && position[1] >= obstacle[1] && position[1] <= obstacle[3]) {
            return true;
        }
        return false;
    }

    private boolean isPositionOutOfBounds(int[] position) {
        return position[0] < 0 || position[0] >= SPACESHIP_WIDTH || position[1] < 0 || position[1] >= SPACESHIP_HEIGHT;
    }

    private String[] parseCommand(String commandString) throws IllegalArgumentException {
        String[] command = commandString.replaceAll(""\\[|\\]"", """").split("","");
        if (command.length != 2) {
            throw new IllegalArgumentException(""Invalid command: "" + commandString);
        }
        return command;
    }

    private String formatCoordinateString(int[] coordinate) {
        return String.format(""(%d,%d)"", coordinate[0], coordinate[1]);
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String goTo(String goCommandString);
}
",3291,98,39.41975308641975,131,0.02040816326530612,0.061224489795918366,0.05102040816326531,0.01020408163265306,0.5918367346938775,0.030612244897959183,0.17346938775510204,0.0,False,True,False,False,False,False,2,0.07142857142857142,0.04081632653061224,0.04081632653061224,0.01020408163265306,0.5204081632653061,0.1326530612244898,0.02040816326530612,10.714285714285714,16,48.0,49
14,gpt4,plain,,"package thkoeln.st.st2praktikum.exercise;

import java.awt.Point;

public class Exercise0 implements Walkable {
    private int width = 12;
    private int height = 9;
    private Point position = new Point(0, 2);
    private static final String NORTH = ""no"";
    private static final String EAST = ""ea"";
    private static final String SOUTH = ""so"";
    private static final String WEST = ""we"";

    @Override
    public String walk(String walkCommandString) {
        String direction = walkCommandString.substring(1, 3);
        int steps = Integer.parseInt(walkCommandString.substring(4, walkCommandString.length() - 1));

        switch (direction) {
            case NORTH:
                position.y = Math.min(position.y + steps, height - 1);
                if (position.x <= 3 && position.y >= 3 && position.y <= 4) {
                    position.y = 3;
                } else if (position.x >= 4 && position.x <= 7 && position.y >= 5) {
                    position.y = 5;
                }
                break;
            case EAST:
                position.x = Math.min(position.x + steps, width - 1);
                if (position.y <= 3 && position.x >= 3 && position.x <= 5) {
                    position.x = 3;
                } else if (position.y >= 0 && position.y <= 4 && position.x >= 5 && position.x <= 6) {
                    position.x = 5;
                } else if (position.y >= 5 && position.y <= 9 && position.x >= 7) {
                    position.x = 7;
                }
                break;
            case SOUTH:
                position.y = Math.max(position.y - steps, 0);
                if (position.x <= 3 && position.y <= 2) {
                    position.y = 2;
                } else if (position.x >= 4 && position.x <= 7 && position.y <= 4) {
                    position.y = 4;
                }
                break;
            case WEST:
                position.x = Math.max(position.x - steps, 0);
                if (position.y >= 0 && position.y <= 3 && position.x <= 2) {
                    position.x = 2;
                } else if (position.y >= 0 && position.y <= 4 && position.x <= 4) {
                    position.x = 4;
                } else if (position.y >= 5 && position.y <= 9 && position.x <= 6) {
                    position.x = 6;
                }
                break;
        }

        return String.format(""(%d,%d)"", position.x, position.y);
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",2552,66,42.13559322033898,102,0.0,0.15151515151515152,0.015151515151515152,0.015151515151515152,0.8484848484848485,0.0,0.10606060606060606,0.0,False,False,False,True,False,False,2,0.030303030303030304,0.10606060606060606,0.030303030303030304,0.015151515151515152,0.8636363636363636,0.13636363636363635,0.015151515151515152,4.5,9,0.0,0
15,bard,cc,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Moveable {

    private static final String INVALID_DIRECTION_MESSAGE = ""Invalid direction: "";
    private static final String INVALID_STEPS_MESSAGE = ""Invalid number of steps: "";

    private int x = 7;
    private int y = 7;
    private int width = 11;
    private int height = 8;
    private String[] barriers = {""(2,1)-(10,1)"", ""(2,1)-(2,6)"", ""(2,6)-(7,6)"", ""(10,1)-(10,8)""};

    public String move(String moveCommandString) {
        // Check if the command string is valid.
        if (!moveCommandString.startsWith(""["") || !moveCommandString.endsWith(""]"")) {
            throw new IllegalArgumentException(""Invalid move command string: "" + moveCommandString);
        }

        // Parse the command string into its components.
        String[] parts = moveCommandString.substring(1, moveCommandString.length() - 1).split("","");
        String direction = parts[0];
        int steps = Integer.parseInt(parts[1]);

        // Check if the direction is valid.
        if (!isValidDirection(direction)) {
            throw new IllegalArgumentException(INVALID_DIRECTION_MESSAGE + direction);
        }

        // Check if the number of steps is valid.
        if (steps < 1) {
            throw new IllegalArgumentException(INVALID_STEPS_MESSAGE + steps);
        }

        // Move the cleaning device.
        for (int i = 0; i < steps; i++) {
            switch (direction) {
                case ""no"":
                    y--;
                    break;
                case ""ea"":
                    x++;
                    break;
                case ""so"":
                    y++;
                    break;
                case ""we"":
                    x--;
                    break;
                default:
                    throw new IllegalStateException(""Unknown direction: "" + direction);
            }

            // Check if the cleaning device has hit a barrier.
            if (isBarrier(x, y)) {
                break;
            }
        }

        // Return the new coordinates of the cleaning device.
        return ""("" + x + "","" + y + "")"";
    }

    private boolean isValidDirection(String direction) {
        return direction.equals(""no"") || direction.equals(""ea"") || direction.equals(""so"") || direction.equals(""we"");
    }

    private boolean isBarrier(int x, int y) {
        for (String barrier : barriers) {
            String[] coords = barrier.split(""-"");
            int x1 = Integer.parseInt(coords[0].substring(1, coords[0].length() - 1));
            int y1 = Integer.parseInt(coords[1].substring(1, coords[1].length() - 1));
            int x2 = Integer.parseInt(coords[2].substring(1, coords[2].length() - 1));
            int y2 = Integer.parseInt(coords[3].substring(1, coords[3].length() - 1));

            if (x >= x1 && x <= x2 && y >= y1 && y <= y2) {
                return true;
            }
        }

        return false;
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String move(String moveCommandString);
}
",3089,88,41.10958904109589,116,0.07954545454545454,0.10227272727272728,0.022727272727272728,0.011363636363636364,0.6477272727272727,0.045454545454545456,0.17045454545454544,0.0,False,False,False,False,False,False,2,0.045454545454545456,0.07954545454545454,0.09090909090909091,0.011363636363636364,0.4431818181818182,0.2840909090909091,0.0,7.133333333333334,25,39.142857142857146,50
15,bing,plain,creative,"package thkoeln.st.st2praktikum.exercise;

// A class that represents a tidy-up robot that can move in a room with walls
public class Exercise0 implements Walkable {

    // Constants for the directions
    private static final String NORTH = ""no"";
    private static final String EAST = ""ea"";
    private static final String SOUTH = ""so"";
    private static final String WEST = ""we"";

    // Constants for the room size and walls
    private static final int ROOM_WIDTH = 12;
    private static final int ROOM_HEIGHT = 8;
    private static final int[][] WALLS = {{3, 0, 3, 3}, {4, 3, 7, 3}, {7, 0, 7, 2}, {1, 4, 8, 4}};

    // Variables for the robot position
    private int x;
    private int y;

    // Constructor that sets the initial position of the robot
    public Exercise0() {
        x = 3;
        y = 0;
    }

    // A method that moves the robot according to a command string and returns its final position
    public String walkTo(String walkCommandString) {
        // Parse the command string and extract the direction and steps
        String direction = walkCommandString.substring(1, 3);
        int steps = Integer.parseInt(walkCommandString.substring(4, walkCommandString.length() - 1));

        // Move the robot according to the direction and steps using a for loop
        for (int i = 0; i < steps; i++) {
            // Check if the robot can move from its current position
            if (isWall(x, y) || isBoundary(x, y)) {
                // The robot cannot move
                break;
            }

            // Increment or decrement the position by one depending on the direction
            switch (direction) {
                case NORTH:
                    y++;
                    break;
                case EAST:
                    x++;
                    break;
                case SOUTH:
                    y--;
                    break;
                case WEST:
                    x--;
                    break;
                default:
                    // Invalid direction
                    return null;
            }

            // Check if the robot has hit a wall or a room boundary and adjust its position accordingly
            if (isWall(x, y)) {
                // The robot has hit a wall
                switch (direction) {
                    case NORTH:
                        y--;
                        break;
                    case EAST:
                        x--;
                        break;
                    case SOUTH:
                        y++;
                        break;
                    case WEST:
                        x++;
                        break;
                }
            }

            if (isBoundary(x, y)) {
                // The robot has hit a room boundary
                switch (direction) {
                    case NORTH:
                        y = ROOM_HEIGHT - 1;
                        break;
                    case EAST:
                        x = ROOM_WIDTH - 1;
                        break;
                    case SOUTH:
                        y = 0;
                        break;
                    case WEST:
                        x = 0;
                        break;
                }
            }
        }

        // Return the final position of the robot as a string
        return ""("" + x + "","" + y + "")"";
    }

    // A helper method that checks if a given position is a wall
    private boolean isWall(int x, int y) {
        for (int[] wall : WALLS) {
            if ((x == wall[0] || x == wall[2]) && y >= wall[1] && y <= wall[3]) {
                // The position is on a vertical wall
                return true;
            }
            if ((y == wall[1] || y == wall[3]) && x >= wall[0] && x <= wall[2]) {
                // The position is on a horizontal wall
                return true;
            }
        }
        return false;
    }

    // A helper method that checks if a given position is a room boundary
    private boolean isBoundary(int x, int y) {
        return x < 0 || x >= ROOM_WIDTH || y < 0 || y >= ROOM_HEIGHT;
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);
}
",4241,126,36.74107142857143,103,0.15873015873015872,0.07142857142857142,0.047619047619047616,0.023809523809523808,0.3492063492063492,0.0,0.1111111111111111,0.0,False,False,False,False,False,False,2,0.031746031746031744,0.07142857142857142,0.015873015873015872,0.007936507936507936,0.4365079365079365,0.06349206349206349,0.0,5.222222222222222,11,49.6,90
15,gpt3.5,styled,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements GoAble {

    private int x = 11;
    private int y = 7;

    private final int deckWidth = 12;
    private final int deckHeight = 8;

    private final int[][] obstacles = {{6,2,6,5}, {5,5,6,5}, {5,5,5,6}, {5,6,12,6}};

    public String goTo(String goCommandString) {
        String[] command = goCommandString.replaceAll(""[\\[\\]]"", """").split("","");

        String direction = command[0];
        int steps = Integer.parseInt(command[1]);

        switch (direction) {
            case ""no"":
                for (int i = 0; i < steps; i++) {
                    if (y+1 >= deckHeight) break;
                    boolean isObstacle = checkObstacles(x, y+1);
                    if (isObstacle) break;
                    y++;
                }
                break;
            case ""ea"":
                for (int i = 0; i < steps; i++) {
                    if (x+1 >= deckWidth) break;
                    boolean isObstacle = checkObstacles(x+1, y);
                    if (isObstacle) break;
                    x++;
                }
                break;
            case ""so"":
                for (int i = 0; i < steps; i++) {
                    if (y-1 < 0) break;
                    boolean isObstacle = checkObstacles(x, y-1);
                    if (isObstacle) break;
                    y--;
                }
                break;
            case ""we"":
                for (int i = 0; i < steps; i++) {
                    if (x-1 < 0) break;
                    boolean isObstacle = checkObstacles(x-1, y);
                    if (isObstacle) break;
                    x--;
                }
                break;
            default:
                System.out.println(""Invalid direction"");
                break;
        }

        return ""("" + x + "","" + y + "")"";
    }

    private boolean checkObstacles(int x2, int y2) {
        for (int[] obstacle : obstacles) {
            int x1 = obstacle[0];
            int y1 = obstacle[1];
            int x3 = obstacle[2];
            int y3 = obstacle[3];

            if (x2 >= x1 && x2 <= x3 && y2 >= y1 && y2 <= y3) {
                return true;
            }
        }

        return false;
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String goTo(String goCommandString);
}
",2369,80,34.16417910447761,84,0.0,0.1125,0.0625,0.0125,0.75,0.0,0.1625,0.0125,True,False,False,False,False,False,2,0.0375,0.0625,0.1375,0.0125,0.65,0.1,0.0,4.823529411764706,10,0.0,0
15,gpt4,plain,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Walkable {

    private int x;
    private int y;
    private final int fieldWidth = 12;
    private final int fieldHeight = 9;
    private final int[][] walls = {
            {3, 0, 3, 3},
            {5, 0, 5, 4},
            {4, 5, 7, 5},
            {7, 5, 7, 9}
    };

    public Exercise0() {
        x = 0;
        y = 2;
    }

    @Override
    public String walk(String walkCommandString) {
        String[] commandParts = walkCommandString.substring(1, walkCommandString.length() - 1).split("","");
        String direction = commandParts[0];
        int steps = Integer.parseInt(commandParts[1]);

        for (int i = 0; i < steps; i++) {
            int nextX = x;
            int nextY = y;

            switch (direction) {
                case ""no"":
                    nextY++;
                    break;
                case ""ea"":
                    nextX++;
                    break;
                case ""so"":
                    nextY--;
                    break;
                case ""we"":
                    nextX--;
                    break;
            }

            if (isValidMove(nextX, nextY)) {
                x = nextX;
                y = nextY;
            } else {
                break;
            }
        }

        return ""("" + x + "","" + y + "")"";
    }

    private boolean isValidMove(int x, int y) {
        if (x < 0 || x >= fieldWidth || y < 0 || y >= fieldHeight) {
            return false;
        }

        for (int[] wall : walls) {
            if (isCollidingWithWall(x, y, wall)) {
                return false;
            }
        }

        return true;
    }

    private boolean isCollidingWithWall(int x, int y, int[] wall) {
        if (wall[0] == wall[2]) {
            if (x == wall[0] && y >= wall[1] && y < wall[3]) {
                return true;
            }
        } else if (wall[1] == wall[3]) {
            if (y == wall[1] && x >= wall[0] && x < wall[2]) {
                return true;
            }
        }

        return false;
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",2214,90,28.32,106,0.0,0.07777777777777778,0.022222222222222223,0.011111111111111112,0.4666666666666667,0.0,0.16666666666666666,0.0,False,False,False,False,False,False,2,0.044444444444444446,0.05555555555555555,0.05555555555555555,0.011111111111111112,0.5333333333333333,0.06666666666666667,0.0,5.75,12,0.0,0
16,bard,cc,,"package thkoeln.st.st2praktikum.exercise;

import java.util.Arrays;
import java.util.List;

public class Exercise0 implements Moveable {

    private static final String DIRECTION_NO = ""no"";
    private static final String DIRECTION_EA = ""ea"";
    private static final String DIRECTION_SO = ""so"";
    private static final String DIRECTION_WE = ""we"";

    private int x = 7;
    private int y = 7;
    private int width = 11;
    private int height = 8;
    private List<Barrier> barriers = Arrays.asList(
            new Barrier(2, 1, 10, 1),
            new Barrier(2, 1, 2, 6),
            new Barrier(2, 6, 7, 6),
            new Barrier(10, 1, 10, 8)
    );

    public String move(String moveCommandString) {
        String[] parts = moveCommandString.substring(1, moveCommandString.length() - 1).split("","");
        String direction = parts[0];
        int steps = Integer.parseInt(parts[1]);

        try {
            switch (direction) {
                case DIRECTION_NO:
                    for (int i = 0; i < steps; i++) {
                        if (y - 1 < 0 || isBarrier(x, y - 1)) {
                            break;
                        }
                        y--;
                    }
                    break;
                case DIRECTION_EA:
                    for (int i = 0; i < steps; i++) {
                        if (x + 1 >= width || isBarrier(x + 1, y)) {
                            break;
                        }
                        x++;
                    }
                    break;
                case DIRECTION_SO:
                    for (int i = 0; i < steps; i++) {
                        if (y + 1 >= height || isBarrier(x, y + 1)) {
                            break;
                        }
                        y++;
                    }
                    break;
                case DIRECTION_WE:
                    for (int i = 0; i < steps; i++) {
                        if (x - 1 < 0 || isBarrier(x - 1, y)) {
                            break;
                        }
                        x--;
                    }
                    break;
            }
        } catch (Exception e) {
            throw new IllegalArgumentException(""Invalid move command"", e);
        }

        return ""("" + x + "","" + y + "")"";
    }

    private boolean isBarrier(int x, int y) {
        for (Barrier barrier : barriers) {
            if (barrier.contains(x, y)) {
                return true;
            }
        }
        return false;
    }

    private static class Barrier {
        private int x1;
        private int y1;
        private int x2;
        private int y2;

        public Barrier(int x1, int y1, int x2, int y2) {
            this.x1 = x1;
            this.y1 = y1;
            this.x2 = x2;
            this.y2 = y2;
        }

        public boolean contains(int x, int y) {
            return x >= x1 && x <= x2 && y >= y1 && y <= y2;
        }
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String move(String moveCommandString);
}
",3065,102,32.922222222222224,99,0.0,0.049019607843137254,0.049019607843137254,0.00980392156862745,0.6372549019607843,0.00980392156862745,0.11764705882352941,0.0,False,True,False,False,False,False,2,0.0392156862745098,0.12745098039215685,0.029411764705882353,0.0196078431372549,0.5392156862745098,0.09803921568627451,0.0196078431372549,3.5714285714285716,9,0.0,0
16,bing,plain,precise,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Walkable {
    private int x = 3;
    private int y = 0;
    private int width = 12;
    private int height = 8;
    private boolean[][] verticalWalls = new boolean[width + 1][height];
    private boolean[][] horizontalWalls = new boolean[width][height + 1];

    public Exercise0() {
        for (int i = 0; i <= 3; i++) {
            verticalWalls[3][i] = true;
        }
        for (int i = 4; i <= 7; i++) {
            horizontalWalls[i][3] = true;
        }
        for (int i = 0; i <= 2; i++) {
            verticalWalls[7][i] = true;
        }
        for (int i = 1; i <= 8; i++) {
            horizontalWalls[i][4] = true;
        }
    }

    @Override
    public String walkTo(String walkCommandString) {
        String[] parts = walkCommandString.substring(1, walkCommandString.length() - 1).split("","");
        String direction = parts[0];
        int steps = Integer.parseInt(parts[1]);

        switch (direction) {
            case ""no"":
                for (int i = 0; i < steps; i++) {
                    if (y + 1 >= height || horizontalWalls[x][y + 1]) break;
                    y++;
                }
                break;
            case ""ea"":
                for (int i = 0; i < steps; i++) {
                    if (x + 1 >= width || verticalWalls[x + 1][y]) break;
                    x++;
                }
                break;
            case ""so"":
                for (int i = 0; i < steps; i++) {
                    if (y - 1 < 0 || horizontalWalls[x][y]) break;
                    y--;
                }
                break;
            case ""we"":
                for (int i = 0; i < steps; i++) {
                    if (x - 1 < 0 || verticalWalls[x][y]) break;
                    x--;
                }
                break;
        }

        return ""("" + x + "","" + y + "")"";
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);
}
",2027,66,32.68333333333333,99,0.0,0.06060606060606061,0.12121212121212122,0.015151515151515152,0.5909090909090909,0.0,0.09090909090909091,0.0,True,False,False,False,False,False,2,0.030303030303030304,0.09090909090909091,0.045454545454545456,0.015151515151515152,0.8939393939393939,0.06060606060606061,0.0,6.1,15,0.0,0
16,gpt3.5,styled,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements GoAble {

    // values for the spaceship deck size and obstacle locations
    private final int WIDTH = 12;
    private final int HEIGHT = 8;
    private final int[][] OBSTACLES = {{6, 2, 6, 5}, {5, 5, 6, 5}, {5, 5, 5, 6}, {5, 6, 12, 6}};

    // initial position for the maintenance droid
    private int x = 11;
    private int y = 7;

    @Override
    public String goTo(String goCommandString) {
        // parse the goCommandString to get the direction and number of steps
        String direction = goCommandString.substring(1, 3);
        int steps = Integer.parseInt(goCommandString.substring(4, goCommandString.length() - 1));

        // update the position of the maintenance droid based on the given direction and number of steps
        switch (direction) {
            case ""no"":
                for (int i = 0; i < steps; i++) {
                    if (y + 1 >= HEIGHT) break;
                    boolean obstacleDetected = false;
                    for (int[] obstacle : OBSTACLES) {
                        if (obstacle[0] <= x && x <= obstacle[2] && obstacle[1] == y + 1) {
                            obstacleDetected = true;
                            break;
                        }
                    }
                    if (obstacleDetected) break;
                    y++;
                }
                break;
            case ""ea"":
                for (int i = 0; i < steps; i++) {
                    if (x + 1 >= WIDTH) break;
                    boolean obstacleDetected = false;
                    for (int[] obstacle : OBSTACLES) {
                        if (obstacle[1] <= y && y <= obstacle[3] && obstacle[0] == x + 1) {
                            obstacleDetected = true;
                            break;
                        }
                    }
                    if (obstacleDetected) break;
                    x++;
                }
                break;
            case ""so"":
                for (int i = 0; i < steps; i++) {
                    if (y - 1 < 0) break;
                    boolean obstacleDetected = false;
                    for (int[] obstacle : OBSTACLES) {
                        if (obstacle[0] <= x && x <= obstacle[2] && obstacle[3] == y - 1) {
                            obstacleDetected = true;
                            break;
                        }
                    }
                    if (obstacleDetected) break;
                    y--;
                }
                break;
            case ""we"":
                for (int i = 0; i < steps; i++) {
                    if (x - 1 < 0) break;
                    boolean obstacleDetected = false;
                    for (int[] obstacle : OBSTACLES) {
                        if (obstacle[1] <= y && y <= obstacle[3] && obstacle[2] == x - 1) {
                            obstacleDetected = true;
                            break;
                        }
                    }
                    if (obstacleDetected) break;
                    x--;
                }
                break;
        }

        // return the new position of the maintenance droid
        return ""("" + x + "","" + y + "")"";
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String goTo(String goCommandString);
}
",3361,89,40.39506172839506,104,0.056179775280898875,0.1348314606741573,0.11235955056179775,0.011235955056179775,0.6292134831460674,0.0,0.0898876404494382,0.0,True,False,False,False,False,False,2,0.02247191011235955,0.056179775280898875,0.06741573033707865,0.011235955056179775,0.6853932584269663,0.0449438202247191,0.0,6.1,16,61.2,93
16,gpt4,plain,,"package thkoeln.st.st2praktikum.exercise;

import java.awt.Point;
import java.util.ArrayList;
import java.util.List;

public class Exercise0 implements Walkable {
    private static final int FIELD_WIDTH = 12;
    private static final int FIELD_HEIGHT = 9;

    private Point machinePosition;
    private List<Wall> walls;

    public Exercise0() {
        machinePosition = new Point(0, 2);
        walls = new ArrayList<>();
        walls.add(new Wall(new Point(3, 0), new Point(3, 3)));
        walls.add(new Wall(new Point(5, 0), new Point(5, 4)));
        walls.add(new Wall(new Point(4, 5), new Point(7, 5)));
        walls.add(new Wall(new Point(7, 5), new Point(7, 9)));

        // Add field boundary walls
        walls.add(new Wall(new Point(0, 0), new Point(0, FIELD_HEIGHT)));
        walls.add(new Wall(new Point(0, 0), new Point(FIELD_WIDTH, 0)));
        walls.add(new Wall(new Point(FIELD_WIDTH, 0), new Point(FIELD_WIDTH, FIELD_HEIGHT)));
        walls.add(new Wall(new Point(0, FIELD_HEIGHT), new Point(FIELD_WIDTH, FIELD_HEIGHT)));
    }

    @Override
    public String walk(String walkCommandString) {
        String[] commandParts = walkCommandString.substring(1, walkCommandString.length() - 1).split("","");
        String direction = commandParts[0];
        int steps = Integer.parseInt(commandParts[1]);

        Point newPosition = new Point(machinePosition);
        for (int i = 0; i < steps; i++) {
            newPosition = getNextPosition(direction, newPosition);
            if (!canMoveTo(newPosition)) {
                break;
            }
            machinePosition = newPosition;
        }
        return ""("" + machinePosition.x + "","" + machinePosition.y + "")"";
    }

    private Point getNextPosition(String direction, Point position) {
        Point newPosition = new Point(position);
        switch (direction) {
            case ""no"":
                newPosition.y += 1;
                break;
            case ""ea"":
                newPosition.x += 1;
                break;
            case ""so"":
                newPosition.y -= 1;
                break;
            case ""we"":
                newPosition.x -= 1;
                break;
        }
        return newPosition;
    }

    private boolean canMoveTo(Point position) {
        if (position.x < 0 || position.y < 0 || position.x >= FIELD_WIDTH || position.y >= FIELD_HEIGHT) {
            return false;
        }

        for (Wall wall : walls) {
            if (wall.intersects(position)) {
                return false;
            }
        }
        return true;
    }

    private static class Wall {
        Point start;
        Point end;

        Wall(Point start, Point end) {
            this.start = start;
            this.end = end;
        }

        boolean intersects(Point position) {
            if (start.x == end.x) {
                // Vertical wall
                return position.y >= start.y && position.y < end.y &&
                        (position.x == start.x || position.x == start.x - 1);
            } else {
                // Horizontal wall
                return position.x >= start.x && position.x < end.x &&
                        (position.y == start.y || position.y == start.y - 1);
            }
        }
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",3379,104,36.388888888888886,106,0.028846153846153848,0.038461538461538464,0.019230769230769232,0.009615384615384616,0.4423076923076923,0.0,0.1346153846153846,0.0,False,True,False,True,False,False,2,0.04807692307692308,0.057692307692307696,0.04807692307692308,0.019230769230769232,0.5865384615384616,0.14423076923076922,0.028846153846153848,7.071428571428571,15,17.333333333333332,24
17,bard,plain,,"package thkoeln.st.st2praktikum.exercise;

import java.util.ArrayList;
import java.util.List;

public class Exercise0 implements Moveable {

    private static final int ROWS = 8;
    private static final int COLUMNS = 11;

    private static final List<List<Boolean>> BARRIERS = new ArrayList<>();
    static {
        for (int i = 0; i < ROWS; i++) {
            List<Boolean> row = new ArrayList<>();
            for (int j = 0; j < COLUMNS; j++) {
                row.add(false);
            }
            BARRIERS.add(row);
        }
        BARRIERS.get(1).set(0, true);
        BARRIERS.get(1).set(1, true);
        BARRIERS.get(1).set(2, true);
        BARRIERS.get(1).set(3, true);
        BARRIERS.get(1).set(4, true);
        BARRIERS.get(1).set(5, true);
        BARRIERS.get(1).set(6, true);
        BARRIERS.get(1).set(7, true);
        BARRIERS.get(1).set(8, true);
        BARRIERS.get(2).set(0, true);
        BARRIERS.get(2).set(6, true);
        BARRIERS.get(7).set(0, true);
        BARRIERS.get(7).set(8, true);
    }

    private int x;
    private int y;

    public Exercise0() {
        this.x = 7;
        this.y = 7;
    }

    @Override
    public String move(String moveCommandString) {
        String[] commandParts = moveCommandString.substring(1, moveCommandString.length() - 1).split("","");
        String direction = commandParts[0];
        int steps = Integer.parseInt(commandParts[1]);

        int newX = x;
        int newY = y;
        switch (direction) {
            case ""no"":
                newY -= steps;
                break;
            case ""ea"":
                newX += steps;
                break;
            case ""so"":
                newY += steps;
                break;
            case ""we"":
                newX -= steps;
                break;
        }

        while (newX < 0 || newX >= COLUMNS || newY < 0 || newY >= ROWS || BARRIERS.get(newY).get(newX)) {
            steps--;
            if (steps == 0) {
                break;
            }
            if (direction == ""no"") {
                newY++;
            } else if (direction == ""ea"") {
                newX++;
            } else if (direction == ""so"") {
                newY--;
            } else if (direction == ""we"") {
                newX--;
            }
        }

        if (steps > 0) {
            x = newX;
            y = newY;
        }

        return String.format(""(%d,%d)"", x, y);
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String move(String moveCommandString);
}
",2550,94,29.951219512195124,106,0.0,0.06382978723404255,0.031914893617021274,0.010638297872340425,0.4787234042553192,0.0,0.1276595744680851,0.0,False,True,False,False,False,False,2,0.02127659574468085,0.05319148936170213,0.06382978723404255,0.010638297872340425,0.5,0.3723404255319149,0.02127659574468085,4.333333333333333,12,0.0,0
17,bing,plain,balanced,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Walkable {
    private int[][] walls = {{0, 0, 12, 0}, {0, 0, 0, 8}, {12, 0, 12, 8}, {0, 8, 12, 8}, {3, 0, 3, 3}, {4, 3, 7, 3}, {7, 0, 7, 2}, {1, 4, 8, 4}};
    private int[] robotPosition = {3, 0};
    private int[] roomSize = {12, 8};

    public Exercise0() {
    }

    public String walkTo(String walkCommandString) {
        String[] walkCommand = walkCommandString.substring(1, walkCommandString.length() - 1).split("","");
        String direction = walkCommand[0];
        int steps = Integer.parseInt(walkCommand[1]);

        int[] newPosition = new int[]{robotPosition[0], robotPosition[1]};
        switch (direction) {
            case ""no"":
                newPosition[1] += steps;
                break;
            case ""ea"":
                newPosition[0] += steps;
                break;
            case ""so"":
                newPosition[1] -= steps;
                break;
            case ""we"":
                newPosition[0] -= steps;
                break;
            default:
                throw new IllegalArgumentException(""Invalid direction: "" + direction);
        }

        if (newPosition[0] < 0) {
            newPosition[0] = 0;
        } else if (newPosition[0] >= roomSize[0]) {
            newPosition[0] = roomSize[0] - 1;
        }

        if (newPosition[1] < 0) {
            newPosition[1] = 0;
        } else if (newPosition[1] >= roomSize[1]) {
            newPosition[1] = roomSize[1] - 1;
        }

        for (int[] wall : walls) {
            if ((wall[0] == robotPosition[0] && wall[2] == robotPosition[0]) || (wall[2] == robotPosition[0] && wall[4] == robotPosition[1])) {
                if ((wall[1] <= robotPosition[1] && robotPosition[1] <= wall[3]) || (wall[3] <= robotPosition[1] && robotPosition[1] <= wall[5])) {
                    if ((wall[1] <= newPosition[1] && newPosition[1] <= wall[3]) || (wall[3] <= newPosition[1] && newPosition[1] <= wall[5])) {
                        if ((wall [2]== wall [4]) && (robotPosition [0]!= wall [2])) {
                            continue;
                        }
                        if ((wall [3]== wall [5]) && (robotPosition [1]!= wall [3])) {
                            continue;
                        }
                        return ""("" + robotPosition [0]+"",""+robotPosition [1]+"")"";
                    }
                }
            }
        }

        robotPosition = newPosition;

        return ""("" + robotPosition [0]+"",""+robotPosition [1]+"")"";
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);
}
",2676,72,42.68852459016394,147,0.0,0.125,0.013888888888888888,0.013888888888888888,1.5138888888888888,0.013888888888888888,0.1527777777777778,0.0,False,False,False,False,False,False,2,0.027777777777777776,0.041666666666666664,0.05555555555555555,0.013888888888888888,0.9027777777777778,0.05555555555555555,0.0,8.25,13,0.0,0
17,gpt3.5,styled,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements GoAble{
    private int robotX = 11;
    private int robotY = 7;
    private int gridWidth = 12;
    private int gridHeight = 8;
    private int[][] obstacles = {{6,2,6,5},{5,5,6,5},{5,5,5,6},{5,6,12,6}};

    public String goTo(String goCommandString) {
        String[] goCommand = goCommandString.replaceAll(""\\[|\\]"", """").split("","");
        String direction = goCommand[0];
        int steps = Integer.parseInt(goCommand[1]);
        int newX = robotX;
        int newY = robotY;

        if (direction.equals(""no"")) {
            newY += steps;
        } else if (direction.equals(""ea"")) {
            newX += steps;
        } else if (direction.equals(""so"")) {
            newY -= steps;
        } else if (direction.equals(""we"")) {
            newX -= steps;
        }

        for (int[] obstacle : obstacles) {
            int x1 = obstacle[0];
            int y1 = obstacle[1];
            int x2 = obstacle[2];
            int y2 = obstacle[3];
            if ((newX >= x1 && newX <= x2 && newY == robotY) ||
                    (newY >= y1 && newY <= y2 && newX == robotX)) {
                newX = Math.min(Math.max(newX, 0), gridWidth);
                newY = Math.min(Math.max(newY, 0), gridHeight);
                break;
            }
        }

        robotX = newX;
        robotY = newY;
        return ""("" + robotX + "","" + robotY + "")"";
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String goTo(String goCommandString);
}
",1558,50,35.06976744186046,82,0.0,0.1,0.02,0.0,0.84,0.0,0.14,0.0,False,False,False,False,False,False,2,0.04,0.1,0.18,0.02,0.82,0.22,0.0,5.571428571428571,10,0.0,0
17,gpt4,plain,,"package thkoeln.st.st2praktikum.exercise;

import java.awt.Point;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Exercise0 implements Walkable {

    private int width = 12;
    private int height = 9;
    private Point machinePosition;
    private List<Point[]> walls;

    public Exercise0() {
        machinePosition = new Point(0, 2);
        walls = new ArrayList<>(Arrays.asList(
                new Point[]{new Point(3, 0), new Point(3, 3)},
                new Point[]{new Point(5, 0), new Point(5, 4)},
                new Point[]{new Point(4, 5), new Point(7, 5)},
                new Point[]{new Point(7, 5), new Point(7, 9)}));
    }

    @Override
    public String walk(String walkCommandString) {
        String[] commandParts = walkCommandString.substring(1, walkCommandString.length() - 1).split("","");
        String direction = commandParts[0];
        int steps = Integer.parseInt(commandParts[1]);

        switch (direction) {
            case ""no"":
                for (int i = 0; i < steps; i++) {
                    if (isValidMove(machinePosition.x, machinePosition.y + 1)) {
                        machinePosition.y++;
                    } else {
                        break;
                    }
                }
                break;
            case ""ea"":
                for (int i = 0; i < steps; i++) {
                    if (isValidMove(machinePosition.x + 1, machinePosition.y)) {
                        machinePosition.x++;
                    } else {
                        break;
                    }
                }
                break;
            case ""so"":
                for (int i = 0; i < steps; i++) {
                    if (isValidMove(machinePosition.x, machinePosition.y - 1)) {
                        machinePosition.y--;
                    } else {
                        break;
                    }
                }
                break;
            case ""we"":
                for (int i = 0; i < steps; i++) {
                    if (isValidMove(machinePosition.x - 1, machinePosition.y)) {
                        machinePosition.x--;
                    } else {
                        break;
                    }
                }
                break;
            default:
                throw new IllegalArgumentException(""Invalid walkCommandString format"");
        }

        return String.format(""(%d,%d)"", machinePosition.x, machinePosition.y);
    }

    private boolean isValidMove(int newX, int newY) {
        if (newX < 0 || newX >= width || newY < 0 || newY >= height) {
            return false;
        }

        for (Point[] wall : walls) {
            if (isCollidingWithWall(newX, newY, wall)) {
                return false;
            }
        }

        return true;
    }

    private boolean isCollidingWithWall(int newX, int newY, Point[] wall) {
        if (wall[0].x == wall[1].x) {
            if (newY >= Math.min(wall[0].y, wall[1].y) && newY < Math.max(wall[0].y, wall[1].y)) {
                if (newX == wall[0].x - 1 && machinePosition.x == newX || newX == wall[0].x && machinePosition.x == newX - 1) {
                    return true;
                }
            }
        } else if (wall[0].y == wall[1].y) {
            if (newX >= Math.min(wall[0].x, wall[1].x) && newX < Math.max(wall[0].x, wall[1].x)) {
                if (newY == wall[0].y - 1 && machinePosition.y == newY || newY == wall[0].y && machinePosition.y == newY - 1) {
                    return true;
                }
            }
        }
        return false;
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",3724,110,37.25773195876289,127,0.0,0.10909090909090909,0.06363636363636363,0.00909090909090909,0.5363636363636364,0.00909090909090909,0.11818181818181818,0.0,False,True,False,True,False,False,2,0.03636363636363636,0.03636363636363636,0.02727272727272727,0.00909090909090909,0.8090909090909091,0.13636363636363635,0.03636363636363636,5.538461538461538,15,0.0,0
18,bing,plain,creative,"package thkoeln.st.st2praktikum.exercise;

// A class that represents a tidy-up robot that can walk in a room with walls
public class Exercise0 implements Walkable {

    // Constants for directions
    private static final String NORTH = ""no"";
    private static final String EAST = ""ea"";
    private static final String SOUTH = ""so"";
    private static final String WEST = ""we"";

    // Constants for room size and walls
    private static final int ROOM_WIDTH = 12;
    private static final int ROOM_HEIGHT = 8;
    private static final boolean[][] WALLS = new boolean[ROOM_WIDTH + 1][ROOM_HEIGHT + 1]; // a 2D array that stores whether there is a wall on each grid line

    static {
        // Initialize the walls according to the personal map
        for (int x = 3; x <= 7; x++) {
            WALLS[x][3] = true; // wall between (3,0)-(3,3) and (4,3)-(7,3)
        }
        for (int y = 0; y <= 4; y++) {
            WALLS[3][y] = true; // wall between (3,0)-(3,3)
            WALLS[7][y] = true; // wall between (7,0)-(7,2)
        }
        for (int x = 1; x <= 8; x++) {
            WALLS[x][4] = true; // wall between (1,4)-(8,4)
        }
    }

    // Instance variables for robot position
    private int x; // the x-coordinate of the robot
    private int y; // the y-coordinate of the robot

    // Constructor that sets the initial position of the robot according to the personal map
    public Exercise0() {
        this.x = 3;
        this.y = 0;
    }

    // A method that moves the robot according to a walk command string and returns its coordinate
    public String walkTo(String walkCommandString) {
        // Parse the walk command string into direction and steps
        String direction = walkCommandString.substring(1, 3); // extract the direction part
        int steps = Integer.parseInt(walkCommandString.substring(4, walkCommandString.length() - 1)); // extract and convert the steps part

        // Move the robot according to the direction and steps, stopping at walls or boundaries
        switch (direction) {
            case NORTH:
                while (steps > 0 && y < ROOM_HEIGHT - 1 && !WALLS[x][y + 1]) { // while there are steps left and no wall or boundary above
                    y++; // move one cell up
                    steps--; // decrease one step
                }
                break;
            case EAST:
                while (steps > 0 && x < ROOM_WIDTH - 1 && !WALLS[x + 1][y]) { // while there are steps left and no wall or boundary to the right
                    x++; // move one cell right
                    steps--; // decrease one step
                }
                break;
            case SOUTH:
                while (steps > 0 && y > 0 && !WALLS[x][y - 1]) { // while there are steps left and no wall or boundary below
                    y--; // move one cell down
                    steps--; // decrease one step
                }
                break;
            case WEST:
                while (steps > 0 && x > 0 && !WALLS[x][y]) { // while there are steps left and no wall or boundary to the left
                    x--; // move one cell left
                    steps--; // decrease one step
                }
                break;
            default:
                throw new IllegalArgumentException(""Invalid direction: "" + direction); // throw an exception if the direction is not valid
        }

        // Return the coordinate of the robot after walking as a string
        return ""("" + x + "","" + y + "")"";
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);
}
",3641,85,47.413333333333334,158,0.3764705882352941,0.011764705882352941,0.07058823529411765,0.011764705882352941,0.6705882352941176,0.011764705882352941,0.11764705882352941,0.0,True,False,False,False,False,False,2,0.023529411764705882,0.10588235294117647,0.023529411764705882,0.011764705882352941,0.611764705882353,0.047058823529411764,0.0,6.0,11,40.9375,91
18,gpt3.5,styled,,"package thkoeln.st.st2praktikum.exercise;
public class Exercise0 implements GoAble {
    public String goTo(String goCommandString) {
        String direction = goCommandString.substring(1,3);
        int steps = Integer.parseInt(goCommandString.substring(4, goCommandString.length() - 1));
        int x = 11, y = 7;
        int maxX = 12, maxY = 8;
        int[][] obstacles = {{6,2,6,5},{5,5,6,5},{5,5,5,6},{5,6,12,6}};
        for (int i = 0; i < steps; i++) {
            switch(direction) {
                case ""no"":
                    y++;
                    break;
                case ""ea"":
                    x++;
                    break;
                case ""so"":
                    y--;
                    break;
                case ""we"":
                    x--;
                    break;
            }
            if (x < 0 || x >= maxX || y < 0 || y >= maxY) {
                switch(direction) {
                    case ""no"":
                        y--;
                        break;
                    case ""ea"":
                        x--;
                        break;
                    case ""so"":
                        y++;
                        break;
                    case ""we"":
                        x++;
                        break;
                }
                break;
            }
            for (int j = 0; j < obstacles.length; j++) {
                int x1 = obstacles[j][0];
                int y1 = obstacles[j][1];
                int x2 = obstacles[j][2];
                int y2 = obstacles[j][3];
                if (x == x1 && y >= y1 && y <= y2) {
                    y = y2 + 1;
                    break;
                } else if (x == x2 && y >= y1 && y <= y2) {
                    y = y1 - 1;
                    break;
                } else if (y == y1 && x >= x1 && x <= x2) {
                    x = x2 + 1;
                    break;
                } else if (y == y2 && x >= x1 && x <= x2) {
                    x = x1 - 1;
                    break;
                }
            }
        }
        return ""("" + x + "","" + y + "")"";
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String goTo(String goCommandString);
}
",2239,69,32.38805970149254,97,0.0,0.07246376811594203,0.028985507246376812,0.028985507246376812,0.8985507246376812,0.0,0.028985507246376812,0.0,False,False,False,False,False,False,2,0.028985507246376812,0.0,0.15942028985507245,0.014492753623188406,0.927536231884058,0.057971014492753624,0.0,3.5,9,0.0,0
18,gpt4,styled,,"package thkoeln.st.st2praktikum.exercise;

import java.awt.Point;

public class Exercise0 implements Walkable {
    // Define the field's size
    private final int FIELD_WIDTH = 12;
    private final int FIELD_HEIGHT = 9;
    // Define the starting position of the mining machine
    private Point miningMachineLocation;

    // Constructor
    public Exercise0() {
        // Initialize mining machine's location
        miningMachineLocation = new Point(0, 2);
    }

    // Implement the walk method as required by the Walkable interface
    @Override
    public String walk(String walkCommandString) {
        // Remove brackets from the command and split it into direction and steps
        String[] parts = walkCommandString.substring(1, walkCommandString.length() - 1).split("","");
        String direction = parts[0].trim(); // Get direction
        int steps = Integer.parseInt(parts[1].trim()); // Get steps

        // Loop for the number of steps
        for (int i = 0; i < steps; i++) {
            // Make a copy of the current location
            Point newLocation = new Point(miningMachineLocation);

            // Move the machine based on the direction
            switch (direction) {
                case ""no"": // Move north
                    newLocation.y += 1;
                    break;
                case ""ea"": // Move east
                    newLocation.x += 1;
                    break;
                case ""so"": // Move south
                    newLocation.y -= 1;
                    break;
                case ""we"": // Move west
                    newLocation.x -= 1;
                    break;
            }

            // Check if the move is valid
            if (isValidMove(newLocation)) {
                // If it is, update the machine's location
                miningMachineLocation = newLocation;
            } else {
                // If it's not, stop moving
                break;
            }
        }

        // Return the machine's location in the required format
        return String.format(""(%d,%d)"", miningMachineLocation.x, miningMachineLocation.y);
    }

    // Helper method to check if a move is valid
    private boolean isValidMove(Point newLocation) {
        // Check if the move is within the field's boundaries
        if (newLocation.x < 0 || newLocation.x >= FIELD_WIDTH
                || newLocation.y < 0 || newLocation.y >= FIELD_HEIGHT) {
            return false;
        }

        // Check for collisions with walls
        if ((newLocation.x == 3 && newLocation.y < 3)
                || (newLocation.x == 5 && newLocation.y < 4)
                || (newLocation.y == 5 && newLocation.x >= 4 && newLocation.x < 7)
                || (newLocation.x == 7 && newLocation.y >= 5)) {
            return false;
        }

        // If no collisions or boundary violations, the move is valid
        return true;
    }
}



package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",3022,88,40.19178082191781,99,0.26136363636363635,0.06818181818181818,0.056818181818181816,0.011363636363636364,0.32954545454545453,0.0,0.1590909090909091,0.0,False,False,False,True,False,False,2,0.03409090909090909,0.03409090909090909,0.045454545454545456,0.011363636363636364,0.36363636363636365,0.09090909090909091,0.011363636363636364,7.7,21,32.0,70
19,bing,plain,creative,"package thkoeln.st.st2praktikum.exercise;

// Define the class that implements the Walkable interface
public class Exercise0 implements Walkable {

    // Define the constants for the room size and the directions
    private static final int ROOM_WIDTH = 12;
    private static final int ROOM_HEIGHT = 8;
    private static final String NORTH = ""no"";
    private static final String EAST = ""ea"";
    private static final String SOUTH = ""so"";
    private static final String WEST = ""we"";

    // Define the arrays that represent the left and bottom walls in the room
    // A cell is true if it has a wall on its left or bottom side
    private static final boolean[][] LEFT_WALLS = new boolean[ROOM_WIDTH][ROOM_HEIGHT];
    private static final boolean[][] BOTTOM_WALLS = new boolean[ROOM_WIDTH][ROOM_HEIGHT];

    static {
        // Mark the cells that have a wall on their left side
        for (int y = 0; y <= 3; y++) {
            LEFT_WALLS[3][y] = true;
        }
        for (int y = 0; y <= 2; y++) {
            LEFT_WALLS[7][y] = true;
        }
        // Mark the cells that have a wall on their bottom side
        for (int x = 4; x <= 7; x++) {
            BOTTOM_WALLS[x][3] = true;
        }
        for (int x = 1; x <= 8; x++) {
            BOTTOM_WALLS[x][4] = true;
        }
    }


    // Define the fields for the robot's position
    private int robotX;
    private int robotY;

    // Define the constructor that sets the robot's initial position
    public Exercise0() {
        robotX = 3;
        robotY = 0;
    }

    // Implement the walkTo method that moves the robot according to the command
    @Override
    public String walkTo(String walkCommandString) {
        // Parse the command string and extract the direction and the steps
        String direction = parseDirection(walkCommandString);
        int steps = parseSteps(walkCommandString);

        // Move the robot according to the direction and the steps, stopping at walls or boundaries
        switch (direction) {
            case NORTH: // Move north
                moveNorth(steps);
                break;
            case EAST: // Move east
                moveEast(steps);
                break;
            case SOUTH: // Move south
                moveSouth(steps);
                break;
            case WEST: // Move west
                moveWest(steps);
                break;
            default: // Invalid direction
                throw new IllegalArgumentException(""Invalid direction: "" + direction);
        }

        // Return the robot's position as a string in the format ""(x,y)""
        return ""("" + robotX + "","" + robotY + "")"";
    }

    // Parse the command string and extract the direction part
    private String parseDirection(String walkCommandString) {
        walkCommandString = walkCommandString.trim();
        if (!walkCommandString.startsWith(""["") || !walkCommandString.endsWith(""]"")) {
            throw new IllegalArgumentException(""Invalid command format"");
        }
        walkCommandString = walkCommandString.substring(1, walkCommandString.length() - 1);
        String[] parts = walkCommandString.split("","");
        if (parts.length != 2) {
            throw new IllegalArgumentException(""Invalid command format"");
        }
        return parts[0].trim().toLowerCase();
    }

    // Parse the command string and extract the steps part
    private int parseSteps(String walkCommandString) {
        walkCommandString = walkCommandString.trim();
        if (!walkCommandString.startsWith(""["") || !walkCommandString.endsWith(""]"")) {
            throw new IllegalArgumentException(""Invalid command format"");
        }
        walkCommandString = walkCommandString.substring(1, walkCommandString.length() - 1);
        String[] parts = walkCommandString.split("","");
        if (parts.length != 2) {
            throw new IllegalArgumentException(""Invalid command format"");
        }
        return Integer.parseInt(parts[1].trim());
    }

    // Move the robot north by a given number of steps
    private void moveNorth(int steps) {
        for (int i = 0; i < steps; i++) {
            // Check if there is a wall or a boundary above the robot
            if (robotY == ROOM_HEIGHT - 1 || BOTTOM_WALLS[robotX][robotY + 1]) {
                break; // Stop moving
            }
            robotY++; // Move one cell up
        }
    }

    // Move the robot east by a given number of steps
    private void moveEast(int steps) {
        for (int i = 0; i < steps; i++) {
            // Check if there is a wall or a boundary on the right of the robot
            if (robotX == ROOM_WIDTH - 1 || LEFT_WALLS[robotX + 1][robotY]) {
                break; // Stop moving
            }
            robotX++; // Move one cell right
        }
    }

    // Move the robot south by a given number of steps
    private void moveSouth(int steps) {
        for (int i = 0; i < steps; i++) {
            // Check if there is a wall or a boundary below the robot
            if (robotY == 0 || BOTTOM_WALLS[robotX][robotY]) {
                break; // Stop moving
            }
            robotY--; // Move one cell down
        }
    }

    // Move the robot west by a given number of steps
    private void moveWest(int steps) {
        for (int i = 0; i < steps; i++) {
            // Check if there is a wall or a boundary on the left of the robot
            if (robotX == 0 || LEFT_WALLS[robotX][robotY]) {
                break; // Stop moving
            }
            robotX--; // Move one cell left
        }
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);
}
",5678,152,40.93333333333333,99,0.23026315789473684,0.08552631578947369,0.09868421052631579,0.006578947368421052,0.2565789473684211,0.03289473684210526,0.10526315789473684,0.0,True,False,False,False,False,False,2,0.05263157894736842,0.06578947368421052,0.02631578947368421,0.006578947368421052,0.4868421052631579,0.14473684210526316,0.0,7.142857142857143,17,40.8,88
19,gpt3.5,styled,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements GoAble{
    private int droidX;
    private int droidY;
    private int gridWidth = 12;
    private int gridHeight = 8;
    private boolean[][] obstacles;

    public Exercise0() {
        droidX = 11;
        droidY = 7;
        obstacles = new boolean[gridWidth][gridHeight];
        // Set up the obstacles
        for (int x = 0; x < gridWidth; x++) {
            for (int y = 0; y < gridHeight; y++) {
                obstacles[x][y] = false;
            }
        }
        obstacles[6][2] = true;
        obstacles[6][3] = true;
        obstacles[6][4] = true;
        obstacles[6][5] = true;
        obstacles[5][5] = true;
        obstacles[5][6] = true;
        obstacles[7][6] = true;
        obstacles[8][6] = true;
        obstacles[9][6] = true;
        obstacles[10][6] = true;
        obstacles[11][6] = true;
    }

    public String goTo(String goCommandString) {
        String[] parts = goCommandString.split("","");
        String direction = parts[0].substring(1);
        int steps = Integer.parseInt(parts[1].substring(0, parts[1].length() - 1));
        int newX = droidX;
        int newY = droidY;
        switch (direction) {
            case ""no"":
                newY += steps;
                break;
            case ""ea"":
                newX += steps;
                break;
            case ""so"":
                newY -= steps;
                break;
            case ""we"":
                newX -= steps;
                break;
            default:
                break;
        }
        // Check for obstacles and spaceship deck boundary
        if (newX < 0) {
            newX = 0;
        }
        if (newX >= gridWidth) {
            newX = gridWidth - 1;
        }
        if (newY < 0) {
            newY = 0;
        }
        if (newY >= gridHeight) {
            newY = gridHeight - 1;
        }
        if (obstacles[newX][newY]) {
            // Check for obstacle in the way
            if (direction.equals(""no"") || direction.equals(""so"")) {
                // Check if obstacle is above or below the droid
                int maxSteps = Math.abs(newY - droidY);
                if (newY > droidY) {
                    newY = droidY + maxSteps;
                } else {
                    newY = droidY - maxSteps;
                }
            } else {
                // Obstacle is to the east or west of the droid
                int maxSteps = Math.abs(newX - droidX);
                if (newX > droidX) {
                    newX = droidX + maxSteps;
                } else {
                    newX = droidX - maxSteps;
                }
            }
        }
        // Update the droid's position
        droidX = newX;
        droidY = newY;
        return ""("" + (droidX+1) + "","" + (droidY+1) + "")"";
    }
}


package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String goTo(String goCommandString);
}
",2963,100,30.45744680851064,83,0.06,0.09,0.04,0.01,0.5,0.0,0.05,0.0,True,False,False,False,False,False,2,0.02,0.05,0.07,0.01,0.8,0.09,0.0,5.923076923076923,10,35.333333333333336,47
19,gpt4,styled,,"package thkoeln.st.st2praktikum.exercise;

import java.util.ArrayList;
import java.util.List;

public class Exercise0 implements Walkable {

    // Declare the variables for the current position of the mining machine
    private int currentX;
    private int currentY;

    // Define the size of the field
    private int fieldSizeX = 12;
    private int fieldSizeY = 9;

    // Create a list to store the wall coordinates
    private List<int[]> walls = new ArrayList<>();

    // Constructor
    public Exercise0() {
        // Set the initial position of the mining machine
        currentX = 0;
        currentY = 2;

        // Add the walls to the list
        walls.add(new int[]{3, 0, 3, 3});
        walls.add(new int[]{5, 0, 5, 4});
        walls.add(new int[]{4, 5, 7, 5});
        walls.add(new int[]{7, 5, 7, 9});
    }

    // Method to move the mining machine
    @Override
    public String walk(String walkCommandString) {
        // Remove the brackets and split the command into direction and steps
        String[] commands = walkCommandString.substring(1, walkCommandString.length()-1).split("","");
        String direction = commands[0];
        int steps = Integer.parseInt(commands[1]);

        // Loop for the number of steps
        for (int i = 0; i < steps; i++) {
            // Check the direction and move the mining machine
            if (direction.equals(""no"")) {
                if (!isWall(currentX, currentY+1)) {
                    currentY = currentY + 1;
                    if (currentY > fieldSizeY - 1) {
                        currentY = fieldSizeY - 1;
                    }
                }
            } else if (direction.equals(""ea"")) {
                if (!isWall(currentX+1, currentY)) {
                    currentX = currentX + 1;
                    if (currentX > fieldSizeX - 1) {
                        currentX = fieldSizeX - 1;
                    }
                }
            } else if (direction.equals(""so"")) {
                if (!isWall(currentX, currentY-1)) {
                    currentY = currentY - 1;
                    if (currentY < 0) {
                        currentY = 0;
                    }
                }
            } else if (direction.equals(""we"")) {
                if (!isWall(currentX-1, currentY)) {
                    currentX = currentX - 1;
                    if (currentX < 0) {
                        currentX = 0;
                    }
                }
            }
        }
        // Return the final position of the mining machine
        return ""("" + currentX + "","" + currentY + "")"";
    }

    // Method to check if there is a wall at the given position
    private boolean isWall(int x, int y) {
        // Loop over all the walls
        for (int[] wall : walls) {
            // Check if the given position is inside the wall
            if (x == wall[0] || x == wall[2]) {
                if (y >= Math.min(wall[1], wall[3]) && y <= Math.max(wall[1], wall[3])) {
                    return true;
                }
            } else if (y == wall[1] || y == wall[3]) {
                if (x >= Math.min(wall[0], wall[2]) && x <= Math.max(wall[0], wall[2])) {
                    return true;
                }
            }
        }
        // If no wall is found, return false
        return false;
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",3445,101,37.57303370786517,100,0.1485148514851485,0.1782178217821782,0.039603960396039604,0.0,0.5742574257425742,0.0,0.1188118811881188,0.0,False,True,False,False,False,False,2,0.0297029702970297,0.04950495049504951,0.0297029702970297,0.009900990099009901,0.5742574257425742,0.19801980198019803,0.019801980198019802,5.545454545454546,10,40.0,68
2,bard,plain,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Moveable {

    private int x = 7;
    private int y = 7;
    private int width = 11;
    private int height = 8;
    private int[][] barriers = {{2, 1, 10, 1}, {2, 1, 2, 6}, {2, 6, 7, 6}, {10, 1, 10, 8}};

    @Override
    public String move(String moveCommandString) {
        String[] parts = moveCommandString.substring(1, moveCommandString.length() - 1).split("","");
        String direction = parts[0];
        int steps = Integer.parseInt(parts[1]);

        if (direction.equals(""no"")) {
            for (int i = 0; i < steps; i++) {
                if (y - 1 < 0 || isBarrier(x, y - 1)) {
                    break;
                }
                y--;
            }
        } else if (direction.equals(""ea"")) {
            for (int i = 0; i < steps; i++) {
                if (x + 1 >= width || isBarrier(x + 1, y)) {
                    break;
                }
                x++;
            }
        } else if (direction.equals(""so"")) {
            for (int i = 0; i < steps; i++) {
                if (y + 1 >= height || isBarrier(x, y + 1)) {
                    break;
                }
                y++;
            }
        } else if (direction.equals(""we"")) {
            for (int i = 0; i < steps; i++) {
                if (x - 1 < 0 || isBarrier(x - 1, y)) {
                    break;
                }
                x--;
            }
        }

        return ""("" + x + "","" + y + "")"";
    }

    private boolean isBarrier(int x, int y) {
        for (int[] barrier : barriers) {
            if (x >= barrier[0] && x <= barrier[2] && y >= barrier[1] && y <= barrier[3]) {
                return true;
            }
        }

        // Check if the next position would be inside a barrier.
        int nextX = x + (direction.equals(""ea"") ? 1 : (direction.equals(""we"") ? -1 : 0));
        int nextY = y + (direction.equals(""no"") ? -1 : (direction.equals(""so"") ? 1 : 0));
        if (nextX >= 0 && nextX < width && nextY >= 0 && nextY < height) {
            for (int[] barrier : barriers) {
                if (nextX >= barrier[0] && nextX <= barrier[2] && nextY >= barrier[1] && nextY <= barrier[3]) {
                    return true;
                }
            }
        }

        return false;
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String move(String moveCommandString);
}
",2437,75,35.78787878787879,111,0.013333333333333334,0.16,0.08,0.0,0.8133333333333334,0.0,0.12,0.0,False,False,False,False,False,False,2,0.04,0.06666666666666667,0.06666666666666667,0.013333333333333334,0.8,0.21333333333333335,0.0,4.454545454545454,8,53.0,53
2,bing,plain,balanced,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Walkable {
    private int x = 3;
    private int y = 0;
    private int[][] walls = {{3, 0}, {3, 1}, {3, 2}, {3, 3}, {4, 3}, {5, 3}, {6, 3}, {7, 3}, {7, 2}, {7, 1}, {7, 0}, {1, 4}, {2, 4}, {3, 4}, {4, 4}, {5, 4}, {6, 4}, {7, 4}};
    private int width = 12;
    private int height = 8;

    @Override
    public String walkTo(String walkCommandString) {
        String[] walkCommand = walkCommandString.substring(1, walkCommandString.length() - 1).split("","");
        String direction = walkCommand[0];
        int steps = Integer.parseInt(walkCommand[1]);

        switch (direction) {
            case ""no"":
                for (int i = y + steps; i <= height; i++) {
                    if (isWall(x, y + steps - i)) {
                        y += i - y - steps;
                        break;
                    } else if (i == height) {
                        y += steps;
                    }
                }
                break;
            case ""ea"":
                for (int i = x + steps; i <= width; i++) {
                    if (isWall(x + steps - i, y)) {
                        x += i - x - steps;
                        break;
                    } else if (i == width) {
                        x += steps;
                    }
                }
                break;
            case ""so"":
                for (int i = y - steps; i >= 0; i--) {
                    if (isWall(x, y - steps + i)) {
                        y -= y - steps + i;
                        break;
                    } else if (i == 0) {
                        y -= steps;
                    }
                }
                break;
            case ""we"":
                for (int i = x - steps; i >= 0; i--) {
                    if (isWall(x - steps + i, y)) {
                        x -= x - steps + i;
                        break;
                    } else if (i == 0) {
                        x -= steps;
                    }
                }
                break;
            default:
                throw new IllegalArgumentException(""Invalid direction"");
        }

        return ""("" + x + "","" + y + "")"";
    }

    private boolean isWall(int x, int y) {
        for (int[] wall : walls) {
            if (wall[0] == x && wall[1] == y) {
                return true;
            }
        }

        return false;
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);
}
",2543,78,34.71830985915493,173,0.0,0.11538461538461539,0.0641025641025641,0.01282051282051282,0.6923076923076923,0.01282051282051282,0.08974358974358974,0.0,False,False,False,False,False,False,2,0.038461538461538464,0.0641025641025641,0.038461538461538464,0.01282051282051282,0.9487179487179487,0.10256410256410256,0.0,4.8,11,0.0,0
2,gpt3.5,plain,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements GoAble {

    private int x; // current x-coordinate
    private int y; // current y-coordinate

    public Exercise0() {
        // Initialize the starting position of the maintenance droid
        x = 11;
        y = 7;
    }

    @Override
    public String goTo(String goCommandString) {
        String[] command = goCommandString.replace(""["", """").replace(""]"", """").split("","");
        String direction = command[0];
        int steps = Integer.parseInt(command[1]);

        // Update the coordinates based on the direction and number of steps
        for (int i = 0; i < steps; i++) {
            switch (direction) {
                case ""no"": // north
                    if (y == 5 && x >= 5 && x <= 6) {
                        y = 4;
                        break;
                    } else if (y > 0) {
                        y--;
                    }
                    break;
                case ""ea"": // east
                    if (x == 5 && y >= 5 && y <= 6) {
                        x = 6;
                        break;
                    } else if (x < 11) {
                        x++;
                    }
                    break;
                case ""so"": // south
                    if (y == 0 && x >= 5 && x <= 6) {
                        y = 1;
                        break;
                    } else if (y < 7) {
                        y++;
                    }
                    break;
                case ""we"": // west
                    if (x == 6 && y >= 1 && y <= 5) {
                        x = 5;
                        break;
                    } else if (x > 0) {
                        x--;
                    }
                    break;
            }
        }

        return ""("" + x + "","" + y + "")"";
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String goTo(String goCommandString);
}
",1964,65,32.741379310344826,88,0.12307692307692308,0.12307692307692308,0.015384615384615385,0.015384615384615385,0.47692307692307695,0.0,0.1076923076923077,0.0,False,False,False,False,False,False,2,0.03076923076923077,0.03076923076923077,0.046153846153846156,0.015384615384615385,0.5230769230769231,0.06153846153846154,0.0,4.0,9,22.5,65
2,gpt4,plain,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Walkable {
    private int x, y;
    private final int fieldWidth = 12;
    private final int fieldHeight = 9;

    public Exercise0() {
        x = 0;
        y = 2;
    }

    @Override
    public String walk(String walkCommandString) {
        String[] parts = walkCommandString.substring(1, walkCommandString.length() - 1).split("","");

        String direction = parts[0];
        int steps = Integer.parseInt(parts[1]);
        int newX = x;
        int newY = y;

        switch (direction) {
            case ""no"":
                newY += steps;
                if (newY >= fieldHeight) {
                    newY = fieldHeight - 1;
                }
                if (newX >= 4 && newX <= 7 && newY > 5) {
                    newY = 5;
                }
                break;
            case ""ea"":
                newX += steps;
                if (newX >= fieldWidth) {
                    newX = fieldWidth - 1;
                }
                if (newY >= 0 && newY <= 3 && newX > 3) {
                    newX = 3;
                }
                if (newY >= 0 && newY <= 4 && newX > 5) {
                    newX = 5;
                }
                break;
            case ""so"":
                newY -= steps;
                if (newY < 0) {
                    newY = 0;
                }
                if (newX >= 4 && newX <= 7 && newY < 5 && newY >= 0) {
                    newY = 5;
                }
                break;
            case ""we"":
                newX -= steps;
                if (newX < 0) {
                    newX = 0;
                }
                if (newY >= 0 && newY <= 3 && newX < 3) {
                    newX = 3;
                }
                if (newY >= 0 && newY <= 4 && newX < 5) {
                    newX = 5;
                }
                break;
            default:
                throw new IllegalArgumentException(""Invalid direction: "" + direction);
        }

        x = newX;
        y = newY;
        return ""("" + x + "","" + y + "")"";
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",2221,79,30.169014084507044,99,0.0,0.12658227848101267,0.0,0.012658227848101266,0.5569620253164557,0.012658227848101266,0.10126582278481013,0.0,False,False,False,False,False,False,2,0.02531645569620253,0.05063291139240506,0.06329113924050633,0.012658227848101266,0.7468354430379747,0.05063291139240506,0.0,5.555555555555555,11,0.0,0
20,bing,plain,precise,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Walkable {
    private int x = 3;
    private int y = 0;
    private int width = 12;
    private int height = 8;
    private boolean[][] walls = new boolean[width][height];

    public Exercise0() {
        // Initialize walls
        for (int i = 0; i <= 3; i++) {
            walls[3][i] = true;
        }
        for (int i = 4; i <= 7; i++) {
            walls[i][3] = true;
        }
        for (int i = 0; i <= 2; i++) {
            walls[7][i] = true;
        }
        for (int i = 1; i <= 8; i++) {
            walls[i][4] = true;
        }
    }

    public String walkTo(String walkCommandString) {
        String[] parts = walkCommandString.split("","");
        String direction = parts[0].substring(1);
        int steps = Integer.parseInt(parts[1].substring(0, parts[1].length() - 1));

        switch (direction) {
            case ""no"":
                for (int i = 0; i < steps; i++) {
                    if (y + 1 >= height || walls[x][y + 1]) break;
                    y++;
                }
                break;
            case ""ea"":
                for (int i = 0; i < steps; i++) {
                    if (x + 1 >= width || walls[x + 1][y]) break;
                    x++;
                }
                break;
            case ""so"":
                for (int i = 0; i < steps; i++) {
                    if (y - 1 < 0 || walls[x][y - 1]) break;
                    y--;
                }
                break;
            case ""we"":
                for (int i = 0; i < steps; i++) {
                    if (x - 1 < 0 || walls[x - 1][y]) break;
                    x--;
                }
                break;
        }

        return ""("" + x + "","" + y + "")"";
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);
}
",1895,65,31.016949152542374,83,0.015384615384615385,0.06153846153846154,0.12307692307692308,0.015384615384615385,0.6307692307692307,0.0,0.09230769230769231,0.0,True,False,False,False,False,False,2,0.03076923076923077,0.07692307692307693,0.046153846153846156,0.015384615384615385,0.8923076923076924,0.07692307692307693,0.0,4.222222222222222,9,16.0,16
20,gpt4,styled,,"package thkoeln.st.st2praktikum.exercise;

import java.awt.Point;

public class Exercise0 implements Walkable {
    private Point machineLocation;
    private int fieldWidth = 12;
    private int fieldHeight = 9;
    private boolean[][] walls;

    public Exercise0() { machineLocation = new Point(0, 2);
        walls = new boolean[fieldHeight + 1][fieldWidth + 1];
        setWall(3, 0, 3, 3);
        setWall(5, 0, 5, 4);
        setWall(4, 5, 7, 5);setWall(7, 5, 7, 9);}

    private void setWall(int x1, int y1, int x2, int y2) {
        if (x1 == x2) {for (int i = y1; i <= y2; i++) {walls[i][x1] = true;}} else {for (int i = x1; i <= x2; i++) {walls[y1][i] = true;}}}

    @Override
    public String walk(String walkCommandString) {
        String direction = walkCommandString.substring(1, 3);
        int steps = Integer.parseInt(walkCommandString.substring(4, walkCommandString.length() - 1));

        switch (direction) {case ""no"":for (int i = 0; i < steps; i++) {if (machineLocation.y + 1 < fieldHeight && !walls[machineLocation.y + 1][machineLocation.x]) {machineLocation.y++;}}break;case ""ea"":for (int i = 0; i < steps; i++) {if (machineLocation.x + 1 < fieldWidth && !walls[machineLocation.y][machineLocation.x + 1]) {machineLocation.x++;}}break;case ""so"":for (int i = 0; i < steps; i++) {if (machineLocation.y - 1 >= 0 && !walls[machineLocation.y - 1][machineLocation.x]) {machineLocation.y--;}}break;case ""we"":for (int i = 0; i < steps; i++) {if (machineLocation.x - 1 >= 0 && !walls[machineLocation.y][machineLocation.x - 1]) {machineLocation.x--;}}break;}

        return ""("" + machineLocation.x + "","" + machineLocation.y + "")"";
    }}


package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",1775,35,69.6,670,0.0,0.14285714285714285,0.17142857142857143,0.02857142857142857,1.6285714285714286,0.0,0.2571428571428571,0.0,True,False,False,True,False,False,2,0.08571428571428572,0.11428571428571428,0.05714285714285714,0.02857142857142857,1.6285714285714286,0.22857142857142856,0.02857142857142857,5.076923076923077,15,0.0,0
21,bing,cc,precise,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Walkable {
    private int robotX = 3;
    private int robotY = 0;
    private int roomWidth = 12;
    private int roomHeight = 8;
    private boolean[][] verticalWalls = new boolean[roomWidth + 1][roomHeight];
    private boolean[][] horizontalWalls = new boolean[roomWidth][roomHeight + 1];

    public Exercise0() {
        initializeWalls();
    }

    private void initializeWalls() {
        // Room boundaries
        for (int i = 0; i < roomHeight; i++) {
            verticalWalls[0][i] = true;
            verticalWalls[roomWidth][i] = true;
        }
        for (int i = 0; i < roomWidth; i++) {
            horizontalWalls[i][0] = true;
            horizontalWalls[i][roomHeight] = true;
        }
        // Inner walls
        for (int i = 0; i <= 3; i++) {
            verticalWalls[3][i] = true;
        }
        for (int i = 4; i <= 7; i++) {
            horizontalWalls[i][3] = true;
        }
        for (int i = 0; i <= 2; i++) {
            verticalWalls[7][i] = true;
        }
        for (int i = 1; i <= 8; i++) {
            horizontalWalls[i][4] = true;
        }
    }

    public String walkTo(String walkCommandString) {
        String direction = extractDirection(walkCommandString);
        int steps = extractSteps(walkCommandString);

        moveRobot(direction, steps);

        return ""("" + robotX + "","" + robotY + "")"";
    }

    private String extractDirection(String walkCommandString) {
        String[] parts = walkCommandString.split("","");
        return parts[0].substring(1);
    }

    private int extractSteps(String walkCommandString) {
        String[] parts = walkCommandString.split("","");
        return Integer.parseInt(parts[1].substring(0, parts[1].length() - 1));
    }

    private void moveRobot(String direction, int steps) {
        switch (direction) {
            case ""no"":
                moveNorth(steps);
                break;
            case ""ea"":
                moveEast(steps);
                break;
            case ""so"":
                moveSouth(steps);
                break;
            case ""we"":
                moveWest(steps);
                break;
        }
    }

    private void moveNorth(int steps) {
        for (int i = 0; i < steps; i++) {
            if (horizontalWalls[robotX][robotY + 1]) break;
            robotY++;
        }
    }

    private void moveEast(int steps) {
        for (int i = 0; i < steps; i++) {
            if (verticalWalls[robotX + 1][robotY]) break;
            robotX++;
        }
    }

    private void moveSouth(int steps) {
        for (int i = 0; i < steps; i++) {
            if (horizontalWalls[robotX][robotY]) break;
            robotY--;
        }
    }

    private void moveWest(int steps) {
        for (int i = 0; i < steps; i++) {
            if (verticalWalls[robotX][robotY]) break;
            robotX--;
        }
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);
}
",3057,108,31.372340425531913,81,0.018518518518518517,0.037037037037037035,0.09259259259259259,0.009259259259259259,0.3611111111111111,0.0,0.12962962962962962,0.0,True,False,False,False,False,False,2,0.09259259259259259,0.05555555555555555,0.037037037037037035,0.009259259259259259,0.7222222222222222,0.12962962962962962,0.0,8.727272727272727,17,13.0,15
21,gpt4,styled,,"package thkoeln.st.st2praktikum.exercise;
import java.awt.Point;
public class Exercise0 implements Walkable {
    private static final int F_W = 12;
    private static final int F_H = 9;
    boolean[][] f = new boolean[F_H][F_W];
    Point m;

    public Exercise0() {
        m = new Point(0, 2);
        initF();
    }

    private void initF() {
        for (int i = 0; i < F_H; i++) {
            for (int j = 0; j < F_W; j++) {
                f[i][j] = true;
            }
        }
        bW(3, 0, 3, 3);
        bW(5, 0, 5, 4);
        bW(4, 5, 7, 5);
        bW(7, 5, 7, 9);
    }

    private void bW(int startX, int startY, int endX, int endY) {
        for (int i = Math.min(startY, endY); i <= Math.max(startY, endY); i++) {
            for (int j = Math.min(startX, endX); j <= Math.max(startX, endX); j++) {
                f[i][j] = false;
            }
        }
    }

    @Override
    public String walk(String walkCommandString) {
        String[] commandParts = walkCommandString.replace(""["", """").replace(""]"", """").split("","");
        String direction = commandParts[0];
        int steps = Integer.parseInt(commandParts[1]);

        for (int i = 0; i < steps; i++) {
            switch (direction) {
                case ""no"":
                    if (m.y < F_H - 2 && f[m.y + 2][m.x]) {
                        m.y++;
                    }
                    break;
                case ""ea"":
                    if (m.x < F_W - 2 && f[m.y][m.x + 2]) {
                        m.x++;
                    }
                    break;
                case ""so"":
                    if (m.y > 1 && f[m.y - 2][m.x]) {
                        m.y--;
                    }
                    break;
                case ""we"":
                    if (m.x > 1 && f[m.y][m.x - 2]) {
                        m.x--;
                    }
                    break;
            }
        }

        return ""("" + m.x + "","" + m.y + "")"";
    }
}


package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",2075,74,30.784615384615385,95,0.0,0.05405405405405406,0.06756756756756757,0.013513513513513514,0.5135135135135135,0.0,0.10810810810810811,0.0,True,False,False,True,False,False,2,0.05405405405405406,0.05405405405405406,0.04054054054054054,0.013513513513513514,0.7702702702702703,0.17567567567567569,0.013513513513513514,3.8666666666666667,12,0.0,0
22,bing,plain,creative,"package thkoeln.st.st2praktikum.exercise;

// A class that represents a tidy-up robot that can move in a room with walls
public class Exercise0 implements Walkable {

    // Constants for the directions
    private static final String NORTH = ""no"";
    private static final String EAST = ""ea"";
    private static final String SOUTH = ""so"";
    private static final String WEST = ""we"";

    // Constants for the room size and walls
    private static final int ROOM_WIDTH = 12;
    private static final int ROOM_HEIGHT = 8;
    private static final int[][] WALLS = {{3, 0, 3, 3}, {4, 3, 7, 3}, {7, 0, 7, 2}, {1, 4, 8, 4}};

    // Variables for the robot position
    private int x;
    private int y;

    // Constructor that sets the initial position of the robot
    public Exercise0() {
        x = 3;
        y = 0;
    }

    // A method that implements the walkTo interface
    public String walkTo(String walkCommandString) {
        // Parse the command string and extract the direction and steps
        walkCommandString = walkCommandString.replace(""["", """").replace(""]"", """");
        String[] parts = walkCommandString.split("","");
        String direction = parts[0];
        int steps = Integer.parseInt(parts[1]);

        // Move the robot according to the direction and steps
        switch (direction) {
            case NORTH:
                moveNorth(steps);
                break;
            case EAST:
                moveEast(steps);
                break;
            case SOUTH:
                moveSouth(steps);
                break;
            case WEST:
                moveWest(steps);
                break;
            default:
                // Invalid direction
                break;
        }

        // Return the current position of the robot as a string
        return ""("" + x + "","" + y + "")"";
    }

    // A helper method that moves the robot north by a given number of steps
    private void moveNorth(int steps) {
        // Loop through each step and check if there is a wall or boundary ahead
        for (int i = 0; i < steps; i++) {
            // Check if the robot is at the top boundary of the room
            if (y == ROOM_HEIGHT - 1) {
                // Stop moving
                break;
            }
            // Check if there is a wall above the robot
            boolean wallAbove = false;
            for (int[] wall : WALLS) {
                // A wall is above the robot if it has the same x coordinate and its lower y coordinate is equal to the robot's upper y coordinate
                if (wall[0] == x && wall[1] == y + 1) {
                    wallAbove = true;
                    break;
                }
            }
            if (wallAbove) {
                // Stop moving
                break;
            }
            // Move one step north
            y++;
        }
    }

    // A helper method that moves the robot east by a given number of steps
    private void moveEast(int steps) {
        // Loop through each step and check if there is a wall or boundary ahead
        for (int i = 0; i < steps; i++) {
            // Check if the robot is at the right boundary of the room
            if (x == ROOM_WIDTH - 1) {
                // Stop moving
                break;
            }
            // Check if there is a wall to the right of the robot
            boolean wallRight = false;
            for (int[] wall : WALLS) {
                // A wall is to the right of the robot if it has the same y coordinate and its left x coordinate is equal to the robot's right x coordinate
                if (wall[1] == y && wall[0] == x + 1) {
                    wallRight = true;
                    break;
                }
            }
            if (wallRight) {
                // Stop moving
                break;
            }
            // Move one step east
            x++;
        }
    }

    // A helper method that moves the robot south by a given number of steps
    private void moveSouth(int steps) {
        // Loop through each step and check if there is a wall or boundary ahead
        for (int i = 0; i < steps; i++) {
            // Check if the robot is at the bottom boundary of the room
            if (y == 0) {
                // Stop moving
                break;
            }
            // Check if there is a wall below the robot
            boolean wallBelow = false;
            for (int[] wall : WALLS) {
                // A wall is below the robot if it has the same x coordinate and its upper y coordinate is equal to the robot's lower y coordinate
                if (wall[0] == x && wall[3] == y) {
                    wallBelow = true;
                    break;
                }
            }
            if (wallBelow) {
                // Stop moving
                break;
            }
            // Move one step south
            y--;
        }
    }

    // A helper method that moves the robot west by a given number of steps
    private void moveWest(int steps) {
        // Loop through each step and check if there is a wall or boundary ahead
        for (int i = 0; i < steps; i++) {
            // Check if the robot is at the left boundary of the room
            if (x == 0) {
                // Stop moving
                break;
            }
            // Check if there is a wall to the left of the robot
            boolean wallLeft = false;
            for (int[] wall : WALLS) {
                // A wall is to the left of the robot if it has the same y coordinate and its right x coordinate is equal to the robot's left x coordinate
                if (wall[1] == y && wall[2] == x) {
                    wallLeft = true;
                    break;
                }
            }
            if (wallLeft) {
                // Stop moving
                break;
            }
            // Move one step west
            x--;
        }
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);
}
",6026,171,37.29299363057325,155,0.24561403508771928,0.16374269005847952,0.06432748538011696,0.005847953216374269,0.2631578947368421,0.0,0.08187134502923976,0.0,True,False,False,False,False,False,2,0.03508771929824561,0.05263157894736842,0.04093567251461988,0.005847953216374269,0.36257309941520466,0.04678362573099415,0.0,6.933333333333334,17,49.642857142857146,136
22,gpt4,styled,,"package thkoeln.st.st2praktikum.exercise;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Exercise0 implements Walkable {
    private static final int x_max=12;
    private static final int y_max=9;
    private int posX=0;
    private int posY=2;
    private boolean[][] w = new boolean[x_max+1][y_max+1];

    public Exercise0() {
        for (int i = 0; i <= x_max; i++) {w[i][0] = true; w[i][y_max] = true;}
        for (int j = 0; j <= y_max; j++) {w[0][j] = true;w[x_max][j] = true;}
        setWall(3, 0, 3, 3);setWall(5, 0, 5, 4);setWall(4, 5, 7, 5);setWall(7, 5, 7, 9);
    }

    private void setWall(int a, int b, int c, int d) {
        if (a == c) {for (int j = b; j <= d; j++) {w[a][j] = true;}} else if (b == d) {for (int i = a; i <= c; i++) {w[i][b] = true;}}
    }

    @Override
    public String walk(String s) {
        Pattern p = Pattern.compile(""\\[(\\w+),(\\d+)\\]"");Matcher m = p.matcher(s);
        if (m.find()) {
            String dir = m.group(1);int step = Integer.parseInt(m.group(2));

            switch (dir) {case ""no"":for (int i = 0; i < step; i++) {if (!w[posX][posY+1]) posY++;}break;case ""ea"":for (int i = 0; i < step; i++) {if (!w[posX+1][posY]) posX++;}break;case ""so"":for (int i = 0; i < step; i++) {if (!w[posX][posY-1]) posY--;}break;case ""we"":for (int i = 0; i < step; i++) {if (!w[posX-1][posY]) posX--;}break;}
        }

        return String.format(""(%d,%d)"", posX, posY);
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",1577,39,49.61290322580645,339,0.0,0.1794871794871795,0.23076923076923078,0.02564102564102564,1.0512820512820513,0.0,0.20512820512820512,0.0,True,False,False,False,False,False,2,0.07692307692307693,0.1282051282051282,0.10256410256410256,0.02564102564102564,1.7435897435897436,0.28205128205128205,0.05128205128205128,2.357142857142857,5,0.0,0
23,bing,cc,creative,"package thkoeln.st.st2praktikum.exercise;

// A class that implements the Walkable interface
public class Exercise0 implements Walkable {

    // Constants for the size of the room
    public static final int ROOM_WIDTH = 12;
    public static final int ROOM_HEIGHT = 8;

    // Constants for the directions
    public static final String NORTH = ""no"";
    public static final String EAST = ""ea"";
    public static final String SOUTH = ""so"";
    public static final String WEST = ""we"";

    // A nested class that represents a wall
    private static class Wall {
        // The coordinates of the start and end points of the wall
        private int startX;
        private int startY;
        private int endX;
        private int endY;

        // A constructor that takes the coordinates as parameters
        public Wall(int startX, int startY, int endX, int endY) {
            this.startX = startX;
            this.startY = startY;
            this.endX = endX;
            this.endY = endY;
        }

        // A method that checks if a wall is horizontal or vertical
        public boolean isHorizontal() {
            return startY == endY;
        }

        // A method that checks if a wall is blocking a given coordinate in a given direction
        public boolean isBlocking(int x, int y, String direction) {
            // If the wall is horizontal
            if (isHorizontal()) {
                // Check if the coordinate is on the same row as the wall
                if (y == startY) {
                    // Check if the coordinate is strictly between the start and end points of the wall
                    if (x > startX && x < endX) {
                        // Check if the direction is north or south
                        if (direction.equals(NORTH) || direction.equals(SOUTH)) {
                            // The wall is blocking
                            return true;
                        }
                    }
                }
            } else { // If the wall is vertical
                // Check if the coordinate is on the same column as the wall
                if (x == startX) {
                    // Check if the coordinate is strictly between the start and end points of the wall
                    if (y > startY && y < endY) {
                        // Check if the direction is east or west
                        if (direction.equals(EAST) || direction.equals(WEST)) {
                            // The wall is blocking
                            return true;
                        }
                    }
                }
            }
            // The wall is not blocking
            return false;
        }
    }

    // An array of walls in the room
    private Wall[] walls;

    // The current position of the robot
    private int x;
    private int y;

    // A constructor that initializes the walls and the position of the robot
    public Exercise0() {
        walls = new Wall[4];
        walls[0] = new Wall(3,0,3,3);
        walls[1] = new Wall(4,3,7,3);
        walls[2] = new Wall(7,0,7,2);
        walls[3] = new Wall(1,4,8,4);
        x = 3;
        y = 0;
    }

    // A method that implements the walkTo method from the Walkable interface
    @Override
    public String walkTo(String walkCommandString) {
        try {
            // Parse the command string and extract the direction and steps
            String direction = walkCommandString.substring(1,3);
            int steps = Integer.parseInt(walkCommandString.substring(4,5));

            // Move the robot according to the direction and steps
            switch (direction) {
                case NORTH:
                    // Move the robot north until it reaches the room boundary or a wall
                    for (int i = 0; i < steps; i++) {
                        // Check if the next cell is within the room boundary
                        if (y + 1 < ROOM_HEIGHT) {
                            // Check if any wall is blocking the next cell
                            boolean blocked = false;
                            for (Wall wall : walls) {
                                if (wall.isBlocking(x, y + 1, direction)) {
                                    blocked = true;
                                    break;
                                }
                            }
                            // If not blocked, move to the next cell
                            if (!blocked) {
                                y++;
                            } else {
                                // If blocked, stop moving
                                break;
                            }
                        } else {
                            // If out of the room boundary, stop moving
                            break;
                        }
                    }
                    break;
                case EAST:
                    // Move the robot east until it reaches the room boundary or a wall
                    for (int i = 0; i < steps; i++) {
                        // Check if the next cell is within the room boundary
                        if (x + 1 < ROOM_WIDTH) {
                            // Check if any wall is blocking the next cell
                            boolean blocked = false;
                            for (Wall wall : walls) {
                                if (wall.isBlocking(x + 1, y, direction)) {
                                    blocked = true;
                                    break;
                                }
                            }
                            // If not blocked, move to the next cell
                            if (!blocked) {
                                x++;
                            } else {
                                // If blocked, stop moving
                                break;
                            }
                        } else {
                            // If out of the room boundary, stop moving
                            break;
                        }
                    }
                    break;
                case SOUTH:
                    // Move the robot south until it reaches the room boundary or a wall
                    for (int i = 0; i < steps; i++) {
                        // Check if the next cell is within the room boundary
                        if (y - 1 > 0) {
                            // Check if any wall is blocking the next cell
                            boolean blocked = false;
                            for (Wall wall : walls) {
                                if (wall.isBlocking(x, y - 1, direction)) {
                                    blocked = true;
                                    break;
                                }
                            }
                            // If not blocked, move to the next cell
                            if (!blocked) {
                                y--;
                            } else {
                                // If blocked, stop moving
                                break;
                            }
                        } else {
                            // If out of the room boundary, stop moving
                            break;
                        }
                    }
                    break;
                case WEST:
                    // Move the robot west until it reaches the room boundary or a wall
                    for (int i = 0; i < steps; i++) {
                        // Check if the next cell is within the room boundary
                        if (x - 1 > 0) {
                            // Check if any wall is blocking the next cell
                            boolean blocked = false;
                            for (Wall wall : walls) {
                                if (wall.isBlocking(x - 1, y, direction)) {
                                    blocked = true;
                                    break;
                                }
                            }
                            // If not blocked, move to the next cell
                            if (!blocked) {
                                x--;
                            } else {
                                // If blocked, stop moving
                                break;
                            }
                        } else {
                            // If out of the room boundary, stop moving
                            break;
                        }
                    }
                    break;
                default:
                    // If the direction is invalid, throw an exception
                    throw new IllegalArgumentException(""Invalid direction: "" + direction);
            }

            // Return the current position of the robot as a string
            return ""("" + x + "","" + y + "")"";
        } catch (Exception e) {
            // If any error occurs, return the error message as a string
            return e.getMessage();
        }
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);
}
",9185,219,43.73658536585366,103,0.2374429223744292,0.1598173515981735,0.045662100456621,0.0045662100456621,0.2191780821917808,0.0045662100456621,0.0639269406392694,0.0,True,False,False,False,False,False,2,0.0182648401826484,0.0593607305936073,0.0273972602739726,0.0091324200913242,0.3789954337899543,0.0593607305936073,0.0,5.176470588235294,11,45.23076923076923,82
23,gpt4,styled,,"package thkoeln.st.st2praktikum.exercise;

import java.util.Arrays;
import java.util.List;

public class Exercise0 implements Walkable {

    private static final int abc = 12;
    private static final int xyz = 9;
    private int[] p = new int[]{0, 2};

    private static final List<String> w = Arrays.asList(
            ""3,0-3,3"",
            ""5,0-5,4"",
            ""4,5-7,5"",
            ""7,5-7,9""
    );

    @Override
    public String walk(String s) {
        String[] c = s.replace(""["", """").replace(""]"", """").split("","");
        String d = c[0];
        int st = Integer.parseInt(c[1]);

        for (int i = 0; i < st; i++) {
            if (d.equals(""no"")) {
                if (!iw(p[0], p[1] + 1) && p[1] < xyz - 1) p[1]++;
            } else if (d.equals(""ea"")) {
                if (!iw(p[0] + 1, p[1]) && p[0] < abc - 1) p[0]++;
            } else if (d.equals(""so"")) {
                if (!iw(p[0], p[1] - 1) && p[1] > 0) p[1]--;
            } else if (d.equals(""we"")) {
                if (!iw(p[0] - 1, p[1]) && p[0] > 0) p[0]--;
            }
        }
        return ""("" + p[0] + "","" + p[1] + "")"";
    }

    private boolean iw(int x, int y) {
        for (String wl : w) {
            String[] wc = wl.split(""-"");
            int[] s = Arrays.stream(wc[0].split("","")).mapToInt(Integer::parseInt).toArray();
            int[] e = Arrays.stream(wc[1].split("","")).mapToInt(Integer::parseInt).toArray();

            if (s[0] == e[0]) { // vertical wall
                if (x == s[0] && y >= s[1] && y < e[1]) {
                    return true;
                }
            } else { // horizontal wall
                if (y == s[1] && x >= s[0] && x < e[0]) {
                    return true;
                }
            }
        }
        return false;
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",1900,63,34.660377358490564,92,0.031746031746031744,0.1746031746031746,0.031746031746031744,0.0,1.0,0.0,0.15873015873015872,0.0,False,True,False,False,False,False,2,0.047619047619047616,0.06349206349206349,0.09523809523809523,0.015873015873015872,0.7301587301587301,0.3492063492063492,0.031746031746031744,2.357142857142857,8,14.0,15
24,bing,styled,balanced,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Walkable {
    private int[][] walls = {{3, 0}, {3, 1}, {3, 2}, {3, 3}, {4, 3}, {5, 3}, {6, 3}, {7, 3}, {7, 2}, {7, 1}, {7, 0}, {1, 4}, {2, 4}, {3, 4}, {4, 4}, {5, 4}, {6, 4}, {7, 4}, {8, 4}};
    private int[] robotPosition = {3, 0};
    private int[] roomSize = {12, 8};

    public String walkTo(String walkCommandString) {
        String[] walkCommand = walkCommandString.substring(1, walkCommandString.length() - 1).split("","");
        String direction = walkCommand[0];
        int steps = Integer.parseInt(walkCommand[1]);
        int[] newPosition = new int[2];
        newPosition[0] = robotPosition[0];
        newPosition[1] = robotPosition[1];

        if (direction.equals(""no"")) {
            newPosition[1] += steps;
        } else if (direction.equals(""ea"")) {
            newPosition[0] += steps;
        } else if (direction.equals(""so"")) {
            newPosition[1] -= steps;
        } else if (direction.equals(""we"")) {
            newPosition[0] -= steps;
        } else {
            return ""Invalid direction"";
        }

        if (newPosition[0] < 0 || newPosition[0] >= roomSize[0] || newPosition[1] < 0 || newPosition[1] >= roomSize[1]) {
            return ""("" + robotPosition[0] + "","" + robotPosition[1] + "")"";
        }

        for (int[] wall : walls) {
            if (newPosition[0] == wall[0] && newPosition[1] == wall[1]) {
                return ""("" + robotPosition[0] + "","" + robotPosition[1] + "")"";
            }
        }

        robotPosition = newPosition;

        return ""("" + robotPosition[0] + "","" + robotPosition[1] + "")"";
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);
}
",1776,47,44.333333333333336,181,0.0,0.1276595744680851,0.02127659574468085,0.0,1.6382978723404256,0.0,0.1702127659574468,0.0,False,False,False,False,False,False,2,0.0425531914893617,0.06382978723404255,0.0851063829787234,0.02127659574468085,0.7021276595744681,0.1702127659574468,0.0,8.142857142857142,13,0.0,0
24,gpt4,styled,,"package thkoeln.st.st2praktikum.exercise;

import java.awt.Point;
import java.util.Arrays;
import java.util.List;

public class Exercise0 implements Walkable {
    private Point pos;
    private int w = 12;
    private int h = 9;
    private List<Point> ws = Arrays.asList(new Point(3, 0), new Point(5, 0), new Point(4, 5), new Point(7, 5));
    private List<Point> we = Arrays.asList(new Point(3, 3), new Point(5, 4), new Point(7, 5), new Point(7, 9));

    public Exercise0() {
        this.pos = new Point(0, 2);
    }

    @Override
    public String walk(String cmd) {
        String dir = cmd.substring(1, 3);
        int s = Integer.parseInt(cmd.substring(4, cmd.length() - 1));
        Point np;

        if (dir.equals(""no"")) {
            for (int i = 0; i < s; i++) {
                np = new Point(pos.x, pos.y + 1);
                if (canMove(np)) pos = np;
            }
        } else if (dir.equals(""ea"")) {
            for (int i = 0; i < s; i++) {
                np = new Point(pos.x + 1, pos.y);
                if (canMove(np)) pos = np;
            }
        } else if (dir.equals(""so"")) {
            for (int i = 0; i < s; i++) {
                np = new Point(pos.x, pos.y - 1);
                if (canMove(np)) pos = np;
            }
        } else if (dir.equals(""we"")) {
            for (int i = 0; i < s; i++) {
                np = new Point(pos.x - 1, pos.y);
                if (canMove(np)) pos = np;
            }
        }

        return ""("" + pos.x + "","" + pos.y + "")"";
    }

    private boolean canMove(Point np) {
        if (np.x < 0 || np.x >= w || np.y < 0 || np.y >= h) {
            return false;
        }

        for (int i = 0; i < ws.size(); i++) {
            if ((np.x == ws.get(i).x && np.y >= ws.get(i).y && np.y < we.get(i).y) ||
                    (np.y == ws.get(i).y && np.x >= ws.get(i).x && np.x < we.get(i).x)) {
                return false;
            }
        }

        return true;
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",2077,68,34.63793103448276,111,0.0,0.14705882352941177,0.07352941176470588,0.0,0.5882352941176471,0.0,0.14705882352941177,0.0,False,True,False,True,False,False,2,0.04411764705882353,0.07352941176470588,0.04411764705882353,0.014705882352941176,0.9558823529411765,0.3088235294117647,0.04411764705882353,1.375,3,0.0,0
25,bing,styled,precise,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Walkable {
    private int x;
    private int y;
    private final int maxX = 12;
    private final int maxY = 8;

    public Exercise0() {
        x = 3;
        y = 0;
    }

    public String walkTo(String walkCommandString) {
        String direction = walkCommandString.substring(1,3);
        int steps = Integer.parseInt(walkCommandString.substring(4, walkCommandString.length()-1));
        if (direction.equals(""no"")) {
            y += steps;
            if (y >= maxY || (x == 3 && y > 3) || (x >= 4 && x <= 7 && y > 3) || (x == 7 && y > 2) || (x >= 1 && x <= 8 && y > 4)) {
                if (y >= maxY) {
                    y = maxY;
                }
                if (x == 3 && y > 3) {
                    y = 3;
                }
                if (x >= 4 && x <= 7 && y > 3) {
                    y = 3;
                }
                if (x == 7 && y > 2) {
                    y = 2;
                }
                if (x >=1 && x <=8 && y >4) {
                    y = 4;
                }
            }
        } else if (direction.equals(""ea"")) {
            x += steps;
            if (x >= maxX || (y <= 3 && x > 3) || (y == 3 && x > 7) || (y <=2 && x >7) || (y ==4 && x >8)) {
                if (x >= maxX) {
                    x = maxX;
                }
                if (y <=3 && x >3) {
                    x = 3;
                }
                if (y ==3 && x >7) {
                    x = 7;
                }
                if (y <=2 && x >7) {
                    x = 7;
                }
                if (y ==4 && x >8) {
                    x =8;
                }
            }
        } else if (direction.equals(""so"")) {
            y -= steps;
            if (y <0) {
                y =0;
            }
        } else if (direction.equals(""we"")) {
            x -= steps;
            if (x <0) {
                x =0;
            }
        }
        return ""("" + x + "","" + y + "")"";
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);
}
",2145,73,30.028985507246375,132,0.0,0.2465753424657534,0.0,0.0,0.8356164383561644,0.0,0.0547945205479452,0.0,False,False,False,False,False,False,2,0.0273972602739726,0.0547945205479452,0.0273972602739726,0.0136986301369863,0.9863013698630136,0.1095890410958904,0.0,3.0,5,0.0,0
25,gpt4,styled,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Walkable {
    private int x = 0;
    private int y = 2;
    private final int MAX_X = 11; // As the field is 12 tiles wide (0-11)
    private final int MAX_Y = 8; // As the field is 9 tiles high (0-8)

    @Override
    public String walk(String walkCommandString) {
        String direction = walkCommandString.substring(1, 3);
        int steps = Integer.parseInt(walkCommandString.substring(4, walkCommandString.length() - 1));

        for(int i = 0; i < steps; i++) {
            if (""no"".equals(direction)) {
                if (y < MAX_Y && !(x >= 4 && x < 7 && y == 4)) {
                    y++;
                }
            } else if (""ea"".equals(direction)) {
                if (x < MAX_X && !(y >= 0 && y < 4 && x == 2) && !(y > 0 && y <= 4 && x == 4) && !(y >= 5 && x == 6)) {
                    x++;
                }
            } else if (""so"".equals(direction)) {
                if (y > 0 && !(x >= 4 && x < 7 && y == 5) && !(x == 7 && y == 6)) {
                    y--;
                }
            } else if (""we"".equals(direction)) {
                if (x > 0 && !(y >= 0 && y < 4 && x == 3) && !(y > 0 && y <= 4 && x == 5)) {
                    x--;
                }
            }
        }

        return ""("" + x + "","" + y + "")"";
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",1464,42,39.5,119,0.047619047619047616,0.19047619047619047,0.023809523809523808,0.0,1.0714285714285714,0.0,0.14285714285714285,0.0,False,False,False,False,False,False,2,0.047619047619047616,0.09523809523809523,0.047619047619047616,0.023809523809523808,0.9761904761904762,0.19047619047619047,0.0,3.857142857142857,9,35.0,36
26,bing,styled,precise,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Walkable {
    private int x;
    private int y;
    private final int maxX = 12;
    private final int maxY = 8;

    public Exercise0() {
        x = 3;
        y = 0;
    }

    @Override
    public String walkTo(String walkCommandString) {
        String direction = walkCommandString.substring(1,3);
        int steps = Integer.parseInt(walkCommandString.substring(4, walkCommandString.length()-1));
        if (direction.equals(""no"")) {
            y += steps;
            if (y >= maxY || (x == 3 && y > 3) || (x >= 4 && x <= 7 && y > 3) || (x == 7 && y > 2) || (x >= 1 && x <= 8 && y > 4)) {
                y = Math.min(maxY, Math.min(y, Math.min((x == 3 ? 3 : y), (x >= 4 && x <= 7 ? 3 : y))));
                y = Math.min(y, Math.min((x == 7 ? 2 : y), (x >= 1 && x <= 8 ? 4 : y)));
            }
        } else if (direction.equals(""ea"")) {
            x += steps;
            if (x >= maxX || (y <= 3 && x > 3) || (y == 3 && x > 7) || (y <= 2 && x > 7) || (y == 4 && x > 8)) {
                x = Math.min(maxX, Math.min(x, Math.min((y <= 3 ? 3 : x), (y == 3 ? 7 : x))));
                x = Math.min(x, Math.min((y <=2 ? 7 : x), (y ==4 ? 8 : x)));
            }
        } else if (direction.equals(""so"")) {
            y -= steps;
            if (y <0 || (x ==3 && y <0) || (x >=4 && x <=7 && y <0) || (x ==7 && y <0) || (x >=1 && x <=8 && y <0)) {
                y = Math.max(0, Math.max(y, Math.max((x ==3 ?0 :y), (x >=4 && x <=7 ?0 :y))));
                y = Math.max(y, Math.max((x ==7 ?0 :y), (x >=1 && x <=8 ?0 :y)));
            }
        } else if (direction.equals(""we"")) {
            x -= steps;
            if (x <0 || (y <=3 && x <0) || (y ==3 && x <4) || (y <=2 && x <0) || (y ==4 && x <1)) {
                x = Math.max(0, Math.max(x, Math.max((y <=3 ?0 :x), (y ==3 ?4 :x))));
                x = Math.max(x, Math.max((y <=2 ?0 :x), (y ==4 ?1 :x)));
            }
        }
        return ""("" + x + "","" + y + "")"";
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);
}
",2149,50,45.630434782608695,132,0.0,0.16,0.0,0.0,1.78,0.0,0.08,0.0,False,False,False,False,False,False,2,0.04,0.08,0.04,0.02,2.16,0.56,0.0,3.0,5,0.0,0
27,bing,styled,precise,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Walkable {
    private int x;
    private int y;
    private final int maxX = 12;
    private final int maxY = 8;

    public Exercise0() {
        x = 3;
        y = 0;
    }

    public String walkTo(String walkCommandString) {
        String direction = walkCommandString.substring(1, 3);
        int steps = Integer.parseInt(walkCommandString.substring(4, walkCommandString.length() - 1));
        if (direction.equals(""no"")) {
            y += steps;
            if (y >= maxY || (x == 3 && y > 3) || (x >= 4 && x <= 7 && y > 3) || (x == 7 && y > 2) || (x >= 1 && x <= 8 && y > 4)) {
                if (y >= maxY) {
                    y = maxY;
                }
                if (x == 3 && y > 3) {
                    y = 3;
                }
                if (x >= 4 && x <= 7 && y > 3) {
                    y = 3;
                }
                if (x == 7 && y > 2) {
                    y = 2;
                }
                if (x >= 1 && x <= 8 && y > 4) {
                    y = 4;
                }
            }
        } else if (direction.equals(""ea"")) {
            x += steps;
            if (x >= maxX || (y <= 3 && x > 3) || (y == 3 && x > 7) || (y <= 2 && x > 7) || (y == 4 && x >8)) {
                if (x >= maxX) {
                    x = maxX;
                }
                if (y <=3&&x>3){
                    x=3;
                }
                if(y==3&&x>7){
                    x=7;
                }
                if(y<=2&&x>7){
                    x=7;
                }
                if(y==4&&x>8){
                    x=8;
                }
            }
        } else if(direction.equals(""so"")){
            y-=steps;
            if(y<0||(x==3&&y<0)||(x>=4&&x<=7&&y<0)||(x==7&&y<0)||(x>=1&&x<=8&&y<0)){
                if(y<0){
                    y=0;
                }
            }
        }else{
            x-=steps;
            if(x<0||(y<=3&&x<0)||(y==3&&x<4)||(y<=2&&x<0)||(y==4&&x<1)){
                if(x<0){
                    x=0;
                }
            }
        }

        return ""("" + x + "","" + y + "")"";
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);
}
",2292,78,30.328767123287673,132,0.0,0.24358974358974358,0.0,0.0,1.0384615384615385,0.0,0.0641025641025641,0.0,False,False,False,False,False,False,2,0.02564102564102564,0.05128205128205128,0.02564102564102564,0.01282051282051282,1.1794871794871795,0.08974358974358974,0.0,3.0,5,0.0,0
27,gpt4,plain,,"package thkoeln.st.st2praktikum.exercise;

import java.util.HashSet;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Exercise0 implements Walkable {
    private static final int FIELD_WIDTH = 12;
    private static final int FIELD_HEIGHT = 9;

    private Cell position;
    private Set<Cell> walls;

    public Exercise0() {
        this.position = new Cell(0, 2);

        this.walls = new HashSet<>();
        // field boundaries
        for(int i=0; i<FIELD_WIDTH; i++) {
            this.walls.add(new Cell(i, -1)); // south boundary
            this.walls.add(new Cell(i, FIELD_HEIGHT)); // north boundary
        }
        for(int j=0; j<FIELD_HEIGHT; j++) {
            this.walls.add(new Cell(-1, j)); // west boundary
            this.walls.add(new Cell(FIELD_WIDTH, j)); // east boundary
        }
        // specified walls
        addWall(3, 0, 3, 3);
        addWall(5, 0, 5, 4);
        addWall(4, 5, 7, 5);
        addWall(7, 5, 7, 9);
    }

    private void addWall(int x1, int y1, int x2, int y2) {
        for(int i=x1; i<=x2; i++) {
            for(int j=y1; j<=y2; j++) {
                this.walls.add(new Cell(i, j));
            }
        }
    }

    public String walk(String walkCommandString) {
        Pattern pattern = Pattern.compile(""\\[(\\w+),(\\d+)\\]"");
        Matcher matcher = pattern.matcher(walkCommandString);
        if(matcher.find()) {
            String direction = matcher.group(1);
            int steps = Integer.parseInt(matcher.group(2));
            int dx = 0, dy = 0;
            switch (direction) {
                case ""no"": dy = 1; break;
                case ""so"": dy = -1; break;
                case ""ea"": dx = 1; break;
                case ""we"": dx = -1; break;
            }
            for(int i=0; i<steps; i++) {
                Cell nextPosition = new Cell(position.x + dx, position.y + dy);
                if(walls.contains(nextPosition)) break;
                this.position = nextPosition;
            }
        }
        return this.position.toString();
    }

    private static class Cell {
        int x, y;

        Cell(int x, int y) {
            this.x = x;
            this.y = y;
        }

        @Override
        public boolean equals(Object obj) {
            if(this == obj) return true;
            if(obj == null || getClass() != obj.getClass()) return false;
            Cell cell = (Cell) obj;
            return x == cell.x && y == cell.y;
        }

        @Override
        public int hashCode() {
            return 31 * x + y;
        }

        @Override
        public String toString() {
            return ""("" + x + "","" + y + "")"";
        }
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",2820,97,32.80722891566265,79,0.061855670103092786,0.05154639175257732,0.05154639175257732,0.010309278350515464,0.4948453608247423,0.0,0.14432989690721648,0.0,False,False,False,False,False,False,2,0.061855670103092786,0.061855670103092786,0.08247422680412371,0.020618556701030927,0.6288659793814433,0.1958762886597938,0.041237113402061855,5.157894736842105,17,14.166666666666666,16
28,bing,styled,precise,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Walkable {
    private int x;
    private int y;
    private int w;
    private int h;
    private boolean[][] ws;

    public Exercise0() {
        x = 3;
        y = 0;
        w = 12;
        h = 8;
        ws = new boolean[w][h];
        for (int i = 0; i < 3; i++) {
            ws[3][i] = true;
        }
        for (int i = 4; i < 7; i++) {
            ws[i][3] = true;
        }
        for (int i = 0; i < 2; i++) {
            ws[7][i] = true;
        }
        for (int i = 1; i < 8; i++) {
            ws[i][4] = true;
        }
    }

    @Override
    public String walkTo(String s) {
        String[] p = s.split("","");
        String d = p[0].substring(1);
        int n = Integer.parseInt(p[1].substring(0, p[1].length() - 1));
        switch (d) {
            case ""no"":
                for (int i = 0; i < n; i++) {
                    if (y + 1 >= h || ws[x][y + 1]) break;
                    y++;
                }
                break;
            case ""ea"":
                for (int i = 0; i < n; i++) {
                    if (x + 1 >= w || ws[x + 1][y]) break;
                    x++;
                }
                break;
            case ""so"":
                for (int i = 0; i < n; i++) {
                    if (y - 1 < 0 || ws[x][y - 1]) break;
                    y--;
                }
                break;
            case ""we"":
                for (int i = 0; i < n; i++) {
                    if (x - 1 < 0 || ws[x - 1][y]) break;
                    x--;
                }
                break;
        }
        return ""("" + x + "","" + y + "")"";
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);
}
",1793,68,26.953125,71,0.0,0.058823529411764705,0.11764705882352941,0.014705882352941176,0.6029411764705882,0.0,0.058823529411764705,0.0,True,False,False,False,False,False,2,0.029411764705882353,0.07352941176470588,0.04411764705882353,0.014705882352941176,0.9264705882352942,0.07352941176470588,0.0,1.1111111111111112,2,0.0,0
29,gpt4,plain,,"package thkoeln.st.st2praktikum.exercise;

import java.awt.Point;
import java.util.ArrayList;
import java.util.List;

public class Exercise0 implements Walkable {
    private final int fieldWidth;
    private final int fieldHeight;
    private final List<Wall> walls = new ArrayList<>();
    private Point machinePosition;

    public Exercise0() {
        this.fieldWidth = 12;
        this.fieldHeight = 9;
        this.machinePosition = new Point(0, 2);

        // Initialize walls
        walls.add(new Wall(new Point(3, 0), new Point(3, 3)));
        walls.add(new Wall(new Point(5, 0), new Point(5, 4)));
        walls.add(new Wall(new Point(4, 5), new Point(7, 5)));
        walls.add(new Wall(new Point(7, 5), new Point(7, 9)));
    }

    @Override
    public String walk(String walkCommandString) {
        // Parse command
        String direction = walkCommandString.substring(1, 3);
        int steps = Integer.parseInt(walkCommandString.substring(4, walkCommandString.length() - 1));

        // Execute command
        for (int i = 0; i < steps; i++) {
            switch (direction) {
                case ""no"":
                    if (canMoveTo(new Point(machinePosition.x, machinePosition.y + 1)))
                        machinePosition.y++;
                    break;
                case ""ea"":
                    if (canMoveTo(new Point(machinePosition.x + 1, machinePosition.y)))
                        machinePosition.x++;
                    break;
                case ""so"":
                    if (canMoveTo(new Point(machinePosition.x, machinePosition.y - 1)))
                        machinePosition.y--;
                    break;
                case ""we"":
                    if (canMoveTo(new Point(machinePosition.x - 1, machinePosition.y)))
                        machinePosition.x--;
                    break;
            }
        }

        // Return machine position
        return String.format(""(%d,%d)"", machinePosition.x, machinePosition.y);
    }

    private boolean canMoveTo(Point point) {
        // Check boundaries
        if (point.x < 0 || point.y < 0 || point.x >= fieldWidth || point.y >= fieldHeight)
            return false;

        // Check walls
        for (Wall wall : walls) {
            if (wall.intersects(point))
                return false;
        }

        return true;
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}

package thkoeln.st.st2praktikum.exercise;

import java.awt.Point;

public class Wall {
    private final Point start;
    private final Point end;

    public Wall(Point start, Point end) {
        this.start = start;
        this.end = end;
    }

    public boolean intersects(Point point) {
        return (point.x > start.x && point.x < end.x && point.y >= start.y && point.y < end.y) ||
                (point.y > start.y && point.y < end.y && point.x >= start.x && point.x < end.x);
    }
}
",2969,95,36.84615384615385,101,0.06315789473684211,0.06315789473684211,0.031578947368421054,0.010526315789473684,0.3894736842105263,0.0,0.17894736842105263,0.0,False,True,False,True,False,False,3,0.042105263157894736,0.06315789473684211,0.021052631578947368,0.021052631578947368,0.5157894736842106,0.14736842105263157,0.042105263157894736,5.214285714285714,15,15.666666666666666,23
3,bard,plain,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Moveable {

    private static final int START_X = 7;
    private static final int START_Y = 7;
    private static final int WIDTH = 11;
    private static final int HEIGHT = 8;
    private static final int[][] BARRIERS = {{2, 1}, {2, 6}, {7, 6}, {10, 1}, {10, 8}};

    private int x;
    private int y;

    public Exercise0() {
        this.x = START_X;
        this.y = START_Y;
    }

    @Override
    public String move(String moveCommandString) {
        String[] tokens = moveCommandString.replaceAll(""\\[|\\]"", """").split("","");
        String direction = tokens[0];
        int steps = Integer.parseInt(tokens[1]);

        for (int i = 0; i < steps; i++) {
            switch (direction) {
                case ""no"":
                    if (y - 1 >= 0 && !isBarrier(x, y - 1)) {
                        y--;
                    } else {
                        break;
                    }
                    break;
                case ""ea"":
                    if (x + 1 < WIDTH && !isBarrier(x + 1, y)) {
                        x++;
                    } else {
                        break;
                    }
                    break;
                case ""so"":
                    if (y + 1 < HEIGHT && !isBarrier(x, y + 1)) {
                        y++;
                    } else {
                        break;
                    }
                    break;
                case ""we"":
                    if (x - 1 >= 0 && !isBarrier(x - 1, y)) {
                        x--;
                    } else {
                        break;
                    }
                    break;
            }
        }

        return ""("" + x + "","" + y + "")"";
    }

    private boolean isBarrier(int x, int y) {
        for (int[] barrier : BARRIERS) {
            if (barrier[0] == x && barrier[1] == y) {
                return true;
            }
        }
        return false;
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String move(String moveCommandString);
}
",2104,74,31.23076923076923,87,0.0,0.06756756756756757,0.02702702702702703,0.013513513513513514,0.4864864864864865,0.0,0.12162162162162163,0.0,False,False,False,False,False,False,2,0.04054054054054054,0.0945945945945946,0.04054054054054054,0.013513513513513514,0.47297297297297297,0.0945945945945946,0.0,5.25,9,0.0,0
3,bing,cc,precise,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Walkable {
    private int robotX;
    private int robotY;
    private final int roomWidth = 12;
    private final int roomHeight = 8;
    private final boolean[][] walls = new boolean[roomWidth][roomHeight];

    public Exercise0() {
        robotX = 3;
        robotY = 0;
        initializeWalls();
    }

    private void initializeWalls() {
        for (int i = 0; i <= 3; i++) walls[3][i] = true;
        for (int i = 4; i <= 7; i++) walls[i][3] = true;
        for (int i = 0; i <= 2; i++) walls[7][i] = true;
        for (int i = 1; i <= 8; i++) walls[i][4] = true;
    }

    @Override
    public String walkTo(String walkCommandString) {
        String direction = extractDirection(walkCommandString);
        int steps = extractSteps(walkCommandString);
        moveRobot(direction, steps);
        return getCurrentPosition();
    }

    private String extractDirection(String walkCommandString) {
        String[] parts = walkCommandString.split("","");
        return parts[0].substring(1);
    }

    private int extractSteps(String walkCommandString) {
        String[] parts = walkCommandString.split("","");
        return Integer.parseInt(parts[1].substring(0, parts[1].length() - 1));
    }

    private void moveRobot(String direction, int steps) {
        switch (direction) {
            case ""no"":
                moveNorth(steps);
                break;
            case ""ea"":
                moveEast(steps);
                break;
            case ""so"":
                moveSouth(steps);
                break;
            case ""we"":
                moveWest(steps);
                break;
            default:
                throw new IllegalArgumentException(""Invalid direction: "" + direction);
        }
    }

    private void moveNorth(int steps) {
        while (steps > 0 && robotY < roomHeight - 1 && !walls[robotX][robotY + 1]) {
            robotY++;
            steps--;
        }
    }

    private void moveEast(int steps) {
        while (steps > 0 && robotX < roomWidth - 1 && !walls[robotX + 1][robotY]) {
            robotX++;
            steps--;
        }
    }

    private void moveSouth(int steps) {
        while (steps > 0 && robotY > 0 && !walls[robotX][robotY - 1]) {
            robotY--;
            steps--;
        }
    }

    private void moveWest(int steps) {
        while (steps > 0 && robotX > 0 && !walls[robotX - 1][robotY]) {
            robotX--;
            steps--;
        }
    }

    private String getCurrentPosition() {
        return ""("" + robotX + "","" + robotY + "")"";
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);
}
",2744,96,31.903614457831324,86,0.0,0.0,0.041666666666666664,0.010416666666666666,0.40625,0.010416666666666666,0.13541666666666666,0.0,True,False,False,False,False,False,2,0.11458333333333333,0.052083333333333336,0.041666666666666664,0.010416666666666666,0.6770833333333334,0.15625,0.0,7.3,17,0.0,0
3,gpt3.5,plain,,"package thkoeln.st.st2praktikum.exercise;

import java.util.ArrayList;
import java.util.List;

public class Exercise0 implements GoAble {
    private int[][] grid; // 2D array representing the spaceship deck grid
    private int startX; // starting x-coordinate of the maintenance droid
    private int startY; // starting y-coordinate of the maintenance droid
    private List<int[]> obstacles; // list of obstacles represented as start and end coordinates

    public Exercise0() {
        // Define the spaceship deck grid size
        int gridSizeX = 12;
        int gridSizeY = 8;
        grid = new int[gridSizeX][gridSizeY];

        // Set the starting coordinates of the maintenance droid
        startX = 11;
        startY = 7;

        // Define the obstacles
        obstacles = new ArrayList<>();
        obstacles.add(new int[]{6, 2, 6, 5});
        obstacles.add(new int[]{5, 5, 6, 5});
        obstacles.add(new int[]{5, 5, 5, 6});
        obstacles.add(new int[]{5, 6, 12, 6});
    }

    @Override
    public String goTo(String goCommandString) {
        // Parse the goCommandString to extract direction and number of steps
        String[] parts = goCommandString.substring(1, goCommandString.length() - 1).split("","");
        String direction = parts[0];
        int steps = Integer.parseInt(parts[1]);

        // Update the coordinates of the maintenance droid based on the direction and steps
        int newX = startX;
        int newY = startY;
        if (direction.equals(""no"")) {
            newY += steps;
        } else if (direction.equals(""ea"")) {
            newX += steps;
        } else if (direction.equals(""so"")) {
            newY -= steps;
        } else if (direction.equals(""we"")) {
            newX -= steps;
        }

        // Check if the new coordinates are within the spaceship deck boundaries
        if (newX < 0) {
            newX = 0;
        } else if (newX >= grid.length) {
            newX = grid.length - 1;
        }
        if (newY < 0) {
            newY = 0;
        } else if (newY >= grid[0].length) {
            newY = grid[0].length - 1;
        }

        // Check if the new coordinates are blocked by any obstacles
        for (int[] obstacle : obstacles) {
            int startX = obstacle[0];
            int startY = obstacle[1];
            int endX = obstacle[2];
            int endY = obstacle[3];

            if ((newX == startX && newY >= startY && newY <= endY) || (newY == startY && newX >= startX && newX <= endX)) {
                // The new coordinates are blocked by an obstacle, reset to the previous coordinates
                newX = startX;
                newY = startY;
                break;
            }
        }

        startX = newX;
        startY = newY;

        // Return the new coordinates as a string in the format ""(x, y)""
        return ""("" + startX + "","" + startY + "")"";
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String goTo(String goCommandString);
}
",3006,88,38.906666666666666,123,0.14772727272727273,0.125,0.022727272727272728,0.0,0.5,0.0,0.14772727272727273,0.0,False,True,False,False,False,False,2,0.022727272727272728,0.045454545454545456,0.125,0.011363636363636364,0.6704545454545454,0.13636363636363635,0.022727272727272728,5.928571428571429,9,55.15384615384615,81
3,gpt4,plain,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Walkable {
    private int x;
    private int y;
    private final int width = 12;
    private final int height = 9;

    public Exercise0() {
        this.x = 0;
        this.y = 2;
    }

    @Override
    public String walk(String walkCommandString) {
        String[] commandParts = walkCommandString.substring(1, walkCommandString.length() - 1).split("","");
        String direction = commandParts[0].trim();
        int steps = Integer.parseInt(commandParts[1].trim());

        switch (direction) {
            case ""no"":
                y = Math.min(y + steps, height - 1);
                if (x == 3 && y > 3) {
                    y = 3;
                } else if (x == 7 && y < 5) {
                    y = 5;
                }
                break;
            case ""ea"":
                x = Math.min(x + steps, width - 1);
                if (y <= 3 && x > 3) {
                    x = 3;
                } else if (y <= 4 && x > 5) {
                    x = 5;
                } else if (y >= 5 && x < 7) {
                    x = 7;
                }
                break;
            case ""so"":
                y = Math.max(y - steps, 0);
                if (x == 3 && y < 3) {
                    y = 3;
                } else if (x == 7 && y > 5) {
                    y = 5;
                }
                break;
            case ""we"":
                x = Math.max(x - steps, 0);
                if (y <= 3 && x < 3) {
                    x = 3;
                } else if (y <= 4 && x < 5) {
                    x = 5;
                } else if (y >= 5 && x > 7) {
                    x = 7;
                }
                break;
            default:
                throw new IllegalArgumentException(""Invalid direction: "" + direction);
        }
        return ""("" + x + "","" + y + "")"";
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",2016,68,31.419354838709676,106,0.0,0.14705882352941177,0.0,0.014705882352941176,0.6911764705882353,0.014705882352941176,0.08823529411764706,0.0,False,False,False,False,False,False,2,0.029411764705882353,0.058823529411764705,0.04411764705882353,0.014705882352941176,0.7647058823529411,0.14705882352941177,0.0,5.571428571428571,12,0.0,0
30,gpt4,cc,,"package thkoeln.st.st2praktikum.exercise;

import java.util.*;

public class Exercise0 implements Walkable {

    // Starting position
    private int currentXPosition = 0;
    private int currentYPosition = 2;

    // Field dimensions
    private static final int MAX_FIELD_WIDTH = 12;
    private static final int MAX_FIELD_HEIGHT = 9;

    // Walls
    private static final List<int[]> WALL_COORDINATES = Arrays.asList(
            new int[]{3, 0, 3, 3},
            new int[]{5, 0, 5, 4},
            new int[]{4, 5, 7, 5},
            new int[]{7, 5, 7, 9}
    );

    @Override
    public String walk(String walkCommandString) {
        try {
            Command command = parseCommand(walkCommandString);
            executeCommand(command);
        } catch (Exception e) {
            System.err.println(""Invalid command: "" + e.getMessage());
        }
        return getCurrentPositionAsString();
    }

    private Command parseCommand(String commandString) throws Exception {
        String direction = commandString.substring(1, 3);
        int steps = Integer.parseInt(commandString.substring(4, commandString.length() - 1));
        return new Command(direction, steps);
    }

    private void executeCommand(Command command) {
        for (int i = 0; i < command.steps; i++) {
            if (canMoveToNextPosition(command.direction)) {
                updateCurrentPosition(command.direction);
            } else {
                break;
            }
        }
    }

    private boolean canMoveToNextPosition(String direction) {
        int nextXPosition = getNextXPosition(direction);
        int nextYPosition = getNextYPosition(direction);
        return !hasWallAtPosition(nextXPosition, nextYPosition) && isPositionWithinField(nextXPosition, nextYPosition);
    }

    private int getNextXPosition(String direction) {
        return direction.equals(""ea"") ? currentXPosition + 1 : direction.equals(""we"") ? currentXPosition - 1 : currentXPosition;
    }

    private int getNextYPosition(String direction) {
        return direction.equals(""no"") ? currentYPosition + 1 : direction.equals(""so"") ? currentYPosition - 1 : currentYPosition;
    }

    private void updateCurrentPosition(String direction) {
        currentXPosition = getNextXPosition(direction);
        currentYPosition = getNextYPosition(direction);
    }

    private boolean hasWallAtPosition(int x, int y) {
        return WALL_COORDINATES.stream().anyMatch(wall -> isPositionWithinWall(x, y, wall));
    }

    private boolean isPositionWithinWall(int x, int y, int[] wall) {
        return x == wall[0] && y >= wall[1] && y <= wall[3];
    }

    private boolean isPositionWithinField(int x, int y) {
        return x >= 0 && x < MAX_FIELD_WIDTH && y >= 0 && y < MAX_FIELD_HEIGHT;
    }

    private String getCurrentPositionAsString() {
        return String.format(""(%d,%d)"", currentXPosition, currentYPosition);
    }

    private class Command {
        String direction;
        int steps;

        Command(String direction, int steps) {
            this.direction = direction;
            this.steps = steps;
        }
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",3243,100,39.2875,128,0.03,0.01,0.02,0.0,0.38,0.0,0.2,0.01,False,True,False,False,False,False,2,0.12,0.07,0.05,0.02,0.47,0.26,0.01,9.571428571428571,17,12.666666666666666,17
31,gpt4,cc,,"package thkoeln.st.st2praktikum.exercise;

import java.util.*;

public class Exercise0 implements Walkable {
    private static final String NORTH = ""no"";
    private static final String EAST = ""ea"";
    private static final String SOUTH = ""so"";
    private static final String WEST = ""we"";

    private int machineX;
    private int machineY;
    private int fieldWidth;
    private int fieldHeight;
    private Set<String> walls;

    public Exercise0() {
        initializeField();
        initializeWalls();
    }

    private void initializeField() {
        this.machineX = 0;
        this.machineY = 2;
        this.fieldWidth = 12;
        this.fieldHeight = 9;
    }

    private void initializeWalls() {
        this.walls = new HashSet<>();

        // Adding boundaries as walls
        addBoundaryWalls();

        // Adding specific walls
        addVerticalWall(3, 0, 3);
        addVerticalWall(5, 0, 4);
        addHorizontalWall(4, 5, 7);
        addVerticalWall(7, 5, 8);
    }

    private void addBoundaryWalls() {
        for (int i = 0; i <= fieldWidth; i++) {
            walls.add(i + "",0"");
            walls.add(i + "","" + fieldHeight);
        }
        for (int i = 0; i <= fieldHeight; i++) {
            walls.add(""0,"" + i);
            walls.add(fieldWidth + "","" + i);
        }
    }

    private void addVerticalWall(int x, int startY, int endY) {
        for (int i = startY; i < endY; i++) {
            walls.add(x + "","" + (i+1));
        }
    }

    private void addHorizontalWall(int startX, int y, int endX) {
        for (int i = startX; i < endX; i++) {
            walls.add((i+1) + "","" + y);
        }
    }

    @Override
    public String walk(String walkCommandString) {
        try {
            String[] commandParts = parseCommand(walkCommandString);
            performWalk(commandParts[0], Integer.parseInt(commandParts[1]));
        } catch (Exception e) {
            System.out.println(""Invalid command: "" + walkCommandString);
        }

        return getCurrentPosition();
    }

    private String[] parseCommand(String walkCommandString) {
        return walkCommandString.substring(1, walkCommandString.length() - 1).split("","");
    }

    private void performWalk(String direction, int steps) {
        for (int i = 0; i < steps; i++) {
            if (canMoveToNextCell(direction)) {
                moveMachine(direction);
            } else {
                break;
            }
        }
    }

    private boolean canMoveToNextCell(String direction) {
        int nextX = machineX;
        int nextY = machineY;

        switch (direction) {
            case NORTH:
                nextY++;
                break;
            case EAST:
                nextX++;
                break;
            case SOUTH:
                nextY--;
                break;
            case WEST:
                nextX--;
                break;
        }

        return !walls.contains(nextX + "","" + nextY);
    }

    private void moveMachine(String direction) {
        switch (direction) {
            case NORTH:
                machineY++;
                break;
            case EAST:
                machineX++;
                break;
            case SOUTH:
                machineY--;
                break;
            case WEST:
                machineX--;
                break;
        }
    }

    private String getCurrentPosition() {
        return ""("" + machineX + "","" + machineY + "")"";

    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",3582,140,29.418803418803417,89,0.014285714285714285,0.014285714285714285,0.05,0.014285714285714285,0.22857142857142856,0.0,0.16428571428571428,0.007142857142857143,False,False,False,False,False,False,2,0.08571428571428572,0.06428571428571428,0.02142857142857143,0.007142857142857143,0.38571428571428573,0.17142857142857143,0.007142857142857143,6.555555555555555,17,23.5,26
32,gpt4,cc,,"package thkoeln.st.st2praktikum.exercise;

import java.awt.Point;
import java.util.Arrays;
import java.util.List;

public class Exercise0 implements Walkable {

    private static final int FIELD_WIDTH = 12;
    private static final int FIELD_HEIGHT = 9;

    private static final String NORTH = ""no"";
    private static final String EAST = ""ea"";
    private static final String SOUTH = ""so"";
    private static final String WEST = ""we"";

    private Point miningMachinePosition;
    private final int[][] wallCoordinates;

    public Exercise0() {
        miningMachinePosition = new Point(0, 2);
        wallCoordinates = new int[][] {
                {3, 0, 3, 3},
                {5, 0, 5, 4},
                {4, 5, 7, 5},
                {7, 5, 7, 9}
        };
    }

    @Override
    public String walk(String walkCommandString) {
        List<String> commandParts = parseCommand(walkCommandString);
        String direction = commandParts.get(0);
        int steps = Integer.parseInt(commandParts.get(1));

        for (int i = 0; i < steps; i++) {
            if (!attemptMoveInDirection(direction)) {
                break;
            }
        }

        return formatPosition(miningMachinePosition);
    }

    private List<String> parseCommand(String command) {
        return Arrays.asList(command.replaceAll(""[\\[\\]]"", """").split("",""));
    }

    private boolean attemptMoveInDirection(String direction) {
        switch (direction) {
            case NORTH:
                return moveIfPossible(0, 1);
            case EAST:
                return moveIfPossible(1, 0);
            case SOUTH:
                return moveIfPossible(0, -1);
            case WEST:
                return moveIfPossible(-1, 0);
        }
        throw new IllegalArgumentException(""Invalid direction: "" + direction);
    }

    private boolean moveIfPossible(int dx, int dy) {
        int newX = miningMachinePosition.x + dx;
        int newY = miningMachinePosition.y + dy;

        if (isMovePossible(newX, newY)) {
            miningMachinePosition.move(newX, newY);
            return true;
        }
        return false;
    }

    private boolean isMovePossible(int x, int y) {
        return isWithinFieldBounds(x, y) && !isWall(x, y);
    }

    private boolean isWithinFieldBounds(int x, int y) {
        return x >= 0 && x < FIELD_WIDTH && y >= 0 && y < FIELD_HEIGHT;
    }

    private boolean isWall(int x, int y) {
        for (int[] wall : wallCoordinates) {
            if ((x == wall[0] && y >= wall[1] && y < wall[3]) || (y == wall[1] && x >= wall[0] && x < wall[2])) {
                return true;
            }
        }
        return false;
    }

    private String formatPosition(Point position) {
        return ""("" + position.x + "","" + position.y + "")"";
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",2907,100,34.65432098765432,113,0.0,0.03,0.04,0.01,0.44,0.01,0.19,0.0,False,True,False,True,False,False,2,0.09,0.08,0.05,0.01,0.43,0.17,0.03,7.266666666666667,21,0.0,0
33,gpt4,cc,,"package thkoeln.st.st2praktikum.exercise;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Exercise0 implements Walkable {

    private static final int FIELD_WIDTH = 12;
    private static final int FIELD_HEIGHT = 9;

    private int minerPositionX = 0;
    private int minerPositionY = 2;
    private final boolean[][] wallMatrix = new boolean[FIELD_WIDTH][FIELD_HEIGHT];

    public Exercise0() {
        initializeWalls();
    }

    private void initializeWalls() {
        setWall(3, 0, 3);
        setWall(5, 0, 4);
        setWall(4, 5, 5);
        setWall(7, 5, 9);
    }

    private void setWall(int x, int yStart, int yEnd) {
        for (int y = yStart; y < yEnd; y++) {
            wallMatrix[x][y] = true;
        }
    }

    @Override
    public String walk(String walkCommandString) {
        Pattern pattern = Pattern.compile(""\\[(\\w+),(\\d+)\\]"");
        Matcher matcher = pattern.matcher(walkCommandString);

        if (matcher.matches()) {
            String direction = matcher.group(1);
            int steps = Integer.parseInt(matcher.group(2));
            moveMiner(direction, steps);
        }

        return formatMinerPosition();
    }

    private void moveMiner(String direction, int steps) {
        switch (direction) {
            case ""no"":
                moveMinerNorth(steps);
                break;
            case ""so"":
                moveMinerSouth(steps);
                break;
            case ""ea"":
                moveMinerEast(steps);
                break;
            case ""we"":
                moveMinerWest(steps);
                break;
        }
    }

    private void moveMinerNorth(int steps) {
        for (int i = 0; i < steps && minerPositionY + 1 < FIELD_HEIGHT && !wallMatrix[minerPositionX][minerPositionY + 1]; i++) {
            minerPositionY++;
        }
    }

    private void moveMinerSouth(int steps) {
        for (int i = 0; i < steps && minerPositionY - 1 >= 0 && !wallMatrix[minerPositionX][minerPositionY - 1]; i++) {
            minerPositionY--;
        }
    }

    private void moveMinerEast(int steps) {
        for (int i = 0; i < steps && minerPositionX + 1 < FIELD_WIDTH && !wallMatrix[minerPositionX + 1][minerPositionY]; i++) {
            minerPositionX++;
        }
    }

    private void moveMinerWest(int steps) {
        for (int i = 0; i < steps && minerPositionX - 1 >= 0 && !wallMatrix[minerPositionX - 1][minerPositionY]; i++) {
            minerPositionX--;
        }
    }

    private String formatMinerPosition() {
        return ""("" + minerPositionX + "","" + minerPositionY + "")"";
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",2742,96,33.92307692307692,129,0.0,0.010416666666666666,0.07291666666666667,0.010416666666666666,0.3854166666666667,0.0,0.1875,0.0,True,False,False,False,False,False,2,0.10416666666666667,0.052083333333333336,0.041666666666666664,0.010416666666666666,0.5520833333333334,0.17708333333333334,0.020833333333333332,8.076923076923077,17,0.0,0
4,bard,plain,,"package thkoeln.st.st2praktikum.exercise;

public class Barrier {

    private int x1;
    private int y1;
    private int x2;
    private int y2;

    public Barrier(int x1, int y1, int x2, int y2) {
        this.x1 = x1;
        this.y1 = y1;
        this.x2 = x2;
        this.y2 = y2;
    }

    public int getX1() {
        return x1;
    }

    public int getY1() {
        return y1;
    }

    public int getX2() {
        return x2;
    }

    public int getY2() {
        return y2;
    }

    public boolean intersects(int x, int y) {
        return x >= x1 && x <= x2 && y >= y1 && y <= y2;
    }

    public int getX() {
        return (x1 + x2) / 2;
    }

    public int getY() {
        return (y1 + y2) / 2;
    }

}
package thkoeln.st.st2praktikum.exercise;

import java.util.Arrays;
import java.util.List;

public class Exercise0 implements Moveable {

    private static final int START_X = 7;
    private static final int START_Y = 7;
    private static final int WIDTH = 11;
    private static final int HEIGHT = 8;
    private static final List<Barrier> BARRIERS = Arrays.asList(
            new Barrier(0, 1, 10, 1),
            new Barrier(0, 1, 2, 6),
            new Barrier(2, 6, 7, 6),
            new Barrier(10, 1, 10, 8)
    );

    private int x;
    private int y;
    private int width;
    private int height;
    private List<Barrier> barriers;

    public Exercise0() {
        this(START_X, START_Y, WIDTH, HEIGHT, BARRIERS);
    }

    public Exercise0(int x, int y, int width, int height, List<Barrier> barriers) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.barriers = barriers;
    }

    @Override
    public String move(String moveCommandString) {
        String[] parts = moveCommandString.split("","");
        String direction = parts[0];
        int steps = Integer.parseInt(parts[1]);

        if (direction.equals(""no"")) {
            y -= steps;
        } else if (direction.equals(""ea"")) {
            x += steps;
        } else if (direction.equals(""so"")) {
            y += steps;
        } else if (direction.equals(""we"")) {
            x -= steps;
        }

        if (x < 0) {
            x = 0;
        } else if (x >= width) {
            x = width - 1;
        }

        if (y < 0) {
            y = 0;
        } else if (y >= height) {
            y = height - 1;
        }

        for (Barrier barrier : barriers) {
            if (barrier.intersects(x, y)) {
                x = barrier.getX();
                y = barrier.getY();
            }
        }

        return ""("" + x + "","" + y + "")"";
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String move(String moveCommandString);
}
",2753,124,26.29,83,0.0,0.07258064516129033,0.008064516129032258,0.0,0.5806451612903226,0.0,0.1935483870967742,0.0,False,True,False,False,False,False,3,0.07258064516129033,0.11290322580645161,0.024193548387096774,0.016129032258064516,0.5483870967741935,0.08064516129032258,0.016129032258064516,4.111111111111111,8,0.0,0
4,bing,cc,balanced,"package thkoeln.st.st2praktikum.exercise;

import java.util.Arrays;
import java.util.List;

public class Exercise0 implements Walkable {
    private int xCoordinate = 3;
    private int yCoordinate = 0;
    private final List<int[]> walls = Arrays.asList(new int[][]{{3,0},{3,1},{3,2},{3,3},{4,3},{5,3},{6,3},{7,3},{7,2},{7,1},{7,0},{1,4},{2,4},{3,4},{4,4},{5,4},{6,4},{7,4}});
    private final int width = 12;
    private final int height = 8;

    public String walkTo(String walkCommandString) throws IllegalArgumentException {
        String[] command = walkCommandString.substring(1, walkCommandString.length() - 1).split("","");
        String direction = command[0];
        int steps = Integer.parseInt(command[1]);
        switch (direction) {
            case ""no"":
                moveNorth(steps);
                break;
            case ""ea"":
                moveEast(steps);
                break;
            case ""so"":
                moveSouth(steps);
                break;
            case ""we"":
                moveWest(steps);
                break;
            default:
                throw new IllegalArgumentException(""Invalid direction"");
        }
        return ""("" + xCoordinate + "","" + yCoordinate + "")"";
    }

    private void moveNorth(int steps) {
        for (int i = 1; i <= steps; i++) {
            if (yCoordinate + i >= height || isWall(xCoordinate,yCoordinate+i)) {
                yCoordinate += i-1;
                break;
            }
            yCoordinate += 1;
        }
    }

    private void moveEast(int steps) {
        for (int i = 1; i <= steps; i++) {
            if (xCoordinate + i >= width || isWall(xCoordinate+i,yCoordinate)) {
                xCoordinate += i-1;
                break;
            }
            xCoordinate += 1;
        }
    }

    private void moveSouth(int steps) {
        for (int i = 1; i <= steps; i++) {
            if (yCoordinate - i < 0 || isWall(xCoordinate,yCoordinate-i)) {
                yCoordinate -= i-1;
                break;
            }
            yCoordinate -= 1;
        }
    }

    private void moveWest(int steps) {
        for (int i = 1; i <= steps; i++) {
            if (xCoordinate - i < 0 || isWall(xCoordinate-i,yCoordinate)) {
                xCoordinate -= i-1;
                break;
            }
            xCoordinate -= 1;
        }
    }

    private boolean isWall(int x,int y) {
        for (int[] wall : walls) {
            if (wall[0] == x && wall[1] == y) return true;
        }
        return false;
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);
}
",2660,87,32.98717948717949,174,0.0,0.05747126436781609,0.05747126436781609,0.011494252873563218,0.735632183908046,0.011494252873563218,0.10344827586206896,0.0,False,True,False,False,False,False,2,0.08045977011494253,0.05747126436781609,0.034482758620689655,0.011494252873563218,0.6896551724137931,0.14942528735632185,0.022988505747126436,5.5,11,0.0,0
4,gpt3.5,plain,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements GoAble {
    private int[][] obstacles;
    private int[][] spaceshipDeck;
    private int[] currentPosition;

    public Exercise0() {
        obstacles = new int[][]{{6, 2, 6, 5}, {5, 5, 6, 5}, {5, 5, 5, 6}, {5, 6, 12, 6}};
        spaceshipDeck = new int[][]{{0, 0, 12, 8}};
        currentPosition = new int[]{11, 7};
    }

    @Override
    public String goTo(String goCommandString) {
        int steps = Integer.parseInt(goCommandString.substring(4, goCommandString.length() - 1));
        String direction = goCommandString.substring(1, 3);
        int[] newPosition = new int[]{currentPosition[0], currentPosition[1]};
        switch (direction) {
            case ""no"": // move north
                for (int i = 0; i < steps; i++) {
                    newPosition[1]++;
                    if (isCollision(newPosition)) {
                        newPosition[1]--;
                        break;
                    }
                }
                break;
            case ""ea"": // move east
                for (int i = 0; i < steps; i++) {
                    newPosition[0]++;
                    if (isCollision(newPosition)) {
                        newPosition[0]--;
                        break;
                    }
                }
                break;
            case ""so"": // move south
                for (int i = 0; i < steps; i++) {
                    newPosition[1]--;
                    if (isCollision(newPosition)) {
                        newPosition[1]++;
                        break;
                    }
                }
                break;
            case ""we"": // move west
                for (int i = 0; i < steps; i++) {
                    newPosition[0]--;
                    if (isCollision(newPosition)) {
                        newPosition[0]++;
                        break;
                    }
                }
                break;
        }
        currentPosition = newPosition;
        return ""("" + currentPosition[0] + "","" + currentPosition[1] + "")"";
    }

    private boolean isCollision(int[] position) {
        for (int[] obstacle : obstacles) {
            if ((position[0] >= obstacle[0] && position[0] <= obstacle[2])
                    && (position[1] >= obstacle[1] && position[1] <= obstacle[3])) {
                return true;
            }
        }
        for (int[] deck : spaceshipDeck) {
            if ((position[0] >= deck[0] && position[0] <= deck[2])
                    && (position[1] >= deck[1] && position[1] <= deck[3])) {
                return false;
            }
        }
        return true;
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String goTo(String goCommandString);
}
",2803,81,35.81578947368421,97,0.04938271604938271,0.07407407407407407,0.07407407407407407,0.012345679012345678,0.8024691358024691,0.0,0.06172839506172839,0.0,False,False,False,False,False,False,2,0.037037037037037035,0.037037037037037035,0.037037037037037035,0.012345679012345678,0.6419753086419753,0.09876543209876543,0.0,8.3,15,9.5,10
4,gpt4,plain,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Walkable {
    private int x;
    private int y;
    private final int width = 12;
    private final int height = 9;

    public Exercise0() {
        this.x = 0;
        this.y = 2;
    }

    @Override
    public String walk(String walkCommandString) {
        String[] commandParts = walkCommandString.substring(1, walkCommandString.length() - 1).split("","");
        String direction = commandParts[0].trim();
        int steps = Integer.parseInt(commandParts[1].trim());
        int newX = x;
        int newY = y;

        switch (direction) {
            case ""no"":
                newY = Math.min(y + steps, height - 1);
                break;
            case ""ea"":
                newX = Math.min(x + steps, width - 1);
                break;
            case ""so"":
                newY = Math.max(y - steps, 0);
                break;
            case ""we"":
                newX = Math.max(x - steps, 0);
                break;
            default:
                throw new IllegalArgumentException(""Invalid direction: "" + direction);
        }

        // Check for walls
        if (!((newX >= 3 && newX <= 5 && newY == 3) || (newX >= 4 && newX <= 7 && newY == 5))) {
            x = newX;
            y = newY;
        }

        return ""("" + x + "","" + y + "")"";
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",1478,53,31.666666666666668,106,0.018867924528301886,0.018867924528301886,0.018867924528301886,0.018867924528301886,0.4339622641509434,0.018867924528301886,0.1509433962264151,0.0,False,False,False,False,False,False,2,0.03773584905660377,0.07547169811320754,0.09433962264150944,0.018867924528301886,0.6415094339622641,0.18867924528301888,0.0,5.222222222222222,12,15.0,15
5,bard,plain,,"package thkoeln.st.st2praktikum.exercise;

import java.awt.Point;
import java.util.ArrayList;
import java.util.List;

public class Exercise0 implements Moveable {

    private int x = 7;
    private int y = 7;
    private int width = 11;
    private int height = 8;
    private List<java.awt.Point> barriers = new ArrayList<>();

    public Exercise0() {
        barriers.add(new java.awt.Point(2, 1));
        barriers.add(new java.awt.Point(10, 1));
        barriers.add(new java.awt.Point(2, 6));
        barriers.add(new java.awt.Point(7, 6));
        barriers.add(new java.awt.Point(10, 8));
    }

    @Override
    public String move(String moveCommandString) {
        String[] tokens = moveCommandString.split("","");
        String direction = tokens[0];
        int steps = Integer.parseInt(tokens[1]);

        Point newPosition;
        switch (direction) {
            case ""no"":
                newPosition = new Point(x, y - steps);
                break;
            case ""ea"":
                newPosition = new Point(x + steps, y);
                break;
            case ""so"":
                newPosition = new Point(x, y + steps);
                break;
            case ""we"":
                newPosition = new Point(x - steps, y);
                break;
            default:
                throw new IllegalArgumentException(""Invalid direction: "" + direction);
        }

        if (isWithinBounds(newPosition) && !isBlocked(newPosition)) {
            x = newPosition.x;
            y = newPosition.y;
            return ""("" + x + "","" + y + "")"";
        } else {
            return ""Cannot move to "" + newPosition + ""."";
        }
    }

    private boolean isWithinBounds(Point point) {
        return point.x >= 0 && point.x < width && point.y >= 0 && point.y < height;
    }

    private boolean isBlocked(Point point) {
        for (Point barrier : barriers) {
            if (barrier.x == point.x && barrier.y == point.y) {
                return true;
            }
        }
        return false;
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String move(String moveCommandString);
}
",2150,73,32.96825396825397,86,0.0,0.0273972602739726,0.0136986301369863,0.0136986301369863,0.3424657534246575,0.0136986301369863,0.136986301369863,0.0,False,True,False,True,False,False,2,0.0547945205479452,0.0684931506849315,0.0547945205479452,0.0136986301369863,0.547945205479452,0.1232876712328767,0.0410958904109589,5.777777777777778,11,0.0,0
5,bing,cc,balanced,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Walkable {

    private final int[][] walls = {{3, 0, 3, 3}, {4, 3, 7, 3}, {7, 0, 7, 2}, {1, 4, 8, 4}};
    private final int[] position = {0, 0};
    private final int[] roomSize = {9, 5};

    public Exercise0() {
    }

    public String walkTo(String walkCommandString) {
        String[] command = walkCommandString.substring(1, walkCommandString.length() - 1).split("","");
        int steps = Integer.parseInt(command[1]);
        switch (command[0]) {
            case ""no"":
                return moveNorth(steps);
            case ""ea"":
                return moveEast(steps);
            case ""so"":
                return moveSouth(steps);
            case ""we"":
                return moveWest(steps);
            default:
                throw new IllegalArgumentException(""Invalid direction"");
        }
    }

    private String moveNorth(int steps) {
        for (int i = 1; i <= steps; i++) {
            if (position[1] + i >= roomSize[1] || isWall(position[0], position[1] + i)) {
                return ""("" + position[0] + "", "" + (position[1] + i - 1) + "")"";
            }
        }
        position[1] += steps;
        return ""("" + position[0] + "", "" + position[1] + "")"";
    }

    private String moveEast(int steps) {
        for (int i = 1; i <= steps; i++) {
            if (position[0] + i >= roomSize[0] || isWall(position[0] + i, position[1])) {
                return ""("" + (position[0] + i - 1) + "", "" + position[1] + "")"";
            }
        }
        position[0] += steps;
        return ""("" + position[0] + "", "" + position[1] + "")"";
    }

    private String moveSouth(int steps) {
        for (int i = 1; i <= steps; i++) {
            if (position[1] - i < 0 || isWall(position[0], position[1] - i)) {
                return ""("" + position[0] + "", "" + (position[1] - i + 1) + "")"";
            }
        }
        position[1] -= steps;
        return ""("" + position[0] + "", "" + position[1] + "")"";
    }

    private String moveWest(int steps) {
        for (int i = 1; i <= steps; i++) {
            if (position[0] - i < 0 || isWall(position[0] - i, position[1])) {
                return ""("" + (position[0] - i + 1) + "", "" + position[1] + "")"";
            }
        }
        position[0] -= steps;
        return ""("" + position[0] + "", "" + position[1] + "")"";
    }

    private boolean isWall(int x, int y) {
        for (int[] wall : walls) {
            if ((wall[0] == x && wall[1] == y) || (wall[2] == x && wall[3] == y)) {
                return true;
            } else if ((wall[2] == x && wall[1] == y) || (wall[0] == x && wall[3] == y)) {
                return true;
            }
        }
        return false;
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);
}
",2863,84,37.554054054054056,101,0.0,0.07142857142857142,0.05952380952380952,0.011904761904761904,0.9523809523809523,0.011904761904761904,0.11904761904761904,0.0,False,False,False,False,False,False,2,0.08333333333333333,0.03571428571428571,0.023809523809523808,0.011904761904761904,1.0119047619047619,0.14285714285714285,0.0,4.444444444444445,8,0.0,0
5,gpt3.5,plain,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements GoAble {
    private int[][] obstacles;
    private int[][] grid;
    private int currentX;
    private int currentY;

    // Constructor
    public Exercise0() {
        // Initialize the grid and obstacles based on the provided map
        obstacles = new int[][]{{6, 2, 6, 5}, {5, 5, 6, 5}, {5, 5, 5, 6}, {5, 6, 12, 6}};
        grid = new int[12][8];
        currentX = 11;
        currentY = 7;
    }

    @Override
    public String goTo(String goCommandString) {
        // Parse the goCommandString to get the direction and steps
        String direction = goCommandString.substring(1, 3);
        int steps = Integer.parseInt(goCommandString.substring(4, goCommandString.length() - 1));

        // Update the current position based on the direction and steps
        switch (direction) {
            case ""no"":
                for (int i = 1; i <= steps; i++) {
                    if (currentY + i >= 8 || isObstacle(currentX, currentY + i)) {
                        currentY += i - 1;
                        break;
                    }
                    currentY += i;
                }
                break;
            case ""ea"":
                for (int i = 1; i <= steps; i++) {
                    if (currentX + i >= 12 || isObstacle(currentX + i, currentY)) {
                        currentX += i - 1;
                        break;
                    }
                    currentX += i;
                }
                break;
            case ""so"":
                for (int i = 1; i <= steps; i++) {
                    if (currentY - i < 0 || isObstacle(currentX, currentY - i)) {
                        currentY -= i - 1;
                        break;
                    }
                    currentY -= i;
                }
                break;
            case ""we"":
                for (int i = 1; i <= steps; i++) {
                    if (currentX - i < 0 || isObstacle(currentX - i, currentY)) {
                        currentX -= i - 1;
                        break;
                    }
                    currentX -= i;
                }
                break;
            default:
                throw new IllegalArgumentException(""Invalid direction: "" + direction);
        }

        // Return the updated position as a formatted string
        return ""("" + currentX + "","" + currentY + "")"";
    }

    // Helper method to check if a given position is an obstacle
    private boolean isObstacle(int x, int y) {
        for (int[] obstacle : obstacles) {
            if (x >= obstacle[0] && x <= obstacle[2] && y >= obstacle[1] && y <= obstacle[3]) {
                return true;
            }
        }
        return false;
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String goTo(String goCommandString);
}
",2878,85,36.27272727272727,97,0.07058823529411765,0.07058823529411765,0.07058823529411765,0.011764705882352941,0.5647058823529412,0.011764705882352941,0.09411764705882353,0.0,False,False,False,False,False,False,2,0.03529411764705882,0.047058823529411764,0.023529411764705882,0.011764705882352941,0.7647058823529411,0.09411764705882353,0.0,5.4,9,48.666666666666664,60
5,gpt4,plain,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Walkable {
    private int x;
    private int y;
    private final int width = 12;
    private final int height = 9;

    public Exercise0() {
        this.x = 0;
        this.y = 2;
    }

    @Override
    public String walk(String walkCommandString) {
        String[] commandParts = walkCommandString.substring(1, walkCommandString.length() - 1).split("","");
        String direction = commandParts[0].trim();
        int steps = Integer.parseInt(commandParts[1].trim());

        switch (direction) {
            case ""no"":
                for (int i = 0; i < steps; i++) {
                    if (y < height - 1 && !(x == 3 && y == 2) && !(x == 7 && y == 4)) {
                        y++;
                    }
                }
                break;
            case ""ea"":
                for (int i = 0; i < steps; i++) {
                    if (x < width - 1 && !(y <= 3 && x == 2) && !(y <= 4 && x == 4) && !(y >= 5 && x == 6)) {
                        x++;
                    }
                }
                break;
            case ""so"":
                for (int i = 0; i < steps; i++) {
                    if (y > 0 && !(x == 3 && y == 4) && !(x == 7 && y == 6)) {
                        y--;
                    }
                }
                break;
            case ""we"":
                for (int i = 0; i < steps; i++) {
                    if (x > 0 && !(y <= 3 && x == 4) && !(y <= 4 && x == 6) && !(y >= 5 && x == 8)) {
                        x--;
                    }
                }
                break;
            default:
                throw new IllegalArgumentException(""Invalid direction: "" + direction);
        }

        return ""("" + x + "","" + y + "")"";
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",1904,60,34.148148148148145,109,0.0,0.06666666666666667,0.06666666666666667,0.016666666666666666,0.6833333333333333,0.016666666666666666,0.1,0.0,False,False,False,False,False,False,2,0.03333333333333333,0.06666666666666667,0.05,0.016666666666666666,0.8333333333333334,0.1,0.0,5.0,12,0.0,0
6,bard,plain,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Moveable {

    private int x = 7;
    private int y = 7;
    private int width = 11;
    private int height = 8;
    private int[][] barriers = {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 1, 1, 1, 0, 0, 0},
            {0, 0, 0, 1, 1, 1, 1, 1, 0, 0},
            {0, 0, 0, 1, 1, 1, 1, 1, 0, 0},
            {0, 0, 0, 0, 1, 1, 1, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    };

    public Exercise0() {
    }

    @Override
    public String move(String moveCommandString) {
        String[] parts = moveCommandString.substring(1, moveCommandString.length() - 1).split("","");
        String direction = parts[0];
        int steps = Integer.parseInt(parts[1]);

        if (direction.equals(""no"")) {
            for (int i = 0; i < steps; i++) {
                if (y - 1 < 0 || barriers[x][y - 1] == 1) {
                    break;
                }
                y--;
            }
        } else if (direction.equals(""ea"")) {
            for (int i = 0; i < steps; i++) {
                if (x + 1 >= width || barriers[x + 1][y] == 1) {
                    break;
                }
                x++;
            }
        } else if (direction.equals(""so"")) {
            for (int i = 0; i < steps; i++) {
                if (y + 1 >= height || barriers[x][y + 1] == 1) {
                    break;
                }
                y++;
            }
        } else if (direction.equals(""we"")) {
            for (int i = 0; i < steps; i++) {
                if (x - 1 < 0 || barriers[x - 1][y] == 1) {
                    break;
                }
                x--;
            }
        }

        return ""("" + x + "","" + y + "")"";
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String move(String moveCommandString);
}
",2057,68,32.60655737704918,99,0.0,0.11764705882352941,0.058823529411764705,0.0,1.9264705882352942,0.0,0.10294117647058823,0.0,False,False,False,False,False,False,2,0.029411764705882353,0.07352941176470588,0.04411764705882353,0.014705882352941176,0.5588235294117647,0.11764705882352941,0.0,4.0,8,0.0,0
6,bing,cc,balanced,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Walkable {
    private final int[][] walls = {{3, 0}, {3, 1}, {3, 2}, {3, 3}, {4, 3}, {5, 3}, {6, 3}, {7, 3}, {7, 2}, {7, 1}, {7, 0}, {1, 4}, {2, 4}, {3, 4}, {4, 4}, {5, 4}, {6, 4}, {7, 4}};
    private final int[] robotPosition = {3, 0};
    private final int roomWidth = 12;
    private final int roomHeight = 8;

    public String walkTo(String walkCommandString) {
        String[] walkCommand = walkCommandString.substring(1, walkCommandString.length() - 1).split("","");
        String direction = walkCommand[0];
        int steps = Integer.parseInt(walkCommand[1]);
        int[] newPosition = calculateNewPosition(direction, steps);
        if (isWall(newPosition)) {
            return getRobotPosition();
        }
        updateRobotPosition(newPosition);
        return getRobotPosition();
    }

    private int[] calculateNewPosition(String direction, int steps) {
        int[] newPosition = new int[]{robotPosition[0], robotPosition[1]};
        switch (direction) {
            case ""no"":
                newPosition[1] += steps;
                break;
            case ""ea"":
                newPosition[0] += steps;
                break;
            case ""so"":
                newPosition[1] -= steps;
                break;
            case ""we"":
                newPosition[0] -= steps;
                break;
        }
        if (newPosition[0] < 0) {
            newPosition[0] = 0;
        } else if (newPosition[0] >= roomWidth) {
            newPosition[0] = roomWidth - 1;
        }
        if (newPosition[1] < 0) {
            newPosition[1] = 0;
        } else if (newPosition[1] >= roomHeight) {
            newPosition[1] = roomHeight - 1;
        }
        return newPosition;
    }

    private boolean isWall(int[] position) {
        for (int[] wall : walls) {
            if (position[0] == wall[0] && position[1] == wall[1]) {
                return true;
            }
        }
        return false;
    }

    private void updateRobotPosition(int[] newPosition) {
        robotPosition[0] = newPosition[0];
        robotPosition[1] = newPosition[1];
    }

    private String getRobotPosition() {
        return ""("" + robotPosition[0] + "","" + robotPosition[1] + "")"";
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);
}
",2411,72,35.98461538461538,179,0.0,0.08333333333333333,0.013888888888888888,0.013888888888888888,1.0833333333333333,0.0,0.09722222222222222,0.0,False,False,False,False,False,False,2,0.08333333333333333,0.05555555555555555,0.06944444444444445,0.013888888888888888,0.5694444444444444,0.125,0.0,8.5,13,0.0,0
6,gpt3.5,plain,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements GoAble {

    private int currentX; // current x-coordinate of the droid
    private int currentY; // current y-coordinate of the droid
    private int gridWidth; // width of the grid
    private int gridHeight; // height of the grid
    private boolean[][] obstacles; // 2D array to represent the obstacles in the grid

    // Constructor with hardcoded values for the droid's starting position, grid size, and obstacle positions
    public Exercise0() {
        this.currentX = 11; // Starting x-coordinate of the droid
        this.currentY = 7; // Starting y-coordinate of the droid
        this.gridWidth = 12; // Width of the grid
        this.gridHeight = 8; // Height of the grid

        // Initialize the obstacles array with false (no obstacles)
        this.obstacles = new boolean[gridWidth][gridHeight];

        // Set obstacles at specific positions (0-based coordinates)
        for (int x = 6; x <= 6; x++) {
            for (int y = 2; y <= 5; y++) {
                obstacles[x][y] = true;
            }
        }
        for (int x = 5; x <= 6; x++) {
            obstacles[x][5] = true;
        }
        for (int x = 5; x <= 5; x++) {
            for (int y = 5; y <= 6; y++) {
                obstacles[x][y] = true;
            }
        }
        for (int x = 5; x <= 12; x++) {
            obstacles[x][6] = true;
        }
    }

    // Method to move the droid based on the given command and return the new position
    @Override
    public String goTo(String goCommandString) {
        String[] goCommand = goCommandString.substring(1, goCommandString.length() - 1).split("","");
        String direction = goCommand[0];
        int steps = Integer.parseInt(goCommand[1]);

        int newX = currentX;
        int newY = currentY;

        switch (direction) {
            case ""no"": // Move north
                newY = Math.min(currentY + steps, gridHeight - 1);
                break;
            case ""ea"": // Move east
                newX = Math.min(currentX + steps, gridWidth - 1);
                break;
            case ""so"": // Move south
                newY = Math.max(currentY - steps, 0);
                break;
            case ""we"": // Move west
                newX = Math.max(currentX - steps, 0);
                break;
            default:
                throw new IllegalArgumentException(""Invalid direction: "" + direction);
        }

        // Check for obstacles and update the droid's position
        if (!obstacles[newX][newY]) {
            currentX = newX;
            currentY = newY;
        }

        // Return the new position of the droid as a formatted string
        return ""("" + currentX + "","" + currentY + "")"";
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String goTo(String goCommandString);
}
",2879,81,39.97142857142857,109,0.2345679012345679,0.024691358024691357,0.1111111111111111,0.012345679012345678,0.43209876543209874,0.012345679012345678,0.13580246913580246,0.0,True,False,False,False,False,False,2,0.024691358024691357,0.06172839506172839,0.06172839506172839,0.012345679012345678,0.7160493827160493,0.09876543209876543,0.0,6.416666666666667,10,36.421052631578945,102
6,gpt4,plain,,"package thkoeln.st.st2praktikum.exercise;

import java.awt.Point;

public class Exercise0 implements Walkable {
    private int width = 12;
    private int height = 9;
    private Point currentPosition = new Point(0, 2);
    private boolean[][] walls;

    public Exercise0() {
        // Initialize walls
        walls = new boolean[width + 1][height + 1];
        for (int i = 0; i <= width; i++) {
            walls[i][0] = true;
            walls[i][height] = true;
        }
        for (int i = 0; i <= height; i++) {
            walls[0][i] = true;
            walls[width][i] = true;
        }
        // Add inner walls
        for (int i = 0; i <= 3; i++) {
            walls[3][i] = true;
            walls[5][i] = true;
        }
        walls[5][4] = true;

        for (int i = 5; i <= 7; i++) {
            walls[i][5] = true;
        }

        for (int i = 5; i <= 9; i++) {
            walls[7][i] = true;
        }
    }

    @Override
    public String walk(String walkCommandString) {
        String[] commandParts = walkCommandString.substring(1, walkCommandString.length() - 1).split("","");
        String direction = commandParts[0];
        int steps = Integer.parseInt(commandParts[1]);

        for (int i = 0; i < steps; i++) {
            Point newPosition = new Point(currentPosition);
            switch (direction) {
                case ""no"":
                    newPosition.y++;
                    if (!walls[newPosition.x][newPosition.y] && !walls[newPosition.x + 1][newPosition.y]) {
                        currentPosition = newPosition;
                    } else {
                        i = steps;
                    }
                    break;
                case ""ea"":
                    newPosition.x++;
                    if (!walls[newPosition.x][newPosition.y] && !walls[newPosition.x][newPosition.y + 1]) {
                        currentPosition = newPosition;
                    } else {
                        i = steps;
                    }
                    break;
                case ""so"":
                    newPosition.y--;
                    if (!walls[newPosition.x][newPosition.y] && !walls[newPosition.x + 1][newPosition.y]) {
                        currentPosition = newPosition;
                    } else {
                        i = steps;
                    }
                    break;
                case ""we"":
                    newPosition.x--;
                    if (!walls[newPosition.x][newPosition.y] && !walls[newPosition.x][newPosition.y + 1]) {
                        currentPosition = newPosition;
                    } else {
                        i = steps;
                    }
                    break;
            }
        }

        return String.format(""(%d,%d)"", currentPosition.x, currentPosition.y);
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",2936,89,35.5875,107,0.02247191011235955,0.0449438202247191,0.07865168539325842,0.011235955056179775,0.4044943820224719,0.0,0.10112359550561797,0.0,True,False,False,True,False,False,2,0.02247191011235955,0.0449438202247191,0.0449438202247191,0.011235955056179775,0.9775280898876404,0.056179775280898875,0.011235955056179775,6.454545454545454,15,15.5,16
7,bard,plain,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Moveable {

    private static final int WIDTH = 11;
    private static final int HEIGHT = 8;
    private static final int START_X = 7;
    private static final int START_Y = 7;
    private static final int[][] BARRIERS = {{2, 1}, {10, 1}, {2, 6}, {7, 6}, {10, 8}};

    private int x;
    private int y;

    public Exercise0() {
        this.x = START_X;
        this.y = START_Y;
    }

    @Override
    public String move(String moveCommandString) {
        String[] parts = moveCommandString.substring(1, moveCommandString.length() - 1).split("","");
        String direction = parts[0];
        int steps = Integer.parseInt(parts[1]);

        for (int i = 0; i < steps; i++) {
            if (direction.equals(""no"")) {
                if (y > 0 && y - i < HEIGHT - 1 && !isBarrier(x, y - 1)) {
                    y--;
                } else {
                    break;
                }
            } else if (direction.equals(""ea"")) {
                if (x < WIDTH - 1 && x + i < WIDTH - 1 && !isBarrier(x + 1, y)) {
                    x++;
                } else {
                    break;
                }
            } else if (direction.equals(""so"")) {
                if (y < HEIGHT - 1 && y + i < HEIGHT - 1 && !isBarrier(x, y + 1)) {
                    y++;
                } else {
                    break;
                }
            } else if (direction.equals(""we"")) {
                if (x > 0 && x - i > 0 && !isBarrier(x - 1, y)) {
                    x--;
                } else {
                    break;
                }
            }
        }

        return ""("" + x + "","" + y + "")"";
    }

    private boolean isBarrier(int x, int y) {
        for (int[] barrier : BARRIERS) {
            if (x == barrier[0] && y == barrier[1]) {
                return true;
            }
        }
        return false;
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String move(String moveCommandString);
}
",2048,69,32.983333333333334,99,0.0,0.13043478260869565,0.028985507246376812,0.0,0.5797101449275363,0.0,0.13043478260869565,0.0,False,False,False,False,False,False,2,0.043478260869565216,0.10144927536231885,0.043478260869565216,0.014492753623188406,0.6521739130434783,0.17391304347826086,0.0,4.818181818181818,8,0.0,0
7,bing,cc,creative,"package thkoeln.st.st2praktikum.exercise;

// A class that represents a robot that can walk in a room with walls
public class Exercise0 implements Walkable {

    // Constants for the room size and wall locations
    public static final int ROOM_WIDTH = 12;
    public static final int ROOM_HEIGHT = 8;
    public static final int[][] WALLS = {{3,0,3,3}, {4,3,7,3}, {7,0,7,2}, {1,4,8,4}};

    // Fields for the robot's position and direction
    private int x; // x-coordinate of the robot
    private int y; // y-coordinate of the robot
    private String dir; // direction of the robot (no, ea, so, we)

    // Constructor that sets the initial position and direction of the robot
    public Exercise0() {
        x = 3;
        y = 0;
        dir = ""no"";
    }

    // Method that takes a walk command string and returns the final position of the robot
    public String walkTo(String walkCommandString) {
        updateDirection(walkCommandString);
        moveRobot(walkCommandString);
        return getPosition();
    }

    // Method that updates the robot's direction based on the input
    private void updateDirection(String walkCommandString) {
        dir = parseDirection(walkCommandString);
    }

    // Method that moves the robot as many steps as possible without hitting a wall or boundary
    private void moveRobot(String walkCommandString) {
        int steps = parseSteps(walkCommandString);
        while (steps > 0 && isValidMove()) {
            updatePosition();
            steps--;
        }
    }

    // Method that returns the final position of the robot as a string in the format ""(x,y)""
    private String getPosition() {
        return ""("" + x + "","" + y + "")"";
    }

    // Method that parses the direction from the walk command string
    private String parseDirection(String walkCommandString) {
        walkCommandString = removeBrackets(walkCommandString);
        String[] parts = splitByComma(walkCommandString);
        return parts[0];
    }

    // Method that parses the steps from the walk command string
    private int parseSteps(String walkCommandString) {
        walkCommandString = removeBrackets(walkCommandString);
        String[] parts = splitByComma(walkCommandString);
        return Integer.parseInt(parts[1]);
    }

    // Method that removes brackets from a string
    private String removeBrackets(String s) {
        return s.replace(""["", """").replace(""]"", """");
    }

    // Method that splits a string by comma
    private String[] splitByComma(String s) {
        return s.split("","");
    }

    // Method that checks if the next move is valid based on the current position and direction
    private boolean isValidMove() {
        return !isBoundaryCrossed() && !isWallCrossed();
    }

    // Method that updates the position based on the direction
    private void updatePosition() {
        switch (dir) {
            case ""no"":
                y++;
                break;
            case ""ea"":
                x++;
                break;
            case ""so"":
                y--;
                break;
            case ""we"":
                x--;
                break;
        }
    }

    // Method that checks if the next move would cross a room boundary
    private boolean isBoundaryCrossed() {
        return (x == 0 && dir.equals(""we"")) ||
                (x == ROOM_WIDTH - 1 && dir.equals(""ea"")) ||
                (y == 0 && dir.equals(""so"")) ||
                (y == ROOM_HEIGHT - 1 && dir.equals(""no""));
    }

    // Method that checks if the next move would cross a wall
    private boolean isWallCrossed() {
        for (int[] wall : WALLS) {
            if (isVerticalWall(wall) && isSideOfWall(wall)) return true;
            if (isHorizontalWall(wall) && isAboveOrBelowWall(wall)) return true;
        }
        return false;
    }

    // Method that checks if a wall is vertical
    private boolean isVerticalWall(int[] wall) {
        int x1 = wall[0];
        int x2 = wall[2];
        return x1 == x2;
    }

    // Method that checks if a wall is horizontal
    private boolean isHorizontalWall(int[] wall) {
        int y1 = wall[1];
        int y2 = wall[3];
        return y1 == y2;
    }

    // Method that checks if the robot is on the side of a vertical wall
    private boolean isSideOfWall(int[] wall) {
        int x1 = wall[0];
        int y1 = wall[1];
        int y2 = wall[3];
        return (dir.equals(""ea"") && x == x1 - 1 && y >= y1 && y <= y2) ||
                (dir.equals(""we"") && x == x1 && y >= y1 && y <= y2);
    }

    // Method that checks if the robot is above or below a horizontal wall
    private boolean isAboveOrBelowWall(int[] wall) {
        int x1 = wall[0];
        int x2 = wall[2];
        int y1 = wall[1];
        return (dir.equals(""no"") && y == y1 - 1 && x >= x1 && x <= x2) ||
                (dir.equals(""so"") && y == y1 && x >= x1 && x <= x2);
    }
}


package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);
}
",5018,151,38.0234375,95,0.152317880794702,0.059602649006622516,0.026490066225165563,0.006622516556291391,0.46357615894039733,0.0,0.1456953642384106,0.0,False,False,False,False,False,False,2,0.11258278145695365,0.039735099337748346,0.08609271523178808,0.006622516556291391,0.4900662251655629,0.19205298013245034,0.0,5.0,17,56.56521739130435,88
7,gpt3.5,plain,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements GoAble {
    private int droidX;
    private int droidY;
    private final int gridWidth;
    private final int gridHeight;
    private final int[][] obstacles;

    public Exercise0() {
        // Initialize droid starting position and grid size
        droidX = 11;
        droidY = 7;
        gridWidth = 12;
        gridHeight = 8;

        // Define obstacle positions
        obstacles = new int[][]{
                {6, 2, 6, 5},
                {5, 5, 6, 5},
                {5, 5, 5, 6},
                {5, 6, 12, 6}
        };
    }

    @Override
    public String goTo(String goCommandString) {
        // Parse goCommandString to extract direction and steps
        String direction = goCommandString.substring(1, 3);
        int steps = Integer.parseInt(goCommandString.substring(4, goCommandString.length() - 1));

        // Update droid position based on direction and steps
        switch (direction) {
            case ""no"":
                droidY = Math.max(0, droidY - steps);
                break;
            case ""ea"":
                droidX = Math.min(gridWidth - 1, droidX + steps);
                break;
            case ""so"":
                droidY = Math.min(gridHeight - 1, droidY + steps);
                break;
            case ""we"":
                droidX = Math.max(0, droidX - steps);
                break;
            default:
                // Invalid direction, do nothing
                break;
        }

        // Check for collision with obstacles or spaceship deck boundaries
        for (int[] obstacle : obstacles) {
            int obstacleX1 = obstacle[0];
            int obstacleY1 = obstacle[1];
            int obstacleX2 = obstacle[2];
            int obstacleY2 = obstacle[3];

            if ((droidX >= obstacleX1 && droidX <= obstacleX2) && (droidY >= obstacleY1 && droidY <= obstacleY2)) {
                // Collision with obstacle, reset droid position
                droidX = Math.max(obstacleX2 + 1, Math.min(gridWidth - 1, droidX));
                droidY = Math.max(obstacleY2 + 1, Math.min(gridHeight - 1, droidY));
                break;
            }
        }

        // Format and return droid's current position as a string
        return String.format(""(%d,%d)"", droidX, droidY);
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String goTo(String goCommandString);
}
",2456,74,36.646153846153844,115,0.10810810810810811,0.013513513513513514,0.04054054054054054,0.013513513513513514,0.7162162162162162,0.0,0.12162162162162163,0.0,False,False,False,False,False,False,2,0.02702702702702703,0.06756756756756757,0.08108108108108109,0.013513513513513514,0.581081081081081,0.17567567567567569,0.0,8.5,10,45.75,63
7,gpt4,plain,,"package thkoeln.st.st2praktikum.exercise;

import java.awt.Point;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Exercise0 implements Walkable {
    private final int WIDTH = 12;
    private final int HEIGHT = 9;
    private Point currentPosition = new Point(0, 2);

    @Override
    public String walk(String walkCommandString) {
        Pattern pattern = Pattern.compile(""\\[(\\w+),(\\d+)\\]"");
        Matcher matcher = pattern.matcher(walkCommandString);

        if (matcher.find()) {
            String direction = matcher.group(1);
            int steps = Integer.parseInt(matcher.group(2));

            switch (direction) {
                case ""no"":
                    currentPosition.y = Math.min(currentPosition.y + steps, HEIGHT - 1);
                    if (currentPosition.x == 3 && currentPosition.y >= 3) {
                        currentPosition.y = Math.min(2, currentPosition.y - 1);
                    } else if (currentPosition.x == 7 && currentPosition.y >= 5) {
                        currentPosition.y = Math.min(4, currentPosition.y - 1);
                    }
                    break;
                case ""ea"":
                    currentPosition.x = Math.min(currentPosition.x + steps, WIDTH - 1);
                    if (currentPosition.y <= 3 && currentPosition.x >= 3) {
                        currentPosition.x = Math.min(2, currentPosition.x - 1);
                    } else if (currentPosition.y >= 5 && currentPosition.x >= 5) {
                        currentPosition.x = Math.min(4, currentPosition.x - 1);
                    }
                    break;
                case ""so"":
                    currentPosition.y = Math.max(currentPosition.y - steps, 0);
                    if (currentPosition.x == 3 && currentPosition.y <= 3) {
                        currentPosition.y = Math.max(4, currentPosition.y + 1);
                    } else if (currentPosition.x == 7 && currentPosition.y <= 5) {
                        currentPosition.y = Math.max(6, currentPosition.y + 1);
                    }
                    break;
                case ""we"":
                    currentPosition.x = Math.max(currentPosition.x - steps, 0);
                    if (currentPosition.y <= 3 && currentPosition.x <= 3) {
                        currentPosition.x = Math.max(4, currentPosition.x + 1);
                    } else if (currentPosition.y >= 5 && currentPosition.x <= 7) {
                        currentPosition.x = Math.max(8, currentPosition.x + 1);
                    }
                    break;
            }
        }

        return String.format(""(%d,%d)"", currentPosition.x, currentPosition.y);
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",2810,64,48.175438596491226,88,0.0,0.140625,0.015625,0.015625,0.71875,0.0,0.109375,0.0,False,False,False,True,False,False,2,0.03125,0.046875,0.0625,0.015625,0.78125,0.296875,0.046875,6.285714285714286,17,0.0,0
8,bard,styled,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Moveable {

        private int x = 7;
        private int y = 7;
        private int width = 11;
        private int height = 8;
        private String[] barriers = {""(2,1)-(10,1)"", ""(2,1)-(2,6)"", ""(2,6)-(7,6)"", ""(10,1)-(10,8)""};

        @Override
        public String move(String moveCommandString) {
                // Parse the move command string
                String[] tokens = moveCommandString.substring(1, moveCommandString.length() - 1).split("","");
                String direction = tokens[0];
                int steps = Integer.parseInt(tokens[1]);

                // Check if the move is valid
                if (!isValidMove(direction, steps)) {
                        return null;
                }

                // Move the cleaning device
                switch (direction) {
                        case ""no"":
                                for (int i = 0; i < steps; i++) {
                                        y--;
                                }
                                break;
                        case ""ea"":
                                for (int i = 0; i < steps; i++) {
                                        x++;
                                }
                                break;
                        case ""so"":
                                for (int i = 0; i < steps; i++) {
                                        y++;
                                }
                                break;
                        case ""we"":
                                for (int i = 0; i < steps; i++) {
                                        x--;
                                }
                                break;
                }

                // Return the new location of the cleaning device
                return ""("" + x + "","" + y + "")"";
        }

        private boolean isValidMove(String direction, int steps) {
                // Check if the direction is valid
                if (!direction.equals(""no"") && !direction.equals(""ea"") && !direction.equals(""so"") && !direction.equals(""we"")) {
                        return false;
                }

                // Check if the number of steps is valid
                if (steps < 1) {
                        return false;
                }

                // Check if the move will hit a barrier
                for (String barrier : barriers) {
                        String[] coords = barrier.split(""-"");
                        int x1 = Integer.parseInt(coords[0].substring(1, coords[0].length()));
                        int y1 = Integer.parseInt(coords[0].substring(coords[0].length() - 1));
                        int x2 = Integer.parseInt(coords[1].substring(1, coords[1].length()));
                        int y2 = Integer.parseInt(coords[1].substring(coords[1].length() - 1));
                        if (x >= x1 && x <= x2 && y >= y1 && y <= y2) {
                                return false;
                        }
                }

                // The move is valid
                return true;
        }
}
package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String move(String moveCommandString);
}
",3258,82,44.732394366197184,127,0.0975609756097561,0.0975609756097561,0.06097560975609756,0.012195121951219513,0.6829268292682927,0.0,0.13414634146341464,0.0,False,False,False,False,False,False,2,0.036585365853658534,0.06097560975609756,0.0975609756097561,0.012195121951219513,0.5,0.2682926829268293,0.0,3.75,9,30.75,46
8,bing,styled,creative,"package thkoeln.st.st2praktikum.exercise;

import java.util.Arrays;
import java.util.List;

public class Exercise0 implements Walkable {

    // The size of the room
    private static final int WIDTH = 12;
    private static final int HEIGHT = 8;

    // The starting location of the robot
    private int x = 3;
    private int y = 0;

    // The walls in the room
    private List<Wall> walls = Arrays.asList(
            new Wall(3, 0, 3, 3),
            new Wall(4, 3, 7, 3),
            new Wall(7, 0, 7, 2),
            new Wall(1, 4, 8, 4)
    );

    // The directions for the robot
    private enum Direction {
        NO, EA, SO, WE
    }

    // A helper class to represent a wall
    private static class Wall {
        int x1;
        int y1;
        int x2;
        int y2;

        public Wall(int x1, int y1, int x2, int y2) {
            this.x1 = x1;
            this.y1 = y1;
            this.x2 = x2;
            this.y2 = y2;
        }
    }

    // The method to move the robot according to a command
    @Override
    public String walkTo(String walkCommandString) {
        // Parse the command string
        walkCommandString = walkCommandString.trim();
        if (!walkCommandString.startsWith(""["") || !walkCommandString.endsWith(""]"")) {
            System.out.println(""Invalid command format"");
            return null;
        }
        walkCommandString = walkCommandString.substring(1, walkCommandString.length() - 1);
        String[] parts = walkCommandString.split("","");
        if (parts.length != 2) {
            System.out.println(""Invalid command format"");
            return null;
        }
        Direction direction = Direction.valueOf(parts[0].toUpperCase());
        int steps = Integer.parseInt(parts[1]);

        // Move the robot according to the direction and steps
        if (direction == Direction.NO) {
            moveNorth(steps);
        } else if (direction == Direction.EA) {
            moveEast(steps);
        } else if (direction == Direction.SO) {
            moveSouth(steps);
        } else if (direction == Direction.WE) {
            moveWest(steps);
        } else {
            System.out.println(""Invalid direction"");
            return null;
        }

        // Return the current location of the robot
        return ""("" + x + "","" + y + "")"";
    }

    // A helper method to move the robot north
    private void moveNorth(int steps) {
        // Check if there is a wall or a boundary above the robot
        for (int i = 0; i < walls.size(); i++) {
            Wall wall = walls.get(i);
            if (wall.x1 == wall.x2 && wall.x1 == x && wall.y1 <= y && wall.y2 >= y + steps) {
                // The wall blocks the robot from moving north
                steps = wall.y1 - y - 1;
                break;
            }
        }
        if (y + steps >= HEIGHT) {
            // The boundary blocks the robot from moving north
            steps = HEIGHT - y - 1;
        }
        // Update the y coordinate of the robot
        y = y + steps;
    }

    // A helper method to move the robot east
    private void moveEast(int steps) {
        // Check if there is a wall or a boundary to the right of the robot
        for (int i = 0; i < walls.size(); i++) {
            Wall wall = walls.get(i);
            if (wall.y1 == wall.y2 && wall.y1 == y && wall.x1 <= x && wall.x2 >= x + steps) {
                // The wall blocks the robot from moving east
                steps = wall.x1 - x - 1;
                break;
            }
        }
        if (x + steps >= WIDTH) {
            // The boundary blocks the robot from moving east
            steps = WIDTH - x - 1;
        }
        // Update the x coordinate of the robot
        x = x + steps;
    }

    // A helper method to move the robot south
    private void moveSouth(int steps) {
        // Check if there is a wall or a boundary below the robot
        for (int i = 0; i < walls.size(); i++) {
            Wall wall = walls.get(i);
            if (wall.x1 == wall.x2 && wall.x1 == x && wall.y1 <= y - steps && wall.y2 >= y) {
                // The wall blocks the robot from moving south
                steps = y - wall.y2 - 1;
                break;
            }
        }
        if (y - steps < 0) {
            // The boundary blocks the robot from moving south
            steps = y;
        }
        // Update the y coordinate of the robot
        y = y - steps;
    }

    // A helper method to move the robot west
    private void moveWest(int steps) {
        // Check if there is a wall or a boundary to the left of the robot
        for (int i = 0; i < walls.size(); i++) {
            Wall wall = walls.get(i);
            if (wall.y1 == wall.y2 && wall.y1 == y && wall.x1 <= x - steps && wall.x2 >= x) {
                // The wall blocks the robot from moving west
                steps = x - wall.x2 - 1;
                break;
            }
        }
        if (x - steps < 0) {
            // The boundary blocks the robot from moving west
            steps = x;
        }
        // Update the x coordinate of the robot
        x = x - steps;
    }

}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);
}
",5246,162,35.30555555555556,93,0.17901234567901234,0.1111111111111111,0.043209876543209874,0.0,0.5,0.0,0.1111111111111111,0.018518518518518517,False,True,False,False,False,False,2,0.037037037037037035,0.05555555555555555,0.043209876543209874,0.012345679012345678,0.7345679012345679,0.15432098765432098,0.012345679012345678,4.0,17,41.10344827586207,64
8,gpt3.5,plain,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements GoAble {

    private static final int GRID_WIDTH = 12;
    private static final int GRID_HEIGHT = 8;
    private static final int START_X = 11;
    private static final int START_Y = 7;
    private static final int[][] OBSTACLES = {{6, 2, 6, 5}, {5, 5, 6, 5}, {5, 5, 5, 6}, {5, 6, 12, 6}};

    private int currentX;
    private int currentY;

    public Exercise0() {
        currentX = START_X;
        currentY = START_Y;
    }

    @Override
    public String goTo(String goCommandString) {
        String[] parts = goCommandString.substring(1, goCommandString.length() - 1).split("","");
        String direction = parts[0];
        int steps = Integer.parseInt(parts[1]);

        int newX = currentX;
        int newY = currentY;

        // Update the new position based on the direction and number of steps
        switch (direction) {
            case ""no"":
                newY = Math.max(currentY - steps, 0);
                break;
            case ""ea"":
                newX = Math.min(currentX + steps, GRID_WIDTH - 1);
                break;
            case ""so"":
                newY = Math.min(currentY + steps, GRID_HEIGHT - 1);
                break;
            case ""we"":
                newX = Math.max(currentX - steps, 0);
                break;
            default:
                // Invalid direction
                return ""Invalid direction"";
        }

        // Check for collisions with obstacles or spaceship deck boundaries
        for (int[] obstacle : OBSTACLES) {
            int obstacleStartX = obstacle[0];
            int obstacleStartY = obstacle[1];
            int obstacleEndX = obstacle[2];
            int obstacleEndY = obstacle[3];

            if ((currentX == newX && currentY == newY) || // Same position as before
                    (currentX == newX && newY >= obstacleStartY && newY <= obstacleEndY &&
                            ((obstacleStartX >= currentX && obstacleStartX <= newX) ||
                                    (obstacleEndX >= currentX && obstacleEndX <= newX))) || // Colliding with vertical obstacle
                    (currentY == newY && newX >= obstacleStartX && newX <= obstacleEndX &&
                            ((obstacleStartY >= currentY && obstacleStartY <= newY) ||
                                    (obstacleEndY >= currentY && obstacleEndY <= newY)))) { // Colliding with horizontal obstacle
                // Stay at current position
                return ""("" + currentX + "","" + currentY + "")"";
            }
        }

        currentX = newX;
        currentY = newY;

        return ""("" + currentX + "","" + currentY + "")"";
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String goTo(String goCommandString);
}
",2816,76,42.8125,129,0.09210526315789473,0.013157894736842105,0.039473684210526314,0.013157894736842105,0.5131578947368421,0.0,0.15789473684210525,0.0,False,False,False,False,False,False,2,0.02631578947368421,0.09210526315789473,0.11842105263157894,0.013157894736842105,0.8947368421052632,0.10526315789473684,0.0,8.647058823529411,14,37.142857142857146,66
8,gpt4,plain,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Walkable {
    private int x;
    private int y;
    private int[][] walls;

    public Exercise0() {
        x = 0;
        y = 2;
        walls = new int[][]{
                {3, 0, 3, 3},
                {5, 0, 5, 4},
                {4, 5, 7, 5},
                {7, 5, 7, 9}
        };
    }

    @Override
    public String walk(String walkCommandString) {
        String[] parts = walkCommandString.substring(1, walkCommandString.length() - 1).split("","");
        String direction = parts[0].trim();
        int steps = Integer.parseInt(parts[1].trim());

        switch (direction) {
            case ""no"":
                for (int i = 0; i < steps; i++) {
                    if (!isWallCollision(x, y + 1)) {
                        y++;
                    }
                }
                break;
            case ""ea"":
                for (int i = 0; i < steps; i++) {
                    if (!isWallCollision(x + 1, y)) {
                        x++;
                    }
                }
                break;
            case ""so"":
                for (int i = 0; i < steps; i++) {
                    if (!isWallCollision(x, y - 1)) {
                        y--;
                    }
                }
                break;
            case ""we"":
                for (int i = 0; i < steps; i++) {
                    if (!isWallCollision(x - 1, y)) {
                        x--;
                    }
                }
                break;
        }

        return String.format(""(%d,%d)"", x, y);
    }

    private boolean isWallCollision(int newX, int newY) {
        if (newX < 0 || newX > 11 || newY < 0 || newY > 8) {
            return true;
        }

        for (int[] wall : walls) {
            if (wall[0] == newX && wall[1] <= newY && newY < wall[3]) {
                return true;
            } else if (wall[1] == newY && wall[0] <= newX && newX < wall[2]) {
                return true;
            }
        }

        return false;
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",2180,79,30.014285714285716,99,0.0,0.08860759493670886,0.0759493670886076,0.012658227848101266,0.569620253164557,0.0,0.11392405063291139,0.0,False,False,False,False,False,False,2,0.0379746835443038,0.0379746835443038,0.0379746835443038,0.012658227848101266,0.620253164556962,0.13924050632911392,0.0,3.9,9,0.0,0
9,bard,styled,,"package thkoeln.st.st2praktikum.exercise;

import java.awt.*;
import java.util.ArrayList;
import java.util.List;

public class Exercise0 implements Moveable {

    private int x = 7;
    private int y = 7;
    private int width = 11;
    private int height = 8;
    private List<Point> barriers = new ArrayList<>();

    private Point currentLocation;

    public Exercise0() {
        barriers.add(new Point(2, 1));
        barriers.add(new Point(10, 1));
        barriers.add(new Point(2, 6));
        barriers.add(new Point(7, 6));
        barriers.add(new Point(10, 8));
    }

    @Override
    public String move(String moveCommandString) {
        // Get the direction and number of steps from the move command string.
        String[] tokens = moveCommandString.split("","");
        String direction = tokens[0];
        int steps = Integer.parseInt(tokens[1]);

        // Check if the destination is blocked.
        Point destination = null;
        switch (direction) {
            case ""no"":
                destination = new Point(x, y - steps);
                break;
            case ""ea"":
                destination = new Point(x + steps, y);
                break;
            case ""so"":
                destination = new Point(x, y + steps);
                break;
            case ""we"":
                destination = new Point(x - steps, y);
                break;
        }

        if (isBlocked(destination)) {
            // If the destination is blocked, find the closest unblocked destination.
            int dx = destination.x - currentLocation.x;
            int dy = destination.y - currentLocation.y;

            for (int i = 1; i <= steps; i++) {
                Point candidate = new Point(currentLocation.x + i * dx, currentLocation.y + i * dy);
                if (!isBlocked(candidate)) {
                    destination = candidate;
                    break;
                }
            }
        }

        // Move the cleaning device to the destination.
        currentLocation = destination;
        x = destination.x;
        y = destination.y;

        // Return the new location of the cleaning device.
        return ""("" + x + "","" + y + "")"";
    }

    private boolean isBlocked(Point point) {
        // Check if the point is outside the space or if it is blocked by a barrier.
        return point.x < 0 || point.x >= width || point.y < 0 || point.y >= height || barriers.contains(point);
    }

    private Point getUnblockedDestination(Point currentLocation, Point destination, int steps) {
        // Get the difference between the current location and the destination.
        int dx = destination.x - currentLocation.x;
        int dy = destination.y - currentLocation.y;

        // For each step, check if the next point is unblocked.
        for (int i = 1; i <= steps; i++) {
            Point candidate = new Point(currentLocation.x + i * dx, currentLocation.y + i * dy);
            if (!isBlocked(candidate)) {
                return candidate;
            }
        }

        // If all the steps are blocked, return the current location.
        return currentLocation;
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String move(String moveCommandString);
}
",3258,98,38.53658536585366,111,0.09183673469387756,0.08163265306122448,0.02040816326530612,0.01020408163265306,0.2755102040816326,0.0,0.16326530612244897,0.0,False,True,False,True,False,False,2,0.04081632653061224,0.061224489795918366,0.10204081632653061,0.01020408163265306,0.6836734693877551,0.11224489795918367,0.030612244897959183,5.571428571428571,15,57.22222222222222,73
9,bing,styled,creative,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Walkable {

    private int x;
    private int y;
    private int width;
    private int height;
    private int[][] walls;

    public Exercise0() {
        x = 3;
        y = 0;
        width = 12;
        height = 8;
        walls = new int[][]{{3,0,3,3}, {4,3,7,3}, {7,0,7,2}, {1,4,8,4}};
    }

    @Override
    public String walkTo(String walkCommandString) {
        walkCommandString = walkCommandString.replace(""["", """").replace(""]"", """");
        String[] parts = walkCommandString.split("","");
        String direction = parts[0];
        int steps = Integer.parseInt(parts[1]);

        if (direction.equals(""no"")) {
            for (int i = 0; i < steps; i++) {
                boolean blocked = false;
                if (y == height - 1) {
                    blocked = true;
                } else {
                    for (int j = 0; j < walls.length; j++) {
                        if (walls[j][0] == walls[j][2] && walls[j][0] == x && walls[j][1] <= y && walls[j][3] > y) {
                            blocked = true;
                            break;
                        }
                    }
                }
                if (!blocked) {
                    y++;
                } else {
                    break;
                }
            }
        } else if (direction.equals(""ea"")) {
            for (int i = 0; i < steps; i++) {
                boolean blocked = false;
                if (x == width - 1) {
                    blocked = true;
                } else {
                    for (int j = 0; j < walls.length; j++) {
                        if (walls[j][1] == walls[j][3] && walls[j][1] == y && walls[j][0] <= x && walls[j][2] > x) {
                            blocked = true;
                            break;
                        }
                    }
                }
                if (!blocked) {
                    x++;
                } else {
                    break;
                }
            }
        } else if (direction.equals(""so"")) {
            for (int i = 0; i < steps; i++) {
                boolean blocked = false;
                if (y == 0) {
                    blocked = true;
                } else {
                    for (int j = 0; j < walls.length; j++) {
                        if (walls[j][0] == walls[j][2] && walls[j][0] == x && walls[j][1] >= y && walls[j][1] < y) {
                            blocked = true;
                            break;
                        }
                    }
                }
                if (!blocked) {
                    y--;
                } else {
                    break;
                }
            }
        } else if (direction.equals(""we"")) {
            for (int i = 0; i < steps; i++) {
                boolean blocked = false;
                if (x == 0) {
                    blocked = true;
                } else {
                    for (int j = 0; j < walls.length; j++) {
                        if (walls[j][1] == walls[j][3] && walls[j][1] == y && walls[j][0] >= x && walls[j][0] < x) {
                            blocked = true;
                            break;
                        }
                    }
                }
                if (!blocked) {
                    x--;
                } else {
                    break;
                }
            }
        } else {
            return null;
        }

        return ""("" + x + "","" + y + "")"";
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);
}
",3643,113,33.301886792452834,116,0.0,0.1415929203539823,0.07079646017699115,0.0,0.5221238938053098,0.0,0.061946902654867256,0.0,True,False,False,False,False,False,2,0.017699115044247787,0.04424778761061947,0.061946902654867256,0.008849557522123894,0.9557522123893806,0.07079646017699115,0.0,5.0,17,0.0,0
9,gpt3.5,plain,,"package thkoeln.st.st2praktikum.exercise;

import java.util.Arrays;
import java.util.List;

public class Exercise0 implements GoAble {

    private int[][] obstacles;
    private int xMax;
    private int yMax;
    private int[] currentPosition;

    public Exercise0() {
        obstacles = new int[][]{{6, 2, 6, 5}, {5, 5, 6, 5}, {5, 5, 5, 6}, {5, 6, 12, 6}};
        xMax = 12;
        yMax = 8;
        currentPosition = new int[]{11, 7};
    }

    @Override
    public String goTo(String goCommandString) {
        int[] newPosition = Arrays.copyOf(currentPosition, currentPosition.length);
        String[] goCommand = goCommandString.substring(1, goCommandString.length() - 1).split("","");
        int steps = Integer.parseInt(goCommand[1]);
        switch (goCommand[0]) {
            case ""no"":
                newPosition[1] += steps;
                break;
            case ""ea"":
                newPosition[0] += steps;
                break;
            case ""so"":
                newPosition[1] -= steps;
                break;
            case ""we"":
                newPosition[0] -= steps;
                break;
            default:
                throw new IllegalArgumentException(""Invalid direction: "" + goCommand[0]);
        }
        newPosition = clampToBoundaries(newPosition);
        for (int[] obstacle : obstacles) {
            if (isObstacleInPath(currentPosition, newPosition, obstacle)) {
                return formatPosition(currentPosition);
            }
        }
        currentPosition = newPosition;
        return formatPosition(currentPosition);
    }

    private int[] clampToBoundaries(int[] position) {
        int x = Math.max(0, Math.min(position[0], xMax));
        int y = Math.max(0, Math.min(position[1], yMax));
        return new int[]{x, y};
    }

    private boolean isObstacleInPath(int[] startPosition, int[] endPosition, int[] obstacle) {
        if (obstacle[0] == obstacle[2]) { // vertical obstacle
            int x = obstacle[0];
            int y1 = obstacle[1];
            int y2 = obstacle[3];
            if (startPosition[0] == endPosition[0] && startPosition[0] == x &&
                    Math.max(startPosition[1], endPosition[1]) >= y1 &&
                    Math.min(startPosition[1], endPosition[1]) <= y2) {
                return true;
            }
        } else if (obstacle[1] == obstacle[3]) { // horizontal obstacle
            int y = obstacle[1];
            int x1 = obstacle[0];
            int x2 = obstacle[2];
            if (startPosition[1] == endPosition[1] && startPosition[1] == y &&
                    Math.max(startPosition[0], endPosition[0]) >= x1 &&
                    Math.min(startPosition[0], endPosition[0]) <= x2) {
                return true;
            }
        }
        return false;
    }

    private String formatPosition(int[] position) {
        return String.format(""(%d,%d)"", position[0], position[1]);
    }

}
package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String goTo(String goCommandString);
}
",3049,89,37.46835443037975,99,0.02247191011235955,0.056179775280898875,0.056179775280898875,0.011235955056179775,0.8314606741573034,0.011235955056179775,0.11235955056179775,0.0,False,False,False,False,False,False,2,0.056179775280898875,0.0449438202247191,0.12359550561797752,0.011235955056179775,0.7303370786516854,0.20224719101123595,0.02247191011235955,6.277777777777778,15,18.0,19
9,gpt4,plain,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Walkable {

    private int x, y;
    private final int fieldWidth = 12;
    private final int fieldHeight = 9;

    public Exercise0() {
        x = 0;
        y = 2;
    }

    @Override
    public String walk(String walkCommandString) {
        String[] commands = walkCommandString.split("","");

        String direction = commands[0].substring(1);
        int steps = Integer.parseInt(commands[1].substring(0, commands[1].length() - 1));

        switch (direction) {
            case ""no"":
                y = Math.min(y + steps, fieldHeight - 1);
                if (x == 3 && y >= 3) y = 2;
                if (x == 5 && y <= 4) y = 5;
                if (x >= 4 && x <= 7 && y >= 5) y = 4;
                break;
            case ""ea"":
                x = Math.min(x + steps, fieldWidth - 1);
                if (y <= 3 && x >= 3) x = 2;
                if (y >= 5 && x >= 7) x = 6;
                break;
            case ""so"":
                y = Math.max(y - steps, 0);
                if (x == 3 && y <= 2) y = 3;
                if (x == 5 && y >= 4) y = 4;
                if (x >= 4 && x <= 7 && y <= 4) y = 5;
                break;
            case ""we"":
                x = Math.max(x - steps, 0);
                if (y <= 3 && x <= 2) x = 3;
                if (y >= 5 && x <= 6) x = 7;
                break;
        }

        return String.format(""(%d,%d)"", x, y);
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",1588,53,34.111111111111114,89,0.0,0.18867924528301888,0.018867924528301886,0.018867924528301886,0.9622641509433962,0.0,0.1509433962264151,0.0,False,False,False,False,False,False,2,0.03773584905660377,0.07547169811320754,0.05660377358490566,0.018867924528301886,1.0188679245283019,0.18867924528301888,0.0,6.428571428571429,11,0.0,0
student1,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Walkable {
    int x = 7;
    int y = 7;

    private final Wegberechnung weg = new Wegberechnung();

    @Override
    public String walkTo(String walkCommandString) {

        System.out.println(walkCommandString);

        String str = walkCommandString.substring(4, walkCommandString.length() - 1);
        int number = Integer.parseInt(str);

        switch (walkCommandString.charAt(1)) {

            //Mauern zwischen y1-y6 und x2; y1-y11 und x10 |
            case 'e':
                x = weg.punktberechnungEast(x, y, number);
                break;

            case 'w':
                x = weg.punktberechnungWest(x, y, number);
                break;

            //Mauern zwischen x2-x10 und y1; x2-x7 und y6 -
            case 'n':
                y = weg.punktberechnungNorth(x, y, number);
                break;

            case 's':
                y = weg.punktberechnungSouth(x, y, number);
                break;

            default:
                return ""Kollege. Weißt du, was eine Himmelsrichtung ist?"";
        }

        return ""("" + x + "","" + y + "")"";
    }
}
package thkoeln.st.st2praktikum.exercise;

import java.util.ArrayList;
import java.util.List;

public class Mauern {

    public List<String> mauernX() {

        List<String> listx = new ArrayList<>();
        listx.add(""y1-5,x2"");
        listx.add(""y1-10,x10"");
        return listx;
    }

    public List<String> mauernY() {

        List<String> listy = new ArrayList<>();
        listy.add(""x2-9,y1"");
        listy.add(""x2-6,y6"");
        return listy;
    }

}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);
}

package thkoeln.st.st2praktikum.exercise;
import java.util.List;
import static java.lang.System.out;

public class Wegberechnung {

    private final Mauern mauer = new Mauern();
    List<String> mauernx = mauer.mauernX();
    List<String> mauerny = mauer.mauernY();

    public int punktberechnungEast(int x, int y, int number) {

        outerloop:
        for (int i = 0; i < number; i++) {
            out.println(""("" + x + "","" + y + "")"");
            for (String s : this.mauernx) {

                String strx1 = s.substring(1, s.lastIndexOf(""-""));
                String strx2 = s.substring(s.lastIndexOf('-') + 1, s.lastIndexOf(','));
                String strx3 = s.substring(s.lastIndexOf('x') + 1);

                if (y >= Integer.parseInt(strx1) && y <= Integer.parseInt(strx2) && x == Integer.parseInt(strx3) - 1)
                    break outerloop;

            }
            if (x == 10)
                break;
            x++;
        }
        return x;
    }

    public int punktberechnungWest(int x, int y, int number) {

        outerloop:
        for (int i = 0; i < number; i++) {
            out.println(""("" + x + "","" + y + "")"");
            for (String s : this.mauernx) {

                String strx1 = s.substring(1, s.lastIndexOf(""-""));
                String strx2 = s.substring(s.lastIndexOf('-') + 1, s.lastIndexOf(','));
                String strx3 = s.substring(s.lastIndexOf('x') + 1);

                if (y >= Integer.parseInt(strx1) && y <= Integer.parseInt(strx2) && x == Integer.parseInt(strx3))
                    break outerloop;

            }
            if (x == 0)
                break;
            x--;
        }
        return x;
    }

    public int punktberechnungNorth(int x, int y, int number) {

        outerloop:
        for (int i = 0; i < number; i++) {
            out.println(""("" + x + "","" + y + "")"");
            for (String border : this.mauerny) {

                String stry1 = border.substring(1, border.lastIndexOf(""-""));
                String stry2 = border.substring(border.lastIndexOf('-') + 1, border.lastIndexOf(','));
                String stry3 = border.substring(border.lastIndexOf('y') + 1);

                if (x >= Integer.parseInt(stry1) && x <= Integer.parseInt(stry2) && y == Integer.parseInt(stry3) - 1)
                    break outerloop;
            }
            if (y == 7)
                break;
            y++;
        }
        return y;
    }

    public int punktberechnungSouth(int x, int y, int number) {

        outerloop:
        for (int i = 0; i < number; i++) {
            out.println(""("" + x + "","" + y + "")"");
            for (String border : this.mauerny) {

                String stry1 = border.substring(1, border.lastIndexOf(""-""));
                String stry2 = border.substring(border.lastIndexOf('-') + 1, border.lastIndexOf(','));
                String stry3 = border.substring(border.lastIndexOf('y') + 1);

                if (x >= Integer.parseInt(stry1) && x <= Integer.parseInt(stry2) && y == Integer.parseInt(stry3))
                    break outerloop;
            }
            if (y == 0)
                break;
            y--;
        }
        return y;
    }
}",4958,170,37.4140625,117,0.011764705882352941,0.047058823529411764,0.047058823529411764,0.0058823529411764705,0.5058823529411764,0.0,0.24705882352941178,0.029411764705882353,False,True,False,False,False,False,4,0.047058823529411764,0.03529411764705882,0.09411764705882353,0.01764705882352941,0.4823529411764706,0.34705882352941175,0.023529411764705882,4.7894736842105265,17,45.5,46
student100,student,,,"package thkoeln.st.st2praktikum.exercise;

import javassist.compiler.ast.Pair;

import java.awt.*;

public class Exercise0 implements Walkable {

    String Robotposition = new String(""0,2"");

    @Override
    public String walk(String walkCommandString) {
        int xMax = 11;
        int yMax = 8;
        boolean stop = false;


        String[] wallpositions = {""3,0"",""3,1"",""3,2"",""5,0"",""5,1"",""5,2"",""5,3"",""4,5"",""5,5"",""6,5"",""7,5"",
                                  ""7,6"",""7,7"",""7,8"" };

        if(walkCommandString.charAt(1)== 'n') {
            StringBuilder intXRobotPosition = new StringBuilder();
            StringBuilder intYRobotPosition = new StringBuilder();
            StringBuilder integerString = new StringBuilder();
            StringBuilder intXwallposition = new StringBuilder();
            StringBuilder intYwallposition = new StringBuilder();
            for(int i=4; i<walkCommandString.length()-1; i++){
                integerString.append(walkCommandString.charAt(i));
            }
            int steps = Integer.parseInt(integerString.toString());
            if(Robotposition.charAt(2) != ',') {
                for (int i = 2; i < Robotposition.length(); i++) {
                    intYRobotPosition.append(Robotposition.charAt(i));
                }
            }
            if(Robotposition.charAt(2) == ',') {
                for (int i = 3; i < Robotposition.length(); i++) {
                    intYRobotPosition.append(Robotposition.charAt(i));
                }
            }
            int RobotYPosition = Integer.parseInt(intYRobotPosition.toString());
            if(Robotposition.charAt(1) == ',') {
                intXRobotPosition.append(Robotposition.charAt(0));
            } else {
                intXRobotPosition.append(Robotposition.charAt(0));
                intXRobotPosition.append(Robotposition.charAt(1));
            }
            int RobotXPosition = Integer.parseInt(intXRobotPosition.toString());



            for(int j=1; j<=steps; j++) {
                int X2Wallposition = 0;
               for (int i=8; i<=10;i++) {
                   char int2Xwallposition = wallpositions[i].charAt(0);
                   int Xwallposition = Integer.parseInt(String.valueOf(int2Xwallposition));
                   char int2Ywallposition = wallpositions[i].charAt(2);
                   int Ywallposition = Integer.parseInt(String.valueOf(int2Ywallposition));
                   if (Ywallposition == RobotYPosition + 1 && Xwallposition == RobotXPosition+1) {
                       X2Wallposition = RobotXPosition - 1;
                   }
               }
                if(X2Wallposition==0) {
                    int temp = RobotYPosition + 1;
                    if (temp <= yMax) {
                        RobotYPosition += 1;
                    } else {
                        break;
                    }
                }
            }
            Robotposition = RobotXPosition+"",""+RobotYPosition;
        }
        //Osten
        if(walkCommandString.charAt(1)== 'e') {
            StringBuilder intXRobotPosition = new StringBuilder();
            StringBuilder intYRobotPosition = new StringBuilder();
            StringBuilder integerString = new StringBuilder();
            for(int i=4; i<walkCommandString.length()-1; i++){
                integerString.append(walkCommandString.charAt(i));
            }
            int steps = Integer.parseInt(integerString.toString());

            if(Robotposition.charAt(2) != ',') {
                for (int i = 2; i < Robotposition.length(); i++) {
                    intYRobotPosition.append(Robotposition.charAt(i));
                }
            }
            if(Robotposition.charAt(2) == ',') {
                for (int i = 3; i < Robotposition.length(); i++) {
                    intYRobotPosition.append(Robotposition.charAt(i));
                }
            }
            int RobotYPosition = Integer.parseInt(intYRobotPosition.toString());
            if(Robotposition.charAt(1) == ',') {
                intXRobotPosition.append(Robotposition.charAt(0));
            } else {
                intXRobotPosition.append(Robotposition.charAt(0));
                intXRobotPosition.append(Robotposition.charAt(1));
            }

            int RobotXPosition = Integer.parseInt(intXRobotPosition.toString());
            int X2Wallposition = 0;
            for(int j=1; j<=steps; j++) {

               for (int i = 0; i <= wallpositions.length-1; i++) {
                   char int2Xwallposition = wallpositions[i].charAt(0);
                   int Xwallposition = Integer.parseInt(String.valueOf(int2Xwallposition));
                   char int2Ywallposition = wallpositions[i].charAt(2);
                   int Ywallposition = Integer.parseInt(String.valueOf(int2Ywallposition));
                   if (Ywallposition == RobotYPosition && Xwallposition == RobotXPosition + 1 ||
                   Ywallposition == RobotYPosition && Xwallposition == RobotXPosition + 1) {
                       RobotXPosition = Xwallposition-1;
                       X2Wallposition = RobotXPosition;

                   }
               }
                        if(X2Wallposition==0) {
                            int temp = RobotXPosition + 1;
                            if (temp <= xMax) {
                                RobotXPosition += 1;
                            } else {
                                break;

                            }
                        }
                }


            Robotposition = RobotXPosition+"",""+RobotYPosition;

        }
        //Süden
        if(walkCommandString.charAt(1)== 's') {
            StringBuilder intXRobotPosition = new StringBuilder();
            StringBuilder intYRobotPosition = new StringBuilder();
            StringBuilder integerString = new StringBuilder();
            for(int i=4; i<walkCommandString.length()-1; i++){
                integerString.append(walkCommandString.charAt(i));
            }
            int steps = Integer.parseInt(integerString.toString());
            if(Robotposition.charAt(2) != ',') {
                for (int i = 2; i < Robotposition.length(); i++) {
                    intYRobotPosition.append(Robotposition.charAt(i));
                }
            }
            if(Robotposition.charAt(2) == ',') {
                for (int i = 3; i < Robotposition.length(); i++) {
                    intYRobotPosition.append(Robotposition.charAt(i));
                }
            }
            int RobotYPosition = Integer.parseInt(intYRobotPosition.toString());
            if(Robotposition.charAt(1) == ',') {
                intXRobotPosition.append(Robotposition.charAt(0));
            } else {
                intXRobotPosition.append(Robotposition.charAt(0));
                intXRobotPosition.append(Robotposition.charAt(1));
            }
            int RobotXPosition = Integer.parseInt(intXRobotPosition.toString());

            for(int j=1; j<=steps; j++) {
                int X2Wallposition = 0;
                for (int i = 8; i <= 10; i++) {
                    char int2Xwallposition = wallpositions[i].charAt(0);
                    int Xwallposition = Integer.parseInt(String.valueOf(int2Xwallposition));
                    char int2Ywallposition = wallpositions[i].charAt(2);
                    int Ywallposition = Integer.parseInt(String.valueOf(int2Ywallposition));

                    if (Ywallposition == RobotYPosition + 1 && Xwallposition == RobotXPosition + 1) {
                        X2Wallposition = RobotXPosition - 1;
                        break;
                    }

                }
                if(X2Wallposition==0) {
                    int temp = RobotYPosition - 1;
                    if (temp >= 0) {
                        RobotYPosition -= 1;
                    } else {
                        break;
                    }
                }

            }
            Robotposition = RobotXPosition+"",""+RobotYPosition;

        }
        //Westen
        if(walkCommandString.charAt(1)== 'w') {

            StringBuilder intXRobotPosition = new StringBuilder();
            StringBuilder intYRobotPosition = new StringBuilder();
            StringBuilder integerString = new StringBuilder();
            for(int i=4; i<walkCommandString.length()-1; i++){
                integerString.append(walkCommandString.charAt(i));
            }
            int steps = Integer.parseInt(integerString.toString());
            if(Robotposition.charAt(2) != ',') {
                for (int i = 2; i < Robotposition.length(); i++) {
                    intYRobotPosition.append(Robotposition.charAt(i));
                }
            }
            if(Robotposition.charAt(2) == ',') {
                for (int i = 3; i < Robotposition.length(); i++) {
                    intYRobotPosition.append(Robotposition.charAt(i));
                }
            }

            int RobotYPosition = Integer.parseInt(intYRobotPosition.toString());
            if(Robotposition.charAt(1) == ',') {
                intXRobotPosition.append(Robotposition.charAt(0));
            } else {
                intXRobotPosition.append(Robotposition.charAt(0));
                intXRobotPosition.append(Robotposition.charAt(1));
            }
            int RobotXPosition = Integer.parseInt(intXRobotPosition.toString());
            int X2Wallposition = 0;
            for(int j=1; j<=steps; j++) {

                for (int i = 0; i <= wallpositions.length - 1; i++) {
                    char int2Xwallposition = wallpositions[i].charAt(0);
                    int Xwallposition = Integer.parseInt(String.valueOf(int2Xwallposition));
                    char int2Ywallposition = wallpositions[i].charAt(2);
                    int Ywallposition = Integer.parseInt(String.valueOf(int2Ywallposition));
                    if (Ywallposition == RobotYPosition && Xwallposition == RobotXPosition - 1 ||
                            Ywallposition == RobotYPosition && Xwallposition == RobotXPosition - 1) {
                        RobotXPosition = Xwallposition;
                        X2Wallposition = RobotXPosition;
                        RobotYPosition = Ywallposition;

                    }
                }
                if (X2Wallposition==0) {
                    int temp = RobotXPosition - 1;
                    if (temp >= 0) {
                        RobotXPosition -= 1;
                    } else {
                        break;
                    }
                }
            }
            Robotposition = RobotXPosition+"",""+RobotYPosition;

        }
        return ""(""+Robotposition+"")"";

    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",10789,254,47.45495495495496,101,0.011811023622047244,0.11023622047244094,0.07874015748031496,0.0,0.6259842519685039,0.0,0.1141732283464567,0.0,True,False,False,False,False,True,2,0.007874015748031496,0.003937007874015748,0.2125984251968504,0.003937007874015748,0.594488188976378,0.4881889763779528,0.007874015748031496,9.5625,17,5.333333333333333,6
student102,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements GoAble {

    int x=8,y=3;




    @Override
    public String goTo(String goCommandString) {

        char direction=goCommandString.charAt(1);
        int value=Integer.parseInt(goCommandString.substring(4,5));
        //System.out.println(""debut ""+direction+"" val ""+value);
        System.out.println(""direction : ""+direction+"" value : ""+value);
        if(direction=='e') {
            //first red line
            if( x<=3 && 1<=y && y<=6){
                if( (x+value)>3)
                    x=3;
                else
                    x += value;
            }
            //second red line
            if( 4<=x && x<=5 && 2<=y && y<=4){
                if( (x+value)>5)
                    x=5;
                else
                    x += value;
                System.out.println(""hello word"");
            }
            //the another case
            if(6<=x){
                x+=value;
            }
            if( x<=4 && (y==0 || 7<=y) ){
                x+=value;
            }
            if( 4<=x && x<=5 && (y==1 || y>4)){
                    x += value;
            }
        }
        if(direction=='w') {
            //first red line west
            if( 4<=x && x<=6 && 1<=y && y<=7){
                if( (x-value)<4)
                    x=4;
                else
                    x -= value;
            }
            //second red line west
            if( 6<=x  && 2<=y && y<=4){
                if( (x-value)<6)
                    x = 6;
                else
                    x -= value;
            }
            //The another case
            if(4<=x && (y==1 || (5<=y && y<=6)  )){
                if( (x-value)<4) {
                    x = 4;
                }
                else
                    x-=value;
            }
            if(y == 0 || y > 6){
                x-=value;
            }
        }
        if(direction=='n') {
            //bottom red line nord
            if( 6<=x && x<=8 && (y==1 || y==0) ){
                if( (y+value)>1  )
                    y=1;
                else
                    y += value;
            }
            //top red line nord
            if(6<=x && x<=8 && (1<y && y<5) ){
                if( (y+value)>4 )
                    y=4;
                else
                    y+=value;
            }
            if(x<4 || x==4 || x==5 || 9<=x)
                y+=value;
            if(6<=x && x<=8 && 5<=y)
                y+=value;
        }
        if(direction=='s') {
            //bottom red line
            if(6<=x && x<=8 && 2<=y && y<=4){
                if( (y-value)<2 )
                    y=2;
                else
                    y-=value;
            }
            //top red line
            if(6<=x && x<=8 && 5<=y){
                if( (x-value)<5 ){
                    y=5;
                }
                else
                    y -= value;
            }
            //another case
            if(x<4 || x==4 || x==5 || 9<=x)
                y-=value;
            if(6<=x && x<=8 && y<=1)
                y-=value;
        }
        System.out.println(""x: ""+x+"" y= ""+y);
        return ""(""+x+"",""+y+"")"";
    }
    private boolean check(int firstX,int firstY){

        return true;
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface GoAble {

    String goTo(String goCommandString);
}
",3401,127,28.224137931034484,71,0.09448818897637795,0.23622047244094488,0.0,0.0,0.6535433070866141,0.0,0.07086614173228346,0.031496062992125984,False,False,False,False,False,False,2,0.023622047244094488,0.015748031496062992,0.015748031496062992,0.007874015748031496,1.0078740157480315,0.047244094488188976,0.0,4.0,9,19.083333333333332,53
student103,student,,,"package thkoeln.st.st2praktikum.exercise;


public class Exercise0 implements Moveable {

    //x sit von 0 bis 7
    private int achseX = 9;
    //y ist von 0 bis 11
    private int achseY = 13;

    private int achseXminus1 = achseX-1;
    private int achseYminus1 = achseY-1;

    private int feld[][] = new int[achseY][achseX];


    private int position[] = {5,3};


    @Override
    public String moveTo(String moveCommandString) {

        felden();

        //Extrahieren der Richtung
        // String richtung = (moveCommandString.substring(1, 3));
        String richtung = (moveCommandString.substring((moveCommandString.indexOf('[') + 1), (moveCommandString.indexOf(','))));
        // Extrahieren der Bewegungseinheiten
        // bewegungseinheiten = Integer.parseInt(moveCommandString.substring(4, 5));
       int  bewegungseinheiten = Integer.parseInt(moveCommandString.substring((moveCommandString.indexOf(',') + 1), (moveCommandString.indexOf(']'))));


        //Kontrollkram, später weg
        /*
        System.out.println(""Position  Zeile: "" + position[0]);
        System.out.println(""Position  Spalte: "" + position[1]);
        System.out.println(""Position Richtung: "" + richtung);
        System.out.println(""Position Bewegungseinheiten: "" + bewegungseinheiten);
         */

        switch (richtung){


            case ""no"": {

                /*
                bewegen nach norden

                -------
                1.1 prüfen, ob ich bereits oben bin
                1.2 bewegung ist inhalt von position[1] um eine zeile erhöht
                vergleich das mit dem grid, ob da mauer ist
                wenn ja nicht bewegen
                wenn nein bewegen
                ------

                 */

                do{

                //check ob in oberster Zeile also position[1] == 7
                //statt break auch einfach ien return machen, geht auch
                if (position[1] == 7) break;

               //     System.out.println(""Wert position0: ""+position[0]+"" Wert postion1 +1:  ""+(position[1]+1));

                    int temp_feldwert = feld[position[0]][(position[1]+1)];
                 //   System.out.println(""Wert temp_feld: ""+temp_feldwert);


                    int posplus2=position[1]+2;
                    if(posplus2>=7) posplus2=7;
                    int temp_feldwert2 = feld[position[0]][posplus2];

                //    System.out.println(""Wert temp_feld2: ""+temp_feldwert2);

                    int posplus3=position[1]+1;
                    if(posplus3>=7) posplus3=7;
                    int temp_feldwert3 = feld[position[0]+1][posplus3];

                  //  System.out.println(""Wert temp_feld3: ""+temp_feldwert3);

                if(temp_feldwert==0 ||((temp_feldwert==1 && temp_feldwert2==1)&&(temp_feldwert3==0))){
                    position[1]=position[1]+1;
                }else break;


                bewegungseinheiten--;
            } while(bewegungseinheiten>0);

            }break;


            //--------------------------------------------------------------------------------
            //--------------------------------------------------------------------------------
            //--------------------------------------------------------------------------------
            //--------------------------------------------------------------------------------


            case ""ea"":{

                do{

                    //statt break auch einfach ien return machen, geht auch
                    if (position[0] == 11) break;

                //    System.out.println(""Wert position0 +1:   ""+(position[0]+1)+"" Wert postion1: ""+(position[1]));

                    int temp_feldwert = feld[position[0]+1][(position[1])];
              //      System.out.println(""Wert temp_feld: ""+temp_feldwert);

                    int posplus2=position[0]+2;
                    if(posplus2>=11) posplus2=10;
                    int temp_feldwert2 = feld[posplus2][(position[1])];

              //      System.out.println(""Wert temp_feld2: ""+temp_feldwert2);

                    if(temp_feldwert==0 || (temp_feldwert==1 && temp_feldwert2==1) ){
                        position[0]=position[0]+1;
                    }else break;


                    bewegungseinheiten--;
                } while(bewegungseinheiten>0);



            }break;

            //--------------------------------------------------------------------------------
            //--------------------------------------------------------------------------------
            //--------------------------------------------------------------------------------
            //--------------------------------------------------------------------------------


            case ""we"":{

                do{

                    //statt break auch einfach ien return machen, geht auch
                    if (position[0] == 0) break;

                //    System.out.println(""Wert position0 -1:   ""+(position[0]-1)+"" Wert postion1: ""+(position[1]));

                    int temp_feldwert = feld[position[0]-1][(position[1])];

               //     System.out.println(""Wert temp_feld: ""+temp_feldwert);


                    int posplus2=position[0]-2;
                    if(posplus2<=0) posplus2=0;
                    int temp_feldwert2 = feld[posplus2][(position[1])];

                   // System.out.println(""Wert temp_feld2: ""+temp_feldwert2);

                    int posplus3=position[1]-1;
                    if(posplus3<=0) posplus3=0;
                    int temp_feldwert3 = feld[position[0]-1][posplus3];

                   // System.out.println(""Wert temp_feld3: ""+temp_feldwert3);


                    boolean temp1 =temp_feldwert==0;
                    boolean temp2 =(temp_feldwert==1 && temp_feldwert2==1);
                    boolean temp3 =temp_feldwert2==0;
                    boolean temp4=(temp_feldwert==1&&temp_feldwert3==1);

                    if((temp1 || temp2) || temp4 || temp3){
                        if(temp3 && temp4) {
                            position[0]=position[0]-1;
                            break;
                        }

                        position[0]=position[0]-1;
                    }else break;

                    bewegungseinheiten--;
                } while(bewegungseinheiten>0);

            }break;


            //--------------------------------------------------------------------------------
            //--------------------------------------------------------------------------------
            //--------------------------------------------------------------------------------
            //--------------------------------------------------------------------------------



            case ""so"":{

                do{

                    if (position[1] == 0) break;

           //         System.out.println(""Wert position0: ""+position[0]+"" Wert postion1 -1:  ""+(position[1]-1));

                    int temp_feldwert = feld[position[0]][(position[1]-1)];

                  //  System.out.println(""Wert temp_feld: ""+temp_feldwert);

                    if(temp_feldwert==0){
                        position[1]=position[1]-1;
                    }else break;

                    bewegungseinheiten--;
                } while(bewegungseinheiten>0);

            }break;


            default:{
                System.out.println(""Keine richtige Richtung zum richten, \ndamit ist das Richten der Richtung nicht möglich"");
            }break;

        }
        return (""(""+position[0]+"",""+position[1]+"")"");
    }



    public void felden(){

        for (int x = 0; x < achseY; x++) {
            for (int y = 0; y < achseX; y++) {
                feld[x][y]=0;

                //Wand Zeilen nur Norden Süden abfragen als Horizontal
                //  wand1 = ""(1,6)-(5,6)"";
                // wand2 = ""(3,3)-(8,3)"";

                //Wand Spalten Nur Osten Westen abfragen also Vertikal
                // wand3 = ""(6,2)-(6,7)"";
                //  wand4 = ""(4,1)-(4,2)"";


                //Wand1
                if((y==6)&&((x>=1)&&(x<=5))) feld[x][y]=1;
                //Wande2
                if((y==3)&&((x>=3)&&(x<=8))) feld[x][y]=1;


                //Wand3
                if((x==6)&&((y>=2)&&(y<=7))) feld[x][y]=1;
                //Wand4
                if((x==4)&&((y>=1)&&(y<=2))) feld[x][y]=1;
            }
        }
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String moveTo(String moveCommandString);
}
",8535,256,51.422360248447205,151,0.1875,0.0703125,0.0078125,0.00390625,0.91796875,0.0,0.29296875,0.0703125,True,False,False,False,False,False,2,0.01171875,0.0234375,0.078125,0.00390625,0.484375,0.03515625,0.0,7.588235294117647,18,48.666666666666664,93
student104,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Dot
{
    private Field here;

    public Dot(Field f)
    {
        here=f;
    }

    public Field getHere() {
        return here;
    }

    public void setHere(Field here) {
        this.here = here;
    }
}

package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements GoAble
{
    private Dot dot;
    private Field[][] field;
    private Wall[] walls;

    public Exercise0()
    {
        walls=new Wall[8];
        walls[0]=new Wall(3,0,3,2);
        walls[1]=new Wall(0,2,2,2);
        walls[2]=new Wall(1,3,9,3);
        walls[3]=new Wall(9,3,9,7);
        walls[4]=new Wall(0,0,11,0);
        walls[5]=new Wall(0,0,0,8);
        walls[6]=new Wall(11,0,11,8);
        walls[7]=new Wall(0,8,11,8);

        field=new Field[11][8];
        for (int a=0; a<11; a++)
        {
            for (int b=0; b<8; b++)
            {
                field[a][b]=new Field(a,b);
            }
        }

        for (Wall w:walls)
        {
            if(w.getStartY()==w.getEndY())
            {
                System.out.println(""Horizontal wall"");
                for (int i = w.getStartX(); i < w.getEndX(); i++)
                {
                    if(w.getStartY()!=8)
                    {
                        field[i][w.getStartY()].setWalls(true, 0);
                        System.out.println(""Field ""+i+""/""+w.getStartY()+"" marked with upper wall"");
                    }
                    if(w.getStartY()-1!=-1)
                    {
                        field[i][w.getStartY()-1].setWalls(true, 2);
                        System.out.println(""Field ""+i+""/""+(w.getStartY()-1)+"" marked with lower wall"");
                    }
                }
            }
            else
            {
                System.out.println(""Vertical wall"");
                for (int i = w.getStartY(); i < w.getEndY(); i++)
                {
                    if(w.getStartX()!=11)
                    {
                        field[w.getStartX()][i].setWalls(true, 3);
                        System.out.println(""Field ""+w.getStartX()+""/""+i+"" marked with left wall"");
                    }
                    if(w.getStartX()>0)
                    {
                        field[w.getStartX()-1][i].setWalls(true, 1);
                        System.out.println(""Field ""+(w.getStartX()-1)+""/""+i+"" marked with right wall"");
                    }
                }
            }
        }
        dot=new Dot(field[1][1]);
    }

    public void step(String dir)
    {
        System.out.println(""Dot at ""+dot.getHere().getX()+""/""+dot.getHere().getY());
        if (!dot.getHere().getWall(dir))
        {
            System.out.println(""No obstacle at ""+dir);
            switch (dir)
            {
                case ""no"":
                    System.out.println(""Moving no now."");
                    dot.setHere(field[dot.getHere().getX()][dot.getHere().getY()-1]);
                    break;
                case ""ea"":
                    System.out.println(""Moving ea now."");
                    dot.setHere(field[dot.getHere().getX()+1][dot.getHere().getY()]);
                    break;
                case ""so"":
                    System.out.println(""Moving so now."");
                    dot.setHere(field[dot.getHere().getX()][dot.getHere().getY()+1]);
                    break;
                case ""we"":
                    System.out.println(""Moving we now."");
                    dot.setHere(field[dot.getHere().getX()-1][dot.getHere().getY()]);
                    break;
            }
            System.out.println(""Dot at ""+dot.getHere().getX()+""/""+dot.getHere().getY());
        }
        else
        {
            System.out.println(""Obstacle detected at ""+dir+"". Not moving."");
        }
    }


    @Override
    public String go(String goCommandString) {
        String s = goCommandString.substring(1, goCommandString.length() - 1);
        String[] input = s.split("","");

        String dir = input[0];
        int steps = Integer.parseInt(input[1]);

        for (int i = 0; i < steps; i++)
        {
            step(dir);
        }

        System.out.println(""Dot finally at ""+dot.getHere().getX()+""/""+dot.getHere().getY());
        int x=dot.getHere().getX();
        int flipY=7-dot.getHere().getY();
        System.out.println(""Position converted to ""+x+""/""+flipY);

        return ""("" + x + "","" + flipY + "")"" ;
    }
}

package thkoeln.st.st2praktikum.exercise;

public class Field
{
    private boolean obstacle;
    private boolean[] walls;
    private int x;
    private int y;

    public Field(int a, int b)
    {
        x=a;
        y=b;
        obstacle = false;

        walls=new boolean[4];

        walls[0]=false;
        walls[1]=false;
        walls[2]=false;
        walls[3]=false;

    }

    public boolean isObstacle() {
        return obstacle;
    }

    public void setObstacle(boolean obstacle) {
        this.obstacle = obstacle;
    }

    public boolean getWall(String dir) {
        switch (dir)
        {
            case ""no"":
                return walls[0];
            case ""ea"":
                return walls[1];
            case ""so"":
                return walls[2];
            case ""we"":
                return walls[3];
            default:
                return true;
        }
    }

    public void setWalls(boolean state, int dir) {
        walls[dir]=state;
        if (state=true)
        {
            obstacle=true;
        }
        //if state false check for other walls
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String go(String goCommandString);
}

package thkoeln.st.st2praktikum.exercise;

public class Wall
{
    private int startX;
    private int startY;
    private int endX;
    private int endY;

    public Wall(int a, int b, int c, int d)
    {
        startX=a;
        startY=b;
        endX=c;
        endY=d;
    }

    public int getStartX() {
        return startX;
    }

    public int getStartY() {
        return startY;
    }

    public int getEndX() {
        return endX;
    }

    public int getEndY() {
        return endY;
    }
}
",6270,250,28.262910798122064,103,0.004,0.032,0.028,0.008,0.38,0.0,0.144,0.064,True,False,False,False,False,False,5,0.06,0.048,0.024,0.016,0.392,0.324,0.0,3.0689655172413794,8,36.0,36
student105,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Barrier {

    Point p1;
    Point p2;
    Direction direction;

    public Barrier(Point p1, Point p2) {
        if (p1.x == p2.x) {
            this.direction = Direction.NORTH;
        } else {
            this.direction = Direction.EAST;
        }
        this.p1 = p1;
        this.p2 = p2;
    }

    public boolean collides(Command c) {
        Direction moveDirection = c.direction;

        // Cannot collide if moving parallel to the barrier
        if (isParallel(direction, moveDirection)) {
            return false;
        }

        switch (moveDirection) {
            case EAST: if (c.to.x == p1.x && c.to.y >= p1.y && c.to.y < p2.y) return true;           break;
            case WEST: if (c.from.x == p1.x && c.to.y >= p1.y && c.to.y < p2.y) return true;         break;
            case NORTH: if (c.to.y == p1.y && c.to.x >= p1.x && c.to.x < p2.x) return true;          break;
            case SOUTH: if (c.from.y == p1.y && c.to.x >= p1.x && c.to.x < p2.x) return true;        break;
        }

        return false;
    }

    private boolean isParallel(Direction barrierDirection, Direction moveDirection) {
        if (barrierDirection == Direction.EAST && ( moveDirection == Direction.EAST ||moveDirection == Direction.WEST))
            return true;
        else return barrierDirection == Direction.NORTH && (moveDirection == Direction.NORTH || moveDirection == Direction.SOUTH);
    }

}

package thkoeln.st.st2praktikum.exercise;

public class Command {
    Point from;
    Point to;
    Direction direction;

    public Command(Point from, Point to) {
        this.from = from;
        this.to = to;

        if (to.x > from.x) {
            direction = Direction.EAST;
        } else if (to.x < from.x) {
            direction = Direction.WEST;
        } else if (to.y > from.y) {
            direction = Direction.NORTH;
        } else if (to.y < from.y) {
            direction = Direction.SOUTH;
        } else {
            throw new RuntimeException(""Not a valid move"");
        }
    }
}

package thkoeln.st.st2praktikum.exercise;

public enum Direction {
    NORTH, EAST, SOUTH, WEST
}

package thkoeln.st.st2praktikum.exercise;

import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Exercise0 implements Moveable {

    final int DECK_WIDTH = 11;
    final int DECK_HEIGHT = 7;

    ArrayList<Barrier> barriers = new ArrayList<>();

    Point position;

    public Exercise0() {
        barriers.add(new Barrier(new Point(1, 4), new Point(8, 4)));
        barriers.add(new Barrier(new Point(4, 3), new Point(7, 3)));
        barriers.add(new Barrier(new Point(3, 0), new Point(3, 3)));
        barriers.add(new Barrier(new Point(7, 0), new Point(7, 2)));
        position = new Point(3, 0);
        System.out.println(""reset position"");
    }

    @Override
    public String moveTo(String moveCommandString) {
        Command command = parseCommandString(moveCommandString);
        ArrayList<Command> commands = getSingleSteps(command);
        Point endPos = null;
        for (Command c : commands) {
            for (Barrier b : barriers) {
                if (b.collides(c)) {
                    endPos = c.from;
                }
            }
        }
        if (endPos == null) endPos = command.to;
        position = endPos;
        return endPos.toString();
    }

    private Command parseCommandString(String moveCommandString) {
        Pattern p = Pattern.compile(""\\[([a-z]{2}),([\\d]*)\\]"");
        Matcher matcher = p.matcher(moveCommandString);

        Command c;
        if (matcher.matches()) {
            String directionString = matcher.group(1).toLowerCase();
            int length = Integer.parseInt(matcher.group(2));

            if (directionString.startsWith(""n"")) {
                c = new Command(position, new Point(position.x, position.y + length));
            } else if (directionString.startsWith(""s"")) {
                c = new Command(position, new Point(position.x, position.y - length));
            } else if (directionString.startsWith(""e"")) {
                c = new Command(position, new Point(position.x + length, position.y));
            } else if (directionString.startsWith(""w"")) {
                c = new Command(position, new Point(position.x - length, position.y));
            } else {
                throw new RuntimeException(""Could not parse command direction: "" + directionString);
            }
        } else {
            throw new RuntimeException(""Could not parse commandString: "" + moveCommandString);
        }

        if (c.to.x > DECK_WIDTH) {
            c.to.x = DECK_WIDTH;
        } else if (c.to.x < 0) {
            c.to.x = 0;
        }
        if (c.to.y > DECK_HEIGHT) {
            c.to.y = DECK_HEIGHT;
        } else if (c.to.y < 0) {
            c.to.y = 0;
        }

        return c;
    }

    private ArrayList<Command> getSingleSteps(Command c) {
        ArrayList<Command> commands = new ArrayList<>(11);
        switch (c.direction) {
            case NORTH:
                for (int i = c.from.y; i < c.to.y; i++) {
                    commands.add(new Command(new Point(c.from.x, i), new Point(c.to.x, i + 1)));
                }
                break;
            case SOUTH:
                for (int i = c.from.y; i >= c.to.y; i--) {
                    commands.add(new Command(new Point(c.from.x, i), new Point(c.from.x, i - 1)));
                }
                break;
            case EAST:
                for (int i = c.from.x; i < c.to.x; i++) {
                    commands.add(new Command(new Point(i, c.from.y), new Point(i + 1, c.to.y)));
                }
                break;
            case WEST:
                for (int i = c.from.x; i >= c.to.x; i--) {
                    commands.add(new Command(new Point(i, c.from.y), new Point(i - 1, c.from.y)));
                }
                break;
        }
        return commands;
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String moveTo(String moveCommandString);
}

package thkoeln.st.st2praktikum.exercise;

public class Point {
    public int x;
    public int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    @Override
    public String toString() {
        return ""("" + x + "","" + y + "")"";
    }
}
",6432,205,36.629411764705885,130,0.004878048780487805,0.11219512195121951,0.02926829268292683,0.00975609756097561,0.3121951219512195,0.014634146341463415,0.17073170731707318,0.004878048780487805,False,False,False,True,True,False,6,0.03414634146341464,0.05853658536585366,0.04878048780487805,0.01951219512195122,0.775609756097561,0.12195121951219512,0.01951219512195122,5.487179487179487,17,48.0,48
student106,student,,,"package thkoeln.st.st2praktikum.exercise;

public enum Direction {
    no,ea,so,we;
}

package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Moveable {
    Grid myMap= new Grid();

    @Override
    public String move(String moveCommandString) {
       int lastX = myMap.getX();
       int lastY = myMap.getY();

        //check format [Direction,number]
        if (checkFormatMoveComandString(moveCommandString)) {
            //Seperate the parts of the command into the Direction and the number of tiles to move
            String[] commands = moveCommandString.replace(""["", """").replace(""]"", """").split("","");

            //turn the Sting into a Direction
            Direction direc = Direction.valueOf(commands[0]);

            int number = Integer.parseInt(commands[1]);

            //now move accordingly:
            switch (direc){
                case no: myMap.setY(myMap.getY()+number); break;
                case ea: myMap.setX(myMap.getX()+number); break;
                case so: myMap.setY(myMap.getY()-number); break;
                case we: myMap.setX(myMap.getX()-number); break;
            }

            myMap.checkForWallsInTheWay(direc,lastX,lastY);
        }
        return myMap.getPosition();
    }

    private boolean checkFormatMoveComandString (String moveCommandString){
        // TODO: checkFormatMoveComandString
        return true;
    }
}

package thkoeln.st.st2praktikum.exercise;

public class Grid {
    //coordinates
    private int x=1;
    private int y=6;

    //boardes of the field
    final int maxX=11;
    final int maxY=8;

    //contains a list with walls. A wall is a list of coordinats
    // Von welcher Himmerlrichtung laufe ich drüber?
    // Nachher standort berrechnen und dann vgl. ob eine Mauer dazwischen ist.
    final int[] wallHorizontalSo1 = {0,1,5}; //von x bis x bei y
    final int[] wallHorizontalNo1 = {0,1,6}; //von x bis x bei y
    final int[] wallHorizontalSo2 = {1,8,4}; //von x bis x bei y
    final int[] wallHorizontalNo2 = {1,8,5}; //von x bis x bei y

    final int[] wallVerticalEa1 = {1,4,9}; //von y bis y bei x
    final int[] wallVerticalWe1 = {1,4,8}; //von y bis y bei x
    final int[] wallVerticalEa2 = {6,7,3}; //von y bis y bei x
    final int[] wallVerticalWe2 = {6,7,2}; //von y bis y bei x

    public void setX(int x) {
        if (x<0) this.x=0;
        else if (x>=maxX) this.x=10;
        else this.x = x;
    }

    public void setY(int y) {
        if (y<0) this.y=0;
        else if (y>=maxY) this.y=7;
        else this.y = y;
    }

    public int getX() {
        return this.x;
    }

    public int getY() {
        return this.y;
    }

    public void checkForWallsInTheWay(Direction direc, int lastX, int lastY){
            switch (direc){
                case no:
                    //check if X could hit a wall
                    if (this.x>=wallHorizontalNo1[0] && this.x<=wallHorizontalNo1[1]){
                        //if Yes check if wall is between old and new Y
                        if (lastY<wallHorizontalNo1[2] && this.y>=wallHorizontalNo1[2]){
                            //if Yes correct position
                            setY(wallHorizontalNo1[2]-1);
                        }
                    }
                    //check if X could hit a wall
                    if (this.x>=wallHorizontalNo2[0] && this.x<=wallHorizontalNo2[1]){
                        //if Yes check if wall is between old and new Y
                        if (lastY<wallHorizontalNo2[2] && this.y>=wallHorizontalNo2[2]){
                            //if Yes correct position
                            setY(wallHorizontalNo2[2]-1);
                        }
                    }
                case ea:
                    //check if Y could hit a wall
                    if (this.y>=wallVerticalEa1[0] && this.y<=wallVerticalEa1[1]){
                        //if Yes check if wall is between old and new X
                        if (lastX<wallVerticalEa1[2] && this.x>=wallVerticalEa1[2]){
                            //if Yes correct position
                            setX(wallVerticalEa1[2]+1);
                        }
                    }
                    //check if Y could hit a wall
                    if (this.y>=wallVerticalEa2[0] && this.y<=wallVerticalEa2[1]){
                        //if Yes check if wall is between old and new X
                        if (lastX<wallVerticalEa2[2] && this.x>=wallVerticalEa2[2]){
                            //if Yes correct position
                            setX(wallVerticalEa2[2]-1);
                        }
                    }
                case so:
                    //check if X could hit a wall
                    if (this.x>=wallHorizontalSo1[0] && this.x<=wallHorizontalSo1[1]){
                        //if Yes check if wall is between old and new Y
                        if (this.y<=wallHorizontalSo1[2] && lastY>wallHorizontalSo1[2]){
                            //if Yes correct position
                            setY(wallHorizontalSo1[2]+1);
                        }
                    }
                    //check if X could hit a wall
                    if (this.x>=wallHorizontalSo2[0] && this.x<=wallHorizontalSo2[1]){
                        //if Yes check if wall is between old and new Y
                        if (this.y<=wallHorizontalSo2[2] && lastY>wallHorizontalSo2[2]){
                            //if Yes correct position
                            setY(wallHorizontalSo2[2]+1);
                        }
                    }
                case we:
                    //check if Y could hit a wall
                    if (this.y>=wallVerticalWe1[0] && this.y<=wallVerticalWe1[1]){
                        //if Yes check if wall is between old and new X
                        if (this.x<=wallVerticalWe1[2] && lastX>wallVerticalWe1[2]){
                            //if Yes correct position
                            setX(wallVerticalWe1[2]+1);
                        }
                    }
                    //check if Y could hit a wall
                    if (this.y>=wallVerticalWe2[0] && this.y<=wallVerticalWe2[1]){
                        //if Yes check if wall is between old and new X
                        if (this.x<=wallVerticalWe2[2] && lastX>wallVerticalWe2[2]){
                            //if Yes correct position
                            setX(wallVerticalWe2[2]+1);
                        }
                    }

            }
    }

    public String getPosition() {
        return (""("" + x + "","" + y + "")"");
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String move(String moveCommandString);
}
",6725,173,43.97315436241611,98,0.24277456647398843,0.3063583815028902,0.005780346820809248,0.011560693641618497,0.8034682080924855,0.0,0.13872832369942195,0.0,False,False,False,False,False,False,4,0.05202312138728324,0.07514450867052024,0.028901734104046242,0.011560693641618497,0.5895953757225434,0.15028901734104047,0.0,9.476190476190476,17,30.976190476190474,84
student107,student,,,"package thkoeln.st.st2praktikum.exercise;

import java.util.ArrayList;
import java.util.List;

/**
 * TODO Basic Object ✔
 * TODO Command Parser ✔
 * TODO Movement Detection ✔
 * TODO Apply Movement ✔
 * TODO Collision detection ✔
 *
 * TODO OPTIONAL STUFF
 *
**/

public class Exercise0 implements Moveable {


    private Coordinate robotcoordinate;
    private List<Obstacle> obstacles = new ArrayList<Obstacle>();
    private int areax;
    private int areay;



    public Exercise0() {
        //START POINT
        this.robotcoordinate = new Coordinate(7,7);
        //DIMENSION | Obstacle
        this.areax = 11;
        this.areay = 8;

        this.genobstacle(new Coordinate(2,6) , new Command(""ea"", 5));
        this.genobstacle(new Coordinate(2,1) , new Command(""no"", 5));
        this.genobstacle(new Coordinate(2,1) , new Command(""ea"", 8));
        this.genobstacle(new Coordinate(10,1) , new Command(""no"", 7));
    }

    public Exercise0(int x , int y){
    this();
    this.robotcoordinate = new Coordinate(x,y);
    }

    public void genobstacle(Coordinate cord){
        this.obstacles.add(new Obstacle(new Command(""static"" , 0 ) , cord));

    }

    public void genobstacle(Coordinate cordstart , Command command ){
        Coordinate tmpCoordinate = new Coordinate(cordstart.getX(), cordstart.getY());

            this.obstacles.add(new Obstacle(command , cordstart));
        }


    //COMMAND : [DIRECTION,DISTANCE]
    @Override
    public String move(String moveCommandString) {

        Command command = this.commandparser(moveCommandString);
        boolean breakpoint = false;
        Coordinate tmpCoordinate = new Coordinate(robotcoordinate.getX(), robotcoordinate.getY());
        Coordinate saved = new Coordinate(tmpCoordinate.getX(), tmpCoordinate.getY());;
        String commanddir = command.getDirection();
        for(int i = command.getDistance(); i>= 0 & !breakpoint ; i-- ){
            saved.setX(tmpCoordinate.getX());
            saved.setY(tmpCoordinate.getY());
            switch (command.getDirection()){
                case ""no"":
                    tmpCoordinate.setY(tmpCoordinate.getY() + 1);
                    break;
                case ""ea"":
                    tmpCoordinate.setX(tmpCoordinate.getX() + 1);
                    break;
                case ""so"":
                    tmpCoordinate.setY(tmpCoordinate.getY() - 1);
                    break;
                case ""we"":
                    tmpCoordinate.setX(tmpCoordinate.getX() - 1);
                    break;
            }
            //Check if it touches border | only when coordinate is in the area
            if(tmpCoordinate.getX() >= 0 & tmpCoordinate.getX() < this.areax & tmpCoordinate.getY() >= 0 & tmpCoordinate.getY() < this.areay){
                //Check if Coordinate is not colliding with any obstacle

                for (Obstacle c: this.obstacles
                     ) {
                    //horizontal border | moving down (south) |
                    if((c.command.getDirection().equals(""we"") || c.command.getDirection().equals(""ea"")) && (commanddir.equals(""so"") || commanddir.equals(""no"")) ){
//                        System.out.println(""    Checking WE | EA"");
                        for(int j = c.command.getDistance(); j >= 0 ; j--){
                            //west movement
                            if(c.command.getDirection().equals(""we"")){
                                //not startpoint
//                                System.out.println(""        Checking WE"");
                                if(j != 0){
                                    if(c.anchor.getX() - j == tmpCoordinate.getX() && ((c.anchor.getY() == tmpCoordinate.getY() && commanddir.equals(""no"")) || (c.anchor.getY()-1 == tmpCoordinate.getY() && commanddir.equals(""so""))) ){
//                                        System.out.println(""            Collision"");
                                        breakpoint = true;
                                    }
                                }
                            }
                            //east movement
                            else if(c.command.getDirection().equals(""ea"")){
                                //not endpoint
//                                System.out.println(""        Checking EA"");
                                if(j != c.command.getDistance()){
                                    if(c.anchor.getX() + j == tmpCoordinate.getX() && ((c.anchor.getY() == tmpCoordinate.getY() && commanddir.equals(""no"")) || (c.anchor.getY()-1 == tmpCoordinate.getY() && commanddir.equals(""so"")))){
//                                        System.out.println(""            Collision"");
                                        breakpoint = true;
                                    }
                                }
                            }
                        }
                    }else if((c.command.getDirection().equals(""no"") || c.command.getDirection().equals(""so"")) && (commanddir.equals(""ea"") || commanddir.equals(""we"")) ){

//                        System.out.println(""    Checking NO | SO"");
                        for(int j = c.command.getDistance(); j >= 0 ; j--){

                            //no movement
                            if(c.command.getDirection().equals(""so"")){
                                //not startpoint
//                                System.out.println(""        Checking SO"");
                                if(j != 0){
                                    if(c.anchor.getY() - j == tmpCoordinate.getY() && ((c.anchor.getX()  == tmpCoordinate.getX() && commanddir.equals(""ea"")) || (c.anchor.getX()-1 == tmpCoordinate.getX() && commanddir.equals(""we""))) ){
                                        breakpoint = true;
                                    }
                                }
                            }
                            //so movement
                            else if(c.command.getDirection().equals(""no"")){
                                //not endpoint
//                                System.out.println(""        Checking NO"");
                                if(j != c.command.getDistance()){
                                    if(c.anchor.getY() + j == tmpCoordinate.getY() && ((c.anchor.getX() == tmpCoordinate.getX() && commanddir.equals(""ea"")) || (c.anchor.getX()-1 == tmpCoordinate.getX() && commanddir.equals(""we"")))){
                                        breakpoint = true;
                                    }
                                }
                            }
                        }
                    }

                }
            }else {
//                System.out.println(""    border collision"");
                breakpoint = true;

            }

        }

    this.robotcoordinate.setX(saved.getX());
    this.robotcoordinate.setY(saved.getY());
        return ""("" + this.robotcoordinate.getX() + "","" +this.robotcoordinate.getY() + "")""
;
        //throw new UnsupportedOperationException();


    }

    private Command commandparser(String commandstring) {

        String direction;
        int distance;

        String[] values= commandstring.replace(""["","""").replace(""]"","""").split("","");
        System.out.println(values[0]);
        System.out.println(values[1]);
        direction = values[0];
        distance = Integer.parseInt(values[1]);

        return new Command(direction,distance);
    }


    private class Obstacle{

        private Command command;
        private Coordinate anchor;

        Obstacle(){
            this.command = null;
            this.command = null;
        }

        Obstacle(Command command , Coordinate anchor){
            this.command = command;
            this.anchor = anchor;
        }

        public Coordinate endcord(){
            switch (this.command.getDirection()){
                case ""static"":
                    return this.anchor;
                case ""no"":
                    return new Coordinate(this.anchor.getX(),+this.anchor.getY()+this.command.distance);
                case ""ea"":
                    return new Coordinate(this.anchor.getX()+this.command.distance,this.anchor.getY());

                case ""we"":
                    return new Coordinate(this.anchor.getX()-this.command.distance,this.anchor.getY());

                case ""so"":
                    return new Coordinate(this.anchor.getX(),+this.anchor.getY()-this.command.distance);
                default:
                    return null;
            }
        }

        public Command getCommand() {
            return command;
        }

        public Coordinate getAnchor() {
            return anchor;
        }

        public void setAnchor(Coordinate anchor) {
            this.anchor = anchor;
        }

        public void setCommand(Command command) {
            this.command = command;
        }
    }





    private class Command {
        private String direction;
        private int distance;

        public int getDistance() {
            return distance;
        }

        public String getDirection() {
            return direction;
        }

        public Command(){

        }
        public Command(String direction , int distance){
            this.direction = direction;
            this.distance = distance;
        }
    }



    private class Line {

        private Coordinate start;
        private Coordinate end;
        public Line(){

        }

        public Line(Coordinate start , Coordinate end){
            this.start = start;
            this.end = end;
        }

        public Coordinate getStart() {
            return this.start;
        }

        public Coordinate getEnd() {
            return this.end;
        }

        @Override

        public String toString() {
            return this.start.toString() +""-""+this.end.toString();
        }



    }


    private class Coordinate {
        private int x;
        private int y;

        public Coordinate(){
            this.x = 0;
            this.y = 0;
        }

        public Coordinate(int x , int y){
            this.x = x;
            this.y = y;
        }

        public int getX() {
            return this.x;
        }
        public int getY() {
            return this.y;
        }

        public void setX(int x) {
            this.x = x;
        }

        public void setY(int y) {
            this.y = y;
        }

        @Override
        public String toString() {
            return ""("" + x + "","" + y + "")"";
        }
    }


    public void test(){

    }

}

package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String move(String moveCommandString);
}
",10690,333,40.615686274509805,234,0.07507507507507508,0.05105105105105105,0.012012012012012012,0.006006006006006006,0.13513513513513514,0.003003003003003003,0.2012012012012012,0.03303303303303303,True,True,False,False,False,False,2,0.06306306306306306,0.036036036036036036,0.02702702702702703,0.015015015015015015,0.3153153153153153,0.3333333333333333,0.006006006006006006,6.421052631578948,17,26.41176470588235,64
student108,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Moveable {
    int[] position;
    Field field;
    public Exercise0() {
        this.position = new int[]{8,3};
        this.field = new Field(12, 9, 4);
        field.addWall(new Wall(3, 1, 3, 7));
        field.addWall(new Wall(6, 1, 9, 1));
        field.addWall(new Wall(5, 2, 5, 5));
        field.addWall(new Wall(6, 4, 9, 4));
    }

    public void moveViaDirection(String direction, int length) {
        switch(direction) {
            case ""no"":
                moveInSteps(length, 1, 0, 1);
                break;
            case ""ea"":
                moveInSteps(length, 1, 1, 0);
                break;
            case ""so"":
                moveInSteps(length, -1, 0, -1);
                break;
            case ""we"":
                moveInSteps(length, -1, -1, 0);
                break;
            default:
        }
    }

    public boolean moveInSteps(int stepLength, int toAdd, int stepToX, int stepToY) {
        int positionIndex = 0;
        if (stepToY != 0) { positionIndex = 1; }
        if (stepLength < 0) {toAdd = toAdd * -1; }
        for (int i = 0; i < Math.abs(stepLength); i++) {
            if (field.isStepClear(this.position[0], this.position[1], this.position[0] + stepToX, this.position[1] + stepToY)) {
                this.position[positionIndex] += toAdd;
            } else {
                return false;
            }
        }
        return true;
    }

    public String[] splitToArgs(String moveCommandString) {
        String s = moveCommandString.substring(1, moveCommandString.length()-1);
        String[] arr = s.split("","");
        return arr;
    }

    @Override
    public String move(String moveCommandString) {
        String[] arr = splitToArgs(moveCommandString);
        moveViaDirection(arr[0], Integer.parseInt(arr[1]));
        return ""("" + this.position[0] + "","" + this.position[1] + "")"";
    }
}

package thkoeln.st.st2praktikum.exercise;

public class Field {
    Wall[] walls;
    int numWallsInserted = 0;
    int sizeX;
    int sizeY;

    public Field(int sizeX, int sizeY, int countWalls) {
        walls = new Wall[countWalls];
        this.sizeX = sizeX;
        this.sizeY = sizeY;
    }

    public void addWall(Wall wall) {
        walls[numWallsInserted] = wall;
        numWallsInserted++;
    }
    public Boolean isTargetWithinFieldLimits(int targetX, int targetY) {
        if (targetX > this.sizeX || targetX < 0 || targetY > this.sizeY || targetY < 0) {
            return false;
        } else {
            return true;
        }
    }

    public Boolean isStepClear(int stepStartX, int stepStartY, int stepEndX, int stepEndY) {
        if (!this.isTargetWithinFieldLimits(stepEndX, stepEndY)) { return false; }
        for (int i=0; i<walls.length; i++) {
            if (walls[i].isStepBlocked(stepStartX, stepStartY, stepEndX, stepEndY)) {
                return false;
            }
        }
        return true;
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String move(String moveCommandString);
}

package thkoeln.st.st2praktikum.exercise;

public class Wall {
    int startX;
    int startY;
    int endX;
    int endY;
    int length;
    int[][] forbiddenSteps;

    public Wall(int startX, int startY, int endX, int endY) {
        //Sicherstellen dass der startwert immer der kleinere Wert ist
        if (startX > endX) {
            int tempX = startX;
            startX = endX;
            endX = tempX;
        }
        if (startY > endY) {
            int tempY = startY;
            startY = endY;
            endY = tempY;
        }
        // Startwerte setzen
        this.startX = startX;
        this.startY = startY;
        this.endX = endX;
        this.endY = endY;
        //Potentielle Verbotene Schritte speichern
        if (startX - endX != 0) {
            this.length = endX-startX;
            addForbiddenStep(1, 0, 1, 0, 0, 1);
        } else {
            this.length = endY-startY;
            addForbiddenStep(0, 1, 0, 1, 1, 0);
        }
    }

    private void addForbiddenStep(int startXMultiplier, int startYMultiplier, int endXMultiplier, int endYMultiplier, int endXAddition, int endYAddition) {
        forbiddenSteps = new int[this.length][];
        for (int i=0; i<forbiddenSteps.length; i++) {
            forbiddenSteps[i] = new int[4];
            forbiddenSteps[i][0] = startX + (startXMultiplier * i);
            forbiddenSteps[i][1] = startY + (startYMultiplier * i);
            forbiddenSteps[i][2] = startX + endXAddition + (endXMultiplier * i);
            forbiddenSteps[i][3] = startY + endYAddition + (endYMultiplier * i);
        }
    }

    public Boolean isStepBlocked(int stepStartX, int stepStartY, int stepEndX, int stepEndY) {
        for ( int i=0; i<forbiddenSteps.length; i++ ) {
            if (forbiddenSteps[i][0] == stepStartX && forbiddenSteps[i][1] == stepStartY && forbiddenSteps[i][2] == stepEndX && forbiddenSteps[i][3] == stepEndY ||
                    forbiddenSteps[i][0] == stepEndX && forbiddenSteps[i][1] == stepEndY && forbiddenSteps[i][2] == stepStartX && forbiddenSteps[i][3] == stepStartY) {
                return true;
            }
        }
        return false;
    }
}
",5282,161,35.5625,167,0.018633540372670808,0.062111801242236024,0.13043478260869565,0.006211180124223602,0.546583850931677,0.0,0.10559006211180125,0.0,False,False,False,False,False,False,4,0.062111801242236024,0.07453416149068323,0.037267080745341616,0.018633540372670808,0.8881987577639752,0.12422360248447205,0.0,8.088888888888889,17,39.0,60
student109,student,,,"package thkoeln.st.st2praktikum.exercise;

import javax.sound.midi.SysexMessage;

public class Exercise0 implements GoAble {

    public String start = ""(1,7)"";
    public String weiter = null;

    @Override
    public String go(String goCommandString) {
        String startf[] = null;
        if (weiter == null) {
            startf = start.split("","");
            startf[0] = startf[0].replace(""("", "" "").trim();
            startf[1] = startf[1].replace("")"", "" "").trim();
        }else {
            startf = weiter.split("","");
            startf[0] = startf[0].replace(""("", "" "").trim();
            startf[1] = startf[1].replace("")"", "" "").trim();
        }


        boolean feldno[][] = new boolean[12][9];
        boolean feldea[][] = new boolean[12][9];
        boolean feldso[][] = new boolean[12][9];
        boolean feldwe[][] = new boolean[12][9];

        feldea[2][8] = true;feldwe[0][0] = true;feldno[0][8] = true;feldso[0][0] = true;
        feldea[2][7] = true;feldwe[0][1] = true;feldno[1][8] = true;feldso[1][0] = true;
        feldea[2][6] = true;feldwe[0][2] = true;feldno[2][8] = true;feldso[2][0] = true;
        feldea[2][5] = true;feldwe[0][3] = true;feldno[3][8] = true;feldso[3][0] = true;
        feldea[2][4] = true;feldwe[0][4] = true;feldno[4][8] = true;feldso[4][0] = true;
        feldea[2][3] = true;feldwe[0][5] = true;feldno[5][8] = true;feldso[5][0] = true;
                            feldwe[0][6] = true;feldno[6][8] = true;feldso[6][0] = true;
        feldea[4][1] = true;feldwe[0][7] = true;feldno[7][8] = true;feldso[7][0] = true;
        feldea[4][0] = true;feldwe[0][8] = true;feldno[8][8] = true;feldso[8][0] = true;
        feldea[5][1] = true;feldwe[3][8] = true;feldno[9][8] = true;feldso[9][0] = true;
        feldea[5][0] = true;feldwe[3][8] = true;feldno[10][8] = true;feldso[10][0] = true;
        feldea[5][2] = true;feldwe[3][8] = true;feldno[11][8] = true;feldso[11][0] = true;
        feldea[5][3] = true;feldwe[3][8] = true;feldno[3][2] = true;feldso[3][3] = true;
        feldea[11][0] = true;feldwe[3][8] = true;feldno[4][2] = true;feldso[3][4] = true;
        feldea[11][1] = true;feldwe[3][7] = true;
        feldea[11][2] = true;feldwe[3][6] = true;
        feldea[11][3] = true;feldwe[3][5] = true;
        feldea[11][4] = true;feldwe[3][4] = true;
        feldea[11][5] = true;feldwe[3][3] = true;
        feldea[11][6] = true;feldwe[6][0] = true;
        feldea[11][7] = true;feldwe[6][1] = true;
        feldea[11][8] = true;feldwe[6][1] = true;
                             feldwe[7][0] = true;
                             feldwe[7][1] = true;
                             feldwe[7][2] = true;
                             feldwe[7][3] = true;




        String tmp[] = goCommandString.split("","");
        tmp[0] = tmp[0].replace(""["", "" "").trim();
        tmp[1] = tmp[1].replace(""]"", "" "").trim();

        int temps = Integer.parseInt(tmp[1]);
        int i = Integer.parseInt(startf[0]);
        int j = Integer.parseInt(startf[1]);


        while (true) {
            if (tmp[0].equals(""no"")) {
                if (temps >= 1 && j++ <= feldno[0].length && feldno[i][j] == false) {
                    temps--;
                }
                else {
                    break;
                }
            }
            if (tmp[0].equals(""ea"")) {
                if (temps >= 1 && i++ <= feldea.length  && feldea[i][j] == false) {
                    temps--;
                }
                else {
                    break;
                }
            }
            if (tmp[0].equals(""so"")) {
                if (temps > 0 && j-- > 0  && feldso[i][j] == false)  {
                    temps--;
                }
                else {
                    break;
                }
            }
            if (tmp[0].equals(""we"")) {

                if (temps > 0 && i-- > 0  && feldwe[i][j] == false) {
                    temps --;
                }
                else {
                    break;
                }
            }
        }
        weiter = ""(""+ String.valueOf(i) + "","" + String.valueOf(j) + "")"";
        return ""(""+ String.valueOf(i) + "","" + String.valueOf(j) + "")"";
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String go(String goCommandString);
}
",4288,112,43.95789473684211,90,0.0,0.08035714285714286,0.0,0.0,1.8392857142857142,0.0,0.11607142857142858,0.0,True,False,False,False,False,False,2,0.017857142857142856,0.017857142857142856,0.08035714285714286,0.008928571428571428,1.1517857142857142,0.23214285714285715,0.008928571428571428,4.7272727272727275,6,0.0,0
student11,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Moveable {

    //check if border is in direction, if not move one step in that direction
    //command is: ""[direction, steps]""
    //check if moving out of field, x,y != -1 & x <= 11, y <= 8
    int x = 4;
    int y = 0;
    int [][]borders = {{1,0,3},{0,0,4},{1,1,3},{0,1,4},{1,2,3},{0,2,4},{1,3,3},{0,3,4},{1,4,3},{0,4,4},{1,5,3},{0,5,4},{1,5,1},{1,6,2},{2,5,1},{2,6,2},{3,5,1},{3,6,2},{5,5,1},{5,6,2},{6,6,2},{6,5,1},{6,5,4},{7,5,3},{6,4,4},{7,4,3},{6,3,4},{7,3,3},{6,2,4},{7,2,3},{6,1,4},{7,1,3}};
    @Override
    public String moveTo(String moveCommandString) {
        String inuf = moveCommandString.replace(""["","""").replace(""]"","""");
        String[] in = inuf.split("","");
        String direction = in[0];
        int steps = Integer.parseInt(in[1]);
        for(int i = 0; i< steps; i++) {
            switch (direction) {
                case ""no"": {
                    // plus y
                    if(!borderInFront(x,y,""no"") && y+1 < 8){
                        y++;
                        break;
                    }
                    else{
                        System.out.println(""Border detected"");
                        break;
                    }
                }
                case ""ea"": {
                    // plus x
                    if(!borderInFront(x,y, ""ea"") && x+1 < 11){
                        x++;
                        break;
                    }
                    else{
                        System.out.println(""Border detected"");
                        break;
                    }
                }
                case ""so"": {
                    // minus y
                    if(!borderInFront(x,y, ""so"") && y-1 >= 0){
                        y--;
                        break;
                    }
                    else{
                        System.out.println(""Border detected"");
                        break;
                    }
                }
                case ""we"": {
                    // minus x
                    if(!borderInFront(x,y, ""we"") && x-1 >= 0){
                        x--;
                        break;
                    }
                    else{
                        System.out.println(""Border detected"");
                        break;
                    }
                }
                default:
                    System.out.println(""unsupported direction"");
            }
        }
        //throw new UnsupportedOperationException();
        return ""("" + x + "","" + y + "")"";

    }
    //FALSCH next coordinate, if it crosses a border return true
    //direction heading
    //current coordinate
    //declare inside and outside border
    public boolean borderInFront(int x, int y, String direction){
        //write contains method
        int dir = 0;
        switch(direction) {
            case ""no"": dir = 1; break;
            case ""so"": dir = 2; break;
            case ""we"": dir = 3; break;
            case ""ea"": dir = 4; break;
        }
        for(int i = 0; i < borders.length; i++){
            if(borders[i][0] == x && borders[i][1] == y && borders[i][2] == dir){
                    return true;
            }
        }
        return false;
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String moveTo(String moveCommandString);
}
",3386,97,35.75,280,0.13402061855670103,0.09278350515463918,0.020618556701030927,0.020618556701030927,1.2989690721649485,0.010309278350515464,0.05154639175257732,0.05154639175257732,False,False,False,False,False,False,2,0.030927835051546393,0.030927835051546393,0.05154639175257732,0.010309278350515464,0.422680412371134,0.13402061855670103,0.0,3.888888888888889,9,28.846153846153847,71
student110,student,,,"package thkoeln.st.st2praktikum.exercise;

import javax.persistence.criteria.CriteriaBuilder;
import java.util.ArrayList;

public class Exercise0 implements GoAble {
    public Integer x = 0;
    public Integer y=2;






    @Override
    public String goTo(String goCommandString) {


                String wandpunkt1 = ""3,0"";
                String wandpunkt2 = ""3,1"";
                String wandpunkt3 = ""3,2"";
                String wandpunkt4 = ""5,0"";
                String wandpunkt5 = ""5,1"";
                String wandpunkt6 = ""5,2"";
                String wandpunkt7= ""5,3"";
                String wandpunkt8 = ""7,9"";
                String wandpunkt9 = ""7,8"";
                String wandpunkt10 = ""7,7"";
                String wandpunkt11 = ""7,6"";
                String wandpunkt12 = ""5,5"";
                String wandpunkt13 = ""6,5"";



        ArrayList<String> wandpunkte = new ArrayList<>();
        wandpunkte.add(wandpunkt1);
        wandpunkte.add(wandpunkt2);
        wandpunkte.add(wandpunkt3);
        wandpunkte.add(wandpunkt4);
        wandpunkte.add(wandpunkt5);
        wandpunkte.add(wandpunkt6);
        wandpunkte.add(wandpunkt7);
        wandpunkte.add(wandpunkt8);
        wandpunkte.add(wandpunkt9);
        wandpunkte.add(wandpunkt10);
        wandpunkte.add(wandpunkt11);
        wandpunkte.add(wandpunkt12);
        wandpunkte.add(wandpunkt13);



        int moveAmmount;
        Integer c;
        String startString = String.format (""[%d,%d]"",x,y);
        String finalString;

        moveAmmount =Integer.parseInt(goCommandString.substring(4,5));





        if(goCommandString.contains(""no"")){


            for (int i = 0; i< wandpunkte.size(); i++){

                if (Integer.parseInt(wandpunkte.get(i).substring(2,3))>y && Integer.parseInt(wandpunkte.get(i).substring(2,3))<= (y+moveAmmount) && Integer.parseInt(wandpunkte.get(i).substring(0,1)) == x ){

                    y = Integer.parseInt(wandpunkte.get(i).substring(2,3))-1;
                    finalString = String.format(""(%d,%d)"",x,y);
                    return finalString;


                }

            }

            y = y + moveAmmount;

            if (y<0) y=0;
            if (y>8)y=8;
            finalString = String.format(""(%d,%d)"",x,y);
            return finalString;
        }
        else if (goCommandString.contains(""so"")){

            for (int b = 0; b< wandpunkte.size(); b++){

                if (Integer.parseInt(wandpunkte.get(b).substring(2,3))<y && Integer.parseInt(wandpunkte.get(b).substring(2,3))>= (y-moveAmmount) && Integer.parseInt(wandpunkte.get(b).substring(0,1)) == x ){

                    y =Integer.parseInt(wandpunkte.get(b).substring(2,3))+1;
                    finalString = String.format(""(%d,%d)"",x,y);
                    return finalString;

                }
            }

                y = y - moveAmmount;
                if (y<0) y=0;
                if (y>8)y=8;

            finalString = String.format(""(%d,%d)"",x,y);
            return finalString;

        }
        else if (goCommandString.contains(""ea"")){



            for (int a = 0; a< wandpunkte.size(); a++){

                if (Integer.parseInt(wandpunkte.get(a).substring(0,1))>x && Integer.parseInt(wandpunkte.get(a).substring(0,1))<= (x+moveAmmount) && Integer.parseInt(wandpunkte.get(a).substring(2,3)) == y ){

                    x = Integer.parseInt(wandpunkte.get(a).substring(0,1))-1;
                    finalString = String.format(""(%d,%d)"",x,y);
                    return finalString;


                }

            }


                 x = x+moveAmmount;
                if (x<0) x=0;
               if (x>12)x=12;

            finalString = String.format(""(%d,%d)"",x,y);
            return finalString;
        }
        else if (goCommandString.contains(""we"")){



            for (int i = 0; i< wandpunkte.size(); i++){
                    ///&& Integer.parseInt(wandpunkte.get(i).substring(2,3)) !=Integer.parseInt(wandpunkte.get(i+1).substring(2,3))  && Integer.parseInt(wandpunkte.get(i+1).substring(2,3)) !=Integer.parseInt(wandpunkte.get(i+2).substring(2,3))  && Integer.parseInt(wandpunkte.get(i+2).substring(2,3)) !=Integer.parseInt(wandpunkte.get(i+3).substring(2,3))

                if (Integer.parseInt(wandpunkte.get(i).substring(0,1))<x && Integer.parseInt(wandpunkte.get(i).substring(0,1))>= (x-moveAmmount) && Integer.parseInt(wandpunkte.get(i).substring(2,3)) == y ){

                    x = Integer.parseInt(wandpunkte.get(i).substring(0,1));
                    finalString = String.format(""(%d,%d)"",x,y);
                    return finalString;


                }

            }

            x = x - moveAmmount;
            if (x<0) x=0;
            if (x>12)x=12;
            finalString = String.format(""(%d,%d)"",x,y);
            return finalString;


        }

     else return null;
    }





}

package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String goTo(String goCommandString);
}
",4991,172,46.33653846153846,355,0.005813953488372093,0.09302325581395349,0.0755813953488372,0.0,0.8313953488372093,0.0,0.29069767441860467,0.0,False,False,True,False,True,False,2,0.011627906976744186,0.011627906976744186,0.10465116279069768,0.005813953488372093,0.6976744186046512,0.46511627906976744,0.011627906976744186,8.05,11,333.0,333
student112,student,,,"package thkoeln.st.st2praktikum.exercise;


public class Exercise0 implements GoAble {
    public Integer startposition_x=0;
    public Integer startposition_y=2;

    @Override
    public String go(String goCommandString) {

        Pair no [] =new Pair[3];
        no[0] = new Pair(4, 5);
        no[1] = new Pair(5, 5);
        no[2] = new Pair(6, 5);

        Pair so [] =new Pair[3];
        so[0] = new Pair(4, 4);
        so[1] = new Pair(5, 4);
        so[2] = new Pair(6, 4);

        Pair ea [] =new Pair[11];
        ea[0] = new Pair(2, 2);
        ea[1] = new Pair(2, 1);
        ea[2] = new Pair(2, 0);
        ea[3] = new Pair(4, 2);
        ea[4] = new Pair(4, 1);
        ea[5] = new Pair(4, 0);
        ea[6] = new Pair(4, 3);
        ea[7] = new Pair(6, 5);
        ea[8] = new Pair(6, 6);
        ea[9] = new Pair(6, 7);
        ea[10] = new Pair(6, 8);

        Pair we [] =new Pair[11];
        we[0] = new Pair(3, 2);
        we[1] = new Pair(3, 1);
        we[2] = new Pair(3, 0);
        we[3] = new Pair(5, 2);
        we[4] = new Pair(5, 1);
        we[5] = new Pair(5, 0);
        we[6] = new Pair(5, 3);
        we[7] = new Pair(7, 5);
        we[8] = new Pair(7, 6);
        we[9] = new Pair(7, 7);
        we[10] = new Pair(7, 8);

        goCommandString=goCommandString.replace(""["","""");
        goCommandString=goCommandString.replace(""]"","""");
        String[]commando=goCommandString.split("","");

        Integer steps = Integer.valueOf(commando[1]);
            //Abfrage für 0 -- wenn ganz am rand
            switch (commando[0]) {
                case ""no"": {
                    for (int i = steps; i > 0; i--) {
                    if (!compare(new Pair(startposition_x, startposition_y), no)) {
                        if (startposition_y < 8)
                            startposition_y++;
                    }
                    }break;
                }
                case ""so"": {
                    for (int i = steps; i > 0; i--) {
                    if (!compare(new Pair(startposition_x, startposition_y), so)) {
                            if (startposition_y > 0)
                                startposition_y--;
                        }
                    }break;
                }
                case ""ea"": {
                    for (int i = steps; i > 0; i--) {
                    if (!compare(new Pair(startposition_x, startposition_y), ea)) {
                        if (startposition_x < 11)
                            startposition_x++;
                    }
                    }break;
                }
                case ""we"": {
                    for (int i = steps; i > 0; i--) {
                        if (!compare(new Pair(startposition_x, startposition_y), we)) {
                            if (startposition_x > 0)
                                startposition_x--;
                        }
                    }break;
                }
            }


        return (""(""+startposition_x+"",""+startposition_y+"")"");

    }
    public Boolean compare(Pair gesucht, Pair[] arr){

        for(int i=0; i<arr.length; i++){
            if(arr[i].first==gesucht.first && arr[i].second==gesucht.second){
                return true;
            }
        }
        return false;
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String go(String goCommandString);
}

package thkoeln.st.st2praktikum.exercise;

public class Pair {
    int first;
    int second;
    // Constructor
    public Pair(int first, int second)
    {
        this.first = first;
        this.second = second;
    }
}
",3599,120,33.77669902912621,87,0.016666666666666666,0.075,0.041666666666666664,0.008333333333333333,0.925,0.0,0.125,0.0,False,False,True,False,False,False,3,0.025,0.03333333333333333,0.05,0.016666666666666666,0.675,0.06666666666666667,0.0,6.125,15,22.5,34
student116,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Walkable {
    private int x;
    private int y;
    char[] c=new char[2];
    @Override
    public String walk(String walkCommandString){
        c[0]=walkCommandString.charAt(1);
        c[1]=walkCommandString.charAt(2);
        String []h=walkCommandString.split("","");
        String j=h[1];
        j=j.replace(""]"","""");
        int b=Integer.parseInt(j);
        if(c[0]=='n'&&c[1]=='o'){
            goNorth(b);
        }

        else if(c[0]=='s'&&c[1]=='o'){
            goSouth(b);
        }

        else if(c[0]=='e'&&c[1]=='a'){
            goEast(b);
        }

        else if(c[0]=='w'&&c[1]=='e'){
            goWest(b);
        }
        else{
            return ""-1"";
        }
        return ""(""+x+"",""+y+"")"";
    }
    boolean [] [] obstaclesX = new boolean[12][9];
    boolean [] [] obstaclesY = new boolean[12][9];
    Exercise0() {
        x = 1;
        y = 6;
        obstaclesY[0][6] = true;
        obstaclesY[1][6] = true;
        obstaclesY[2][6] = true;

        obstaclesY[1][5] = true;
        obstaclesY[2][5] = true;
        obstaclesY[3][5] = true;
        obstaclesY[4][5] = true;
        obstaclesY[5][5] = true;
        obstaclesY[6][5] = true;
        obstaclesY[7][5] = true;
        obstaclesY[8][5] = true;
        obstaclesY[9][5] = true;

        obstaclesX[9][1] = true;
        obstaclesX[9][2] = true;
        obstaclesX[9][3] = true;
        obstaclesX[9][4] = true;
        obstaclesX[9][5] = true;

        obstaclesX[3][6] = true;
        obstaclesX[3][7] = true;
        obstaclesX[3][8] = true;
    }
    private void goNorth(int steps){
        if(y<7 && steps>0){
            if(!obstaclesY[x][y+1] || !obstaclesY[x+1][y+1]) {
                y++;
                goNorth(steps - 1);
            }
        }
    }

    private void goSouth(int steps){
        if(y>0 && steps>0){
            if(!obstaclesY[x][y] || !obstaclesY[x+1][y]) {
                y--;
                goSouth(steps - 1);
            }
        }
    }

    private void goEast(int steps){
        if(x<10 && steps>0){
            if(!obstaclesX[x+1][y] || !obstaclesX[x+1][y+1]) {
                x++;
                goEast(steps - 1);
            }
        }
    }

    private void goWest(int steps){
        if(x>0 && steps>0){
            if(!obstaclesX[x][y] || !obstaclesX[x][y+1]) {
                x--;
                goWest(steps - 1);
            }
        }
    }

}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",2602,106,26.838709677419356,62,0.0,0.11320754716981132,0.0,0.0,0.8301886792452831,0.0,0.12264150943396226,0.0,True,False,False,False,False,False,2,0.05660377358490566,0.04716981132075472,0.02830188679245283,0.009433962264150943,0.7641509433962265,0.12264150943396226,0.0,3.4444444444444446,10,0.0,0
student118,student,,,"package thkoeln.st.st2praktikum.exercise;

import org.modelmapper.internal.Pair;

import javax.persistence.criteria.CriteriaBuilder;

public class Exercise0 implements GoAble {

    int X_MAX = 10;
    int Y_MAX = 7;
    int X = 1;
    int Y = 6;


    @Override
    public String go(String goCommandString) {

        int steps = Integer.parseInt(String.valueOf(goCommandString.charAt(4)));

        //north
        if (goCommandString.charAt(1)=='n') {
            if ((X>=1 && X<=8) && Y<5) {
                if (Y+steps>4) Y=4;
                else Y +=steps;

            }
            else if (X==0 && Y<6){
                if (Y+steps>5) Y=5;
                else Y-=steps;

            }
            else if (X==1&&Y==5) Y=5;
            else if (steps+Y>Y_MAX) Y= Y_MAX;
            else Y +=steps;
        }
        //south
        if (goCommandString.charAt(1)=='s') {
            if ((X>=2 && X<=8) && Y>5){
                if (Y-steps<5) Y=5;
                else Y-=steps;

            }
            else if (X<2 && Y>5){
                if (Y-steps<6) Y=6;
                else Y-=steps;

            }
            else if (X==1 && Y==5) Y=5;
            else if (Y-steps<0) Y= 0;
            else Y-=steps;

        }
        //east
        if (goCommandString.charAt(1)=='e'){
            if ((Y>=1 && Y<=4) && X<9){
                if (X+steps>8) X=8;
                else X+=steps;


            }
            else if (Y>5 && X<3){
                if (X+steps>2) X=2;
                else X+=steps;
            }
            else if (steps+X>X_MAX) X=X_MAX;
            else X+=steps;
        }
        //west
        if (goCommandString.charAt(1)=='w'){
            if ((Y>=1 && Y<=4) && X>8){
                if (X-steps<9) X=9;
                else X-=steps;

            }
            else if (Y>5 && X>2){
                if (X-steps<3) X=3;
                else X-=steps;

            }
            else if (X-steps<0) X=0;
            else X-=steps;
        }

        return ""(""+X+"",""+Y+"")"";
    }
    public static void main(String args[]){

        Exercise0 ex = new Exercise0();


        System.out.println(ex.go(""[no,2]""));
        System.out.println(ex.go(""[ea,5]""));
        System.out.println(ex.go(""[we,3]""));
        System.out.println(ex.go(""[we,4]""));

    }
}


package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String go(String goCommandString);
}
",2413,104,29.227848101265824,80,0.038461538461538464,0.25,0.0,0.0,0.625,0.0,0.20192307692307693,0.038461538461538464,False,False,False,False,False,False,2,0.028846153846153848,0.038461538461538464,0.019230769230769232,0.009615384615384616,0.8846153846153846,0.14423076923076922,0.019230769230769232,3.4,5,4.5,5
student119,student,,,"package thkoeln.st.st2praktikum.exercise;

import java.awt.*;
import java.util.List;

public class Exercise0 implements Walkable {

    // Barriers
    // (0,6) - (2,6)
    // (3,6) - (3,8)
    // (1,5) - (9,5)
    // (9,1) - (9,5)
    private final List<Barrier> mBarriers = List.of(
            // Map borders
            new Barrier(new Point(0, 0), new Point(11, 0), BarrierType.horizontal),
            new Barrier(new Point(0, 8), new Point(11, 8), BarrierType.horizontal),
            new Barrier(new Point(0, 0), new Point(0, 8), BarrierType.vertical),
            new Barrier(new Point(11, 0), new Point(11, 8), BarrierType.vertical),

            // Barriers
            new Barrier(new Point(0, 6), new Point(2, 6), BarrierType.horizontal),
            new Barrier(new Point(3, 6), new Point(3, 8), BarrierType.vertical),
            new Barrier(new Point(1, 5), new Point(9, 5), BarrierType.horizontal),
            new Barrier(new Point(9, 1), new Point(9, 5), BarrierType.vertical)
    );

    // Start
    // (1,6)
    private final TilePosition mCurrentPosition = new TilePosition(
            new Point(1, 6),
            new Point(1, 7),
            new Point(2, 7),
            new Point(2, 6)
    );

    @Override
    public String walkTo(String walkCommandString) {
        // 1. in which direction are we moving?
        // 2. get barriers for this direction
        // 3. get barriers for current tile position, which barrier would be crossed?
        // 4. move to the new tile position
        // 5. return new tile position (bottom left corner)
        final WalkCommand command = parseCommand(walkCommandString);

        for (int i = 0; i < command.steps; i++) {
            // if the border coordinate is lower than the barrier limit, we can move
            final boolean limitReached = barrierReached(command);
            if(limitReached)
                break;

            mCurrentPosition.walk(command.direction, 1);
        }
        return mCurrentPosition.getCoordinates();
    }

    private boolean barrierReached(WalkCommand command) {
        final int border = mCurrentPosition.getBorder(command.direction);
        return mBarriers.stream().anyMatch(barrier -> {
            switch (command.direction) {
                // we are interested in barriers where the y coordinate is greater than or equal
                // the current tile position, and the x coordinate is in rage of barriers x coordinates
                case north:
                case south:
                    return barrier.type == BarrierType.horizontal &&
                            mCurrentPosition.leftTop.x >= barrier.start.x && mCurrentPosition.rightTop.x <= barrier.end.x &&
                            border == barrier.start.y;
                case east:
                case west:
                    final boolean barrierTypeMatch = barrier.type == BarrierType.vertical;
                    final boolean barrierInRange = mCurrentPosition.leftBottom.y >= barrier.start.y && mCurrentPosition.leftTop.y <= barrier.end.y;
                    return barrierTypeMatch &&
                            barrierInRange &&
                            border == barrier.start.x;
                default:
                    throw new UnsupportedOperationException();
            }
        });
    }

    private WalkCommand parseCommand(String commandString) {
        var replaced = commandString.replace(""]"", """");
        replaced = replaced.replace(""["", """");
        var splits = replaced.split("","");
        var directionString = splits[0];
        var steps = splits[1];

        Direction direction;
        switch (directionString) {
            case ""no"":
                direction = Direction.north;
                break;
            case ""ea"":
                direction = Direction.east;
                break;
            case ""so"":
                direction = Direction.south;
                break;
            case ""we"":
                direction = Direction.west;
                break;
            default:
                throw new UnsupportedOperationException();

        }

        return new WalkCommand(direction, Integer.parseInt(steps));
    }

    private static class TilePosition {
        final public Point leftBottom;
        final public Point leftTop;
        final public Point rightTop;
        final public Point rightBottom;

        private TilePosition(Point leftBottom, Point leftTop, Point rightTop, Point rightBottom) {
            this.leftBottom = leftBottom;
            this.leftTop = leftTop;
            this.rightTop = rightTop;
            this.rightBottom = rightBottom;
        }

        private void walk(Direction direction, int steps) {
            var stepPoint = getStepPoint(direction, steps);
            updatePoint(leftBottom, stepPoint);
            updatePoint(leftTop, stepPoint);
            updatePoint(rightTop, stepPoint);
            updatePoint(rightBottom, stepPoint);
        }

        private void updatePoint(Point point, Point updates) {
            point.move(point.x + updates.x, point.y + updates.y);
        }

        private Point getStepPoint(Direction direction, int steps) {
            switch (direction) {
                case north:
                    return new Point(0, steps);
                case east:
                    return new Point(steps, 0);
                case south:
                    return new Point(0, -steps);
                case west:
                    return new Point(-steps, 0);
                default:
                    throw new UnsupportedOperationException();
            }
        }

        public int getBorder(Direction direction) {
            switch (direction) {
                case north:
                    return leftTop.y;
                case east:
                    return rightTop.x;
                case south:
                    return rightBottom.y;
                case west:
                    return leftTop.x;
                default:
                    throw new UnsupportedOperationException();
            }
        }

        public String getCoordinates() {
            return ""("" + leftBottom.x + "","" + leftBottom.y + "")"";
        }
    }

    private static class WalkCommand {
        final Direction direction;
        final int steps;

        private WalkCommand(Direction direction, int steps) {
            this.direction = direction;
            this.steps = steps;
        }
    }

    private enum Direction {
        north, east, south, west
    }

    private static class Barrier {
        public final Point start;
        public final Point end;
        public final BarrierType type;

        private Barrier(Point start, Point end, BarrierType type) {
            this.start = start;
            this.end = end;
            this.type = type;
        }

        public int getLimit() {
            switch (type) {
                case horizontal:
                    return start.y;
                case vertical:
                    return start.x;
                default:
                    throw new UnsupportedOperationException();
            }
        }
    }

    private enum BarrierType {
        horizontal, vertical
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);
}
",7349,215,38.354838709677416,147,0.07906976744186046,0.009302325581395349,0.013953488372093023,0.023255813953488372,0.3627906976744186,0.023255813953488372,0.13488372093023257,0.0,True,True,False,True,False,False,2,0.046511627906976744,0.05116279069767442,0.05116279069767442,0.018604651162790697,0.4511627906976744,0.08372093023255814,0.009302325581395349,7.517241379310345,17,31.941176470588236,84
student121,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Walkable {
    int xPos = 11;
    int yPos = 7;

    @Override
    public String walk(String walkCommandString) {

        int lowerBoundary = 0;
        int upperBoundary = 8;
        int rightBoundary = 12;
        int leftBoundary = 0;



        String direction = walkCommandString.split("","")[0].substring(1, 3);
        int stepSize = Integer.parseInt(walkCommandString.split("","")[1].substring(0,walkCommandString.split("","")[1].length() -1));

//        System.out.println(direction);
//        System.out.println(stepSize);

        switch (direction) {
            case ""no"": {
                for (int i = 0; i < stepSize; i++) {
                    yPos++;
                    if (yPos == upperBoundary) {
                        break;
                    }
                    //obstacle
                    if (yPos == 5 && xPos == 5) {
                        yPos--;
                        break;
                    }
                    if (yPos == 6 && (xPos >= 5 && xPos <= 11)) {
                        yPos--;
                        break;
                    }
                }
            }
            break;
            case ""so"": {
                for (int i = 0; i < stepSize; i++) {
                    yPos--;
                    if (yPos == lowerBoundary) {
                        break;
                    }
                    //obstacle
                    if (yPos == 6 && (xPos >= 5 && xPos <= 11)) {
                        break;
                    }

                }
            }
            break;
            case ""ea"": {
                for (int i = 0; i < stepSize; i++) {
                    xPos++;
                    if (xPos == rightBoundary) {
                        xPos--;
                        break;
                    }
                    //obstacle
                    if (xPos == 5 && yPos == 5) {
                        xPos--;
                        break;
                    }
                    if (xPos == 6 && (yPos >= 2 && yPos <= 4)) {
                        xPos--;
                        break;
                    }
                }
            }
            break;
            case ""we"": {
                for (int i = 0; i < stepSize; i++) {
                    xPos--;
                    if (xPos == leftBoundary) {
                        break;
                    }
                    //obstacle
                    if (xPos == 6 && yPos == 5) {
                        break;
                    }
                    if (xPos == 7 && (yPos >= 2 && yPos <= 4)) {
                        break;
                    }
                }
            }
            break;
            default:
                System.out.println(""Invalid command"");
        }

        String lastPosition = ""("" + xPos + "","" + yPos + "")"";

//        System.out.println(lastPosition);

        return lastPosition;

    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",3090,108,32.064516129032256,130,0.06481481481481481,0.10185185185185185,0.037037037037037035,0.009259259259259259,0.3888888888888889,0.0,0.12962962962962962,0.037037037037037035,False,False,False,False,False,False,2,0.018518518518518517,0.018518518518518517,0.06481481481481481,0.009259259259259259,0.4722222222222222,0.07407407407407407,0.0,8.9,13,17.714285714285715,33
student122,student,,,"package thkoeln.st.st2praktikum.exercise;


import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;

public class Exercise0 implements Walkable {

    private String loc = ""(1,6)"";
    String[] horizontalObstacles = {
            ""(0,6)-(2,6)"",  // horizontal
            ""(0,0)-(11,0)"", //horizontal
            ""(0,8)-(11,8)"",  //horizontal
            ""(1,5)-(9,5)""  // horizontal
    };
    String[] verticalObstacles = {
            ""(3,6)-(3,8)"",
            ""(9,1)-(9,5)"",
            ""(0,0)-(0,8)"",
            ""(11,0)-(11,8)""
    };


    @Override
    public String walkTo(String walkCommandString) {
        System.out.println(""COMMAND: ""+walkCommandString);
        String[] commandArr = walkCommandString.replace(""["","""").replace(""]"","""").split("","");
        String direction = commandArr[0];
        List<String> vObs = getObstacles(verticalObstacles);
        List<String> hObs = getObstacles(horizontalObstacles);

        switch (commandArr[0]){
            case ""so"":// y--
                for(int i =0; i<Integer.parseInt(commandArr[1]);i++){
                    int[] locArr = getLocAsArray(loc);
                    int[] firstPoint = {locArr[0],locArr[1]};
                    int[] secondPoint = {locArr[0]+1,locArr[1]};
                    int unchanged = locArr[1];
                    String boxEdge = stringOfTwoPoints(unchanged,firstPoint[0],secondPoint[0]);
                    System.out.println(""BOXEDGE: ""+boxEdge);

                    System.out.println(""HOBS""+hObs);
                    if(hObs.contains(boxEdge)){
                        System.out.println(""CONTAINS"");
                        break;
                    }else {
                        System.out.println(""NOT CONTAINS"");
                        System.out.println(""LOC BEFORE: ""+loc);
                        loc=changeLoc(loc, ""so"");
                        System.out.println(""LOC AFTER: ""+loc);
                    }
                }
                break;
            case ""no"":// y--
                for(int i =0; i<Integer.parseInt(commandArr[1]);i++){
                    int[] locArr = getLocAsArray(loc);
                    int[] firstPoint = {locArr[0],locArr[1]+1};
                    int[] secondPoint = {locArr[0]+1,locArr[1]+1};
                    int unchanged = locArr[1]+1;

                    String boxEdge = stringOfTwoPoints(unchanged,firstPoint[0],secondPoint[0]);
                    System.out.println(""BOXEDGE: ""+boxEdge);

                    System.out.println(""HOBS""+hObs);
                    if(hObs.contains(boxEdge)){
                        System.out.println(""CONTAINS"");
                        break;
                    }else {
                        System.out.println(""NOT CONTAINS"");
                        System.out.println(""LOC BEFORE: ""+loc);
                        loc=changeLoc(loc, ""no"");
                        System.out.println(""LOC AFTER: ""+loc);
                    }
                }
                break;
            case ""ea"":
                System.out.println(""EA START"");
                for(int i = 0; i<Integer.parseInt(commandArr[1]);i++){
                    int[] locArr = getLocAsArray(loc);
                    int[] firstPoint = {locArr[0]+1,locArr[1]};
                    int[] secondPoint = {locArr[0]+1,locArr[1]+1};
                    int unchanged = locArr[0]+1;
                    String boxEdge = stringOfTwoPoints(unchanged,firstPoint[1],secondPoint[1]);
                    System.out.println(""BOXEDGE: ""+boxEdge);

                    System.out.println(""VOBS""+vObs);
                    if(vObs.contains(boxEdge)){
                        System.out.println(""CONTAINS"");
                        break;
                    }
                    else {
                        System.out.println(""NOT CONTAINS"");
                        System.out.println(""LOC BEFORE: ""+loc);
                        loc=changeLoc(loc, ""ea"");
                        System.out.println(""LOC AFTER: ""+loc);
                    }

                }
                System.out.println(""EA END"");
                break;
            case ""we"":
                for(int i = 0; i<Integer.parseInt(commandArr[1]);i++){
                    int[] locArr = getLocAsArray(loc);

                    int[] firstPoint = {locArr[0],locArr[1]};
                    int[] secondPoint = {locArr[0],locArr[1]+1};
                    System.out.println(""FIRST: ""+ Arrays.toString(firstPoint) +"" SECOND: ""+ Arrays.toString(secondPoint));
                    int unchanged = locArr[0];
                    System.out.println(""UNCHANGED: ""+unchanged);
                    String boxEdge = stringOfTwoPoints(unchanged,firstPoint[1],secondPoint[1]);
                    System.out.println(""BOX EDGE: ""+boxEdge);

                    System.out.println(""VOBS""+vObs);
                    if(vObs.contains(boxEdge)){
                        System.out.println(""CONTAINS"");
                        break;
                    }
                    else {
                        System.out.println(""NOT CONTAINS"");
                        System.out.println(""LOC BEFORE: ""+loc);
                        loc=changeLoc(loc, ""we"");
                        System.out.println(""LOC AFTER: ""+loc);
                    }

                }
                break;
        }

        System.out.println(""NEW LOC: ""+loc);
        System.out.println(""END OF WALK--------------------------------------------------"");
        return loc;
    }

    private String changeLoc(String currentLoc,String direction){
        int[] currArr = getLocAsArray(currentLoc);
        switch (direction){
            case ""so"":
                currArr[1]--;
                break;
            case ""no"":
                currArr[1]++;
                break;
            case ""we"":
                currArr[0]--;

                break;
            case ""ea"":
                currArr[0]++;
                break;
        }

        return getLocAsString(currArr);

    }

    private String stringOfTwoPoints(int unchange, int p1, int p2){
        return unchange+""-(""+p1+"",""+p2+"")"";
    }

    private List<String> getObstacles(String[] obsStr){
        List<String> listOfEdges = new ArrayList<>();
        for(String obs:obsStr){
            HashMap<String,HashMap<String,String>> a = getPoints(obs);
            String direction = (String) a.keySet().toArray()[0];
            String axis = (String) a.get(direction).keySet().toArray()[0];
            String[] arr = getEdges(a.get(direction).get(axis));
            for(String ar: arr){
                String obsWithAxis = (axis+""-""+ar);
                listOfEdges.add(obsWithAxis);
            }
        }

        return listOfEdges;
    }

    private String[] getEdges(String str){
        String[] edgStr = str.split("","");
        String[] edges = new String[edgStr.length-1];

        for(int i = 0; i< edges.length;i++){
            edges[i] = (""("" + edgStr[i] + "",""+edgStr[i+1]+"")"");
        }

        return edges;
    }

    private HashMap<String,HashMap<String,String>> getPoints(String str){
        String direction;
        String nonChangingAxis;
        StringBuilder dots = new StringBuilder();
        String[] points = str.split(""-"");
        String[] leftPoint = points[0].replace(""("","""").replace("")"","""").split("","");
        String[] rightPoint = points[1].replace(""("","""").replace("")"","""").split("","");

        if(!leftPoint[0].equals(rightPoint[0])){
            direction = ""horizontal"";
            nonChangingAxis = leftPoint[1];
            for(int i = Integer.parseInt(leftPoint[0]); i<=Integer.parseInt(rightPoint[0]);i++){
                dots.append(i);
                dots.append("","");
            }
        }else{
            direction = ""vertical"";
            nonChangingAxis = leftPoint[0];
            for(int i = Integer.parseInt(leftPoint[1]); i<=Integer.parseInt(rightPoint[1]);i++){
                dots.append(i);
                dots.append("","");
            }
        }
        dots.deleteCharAt(dots.length()-1);
        HashMap<String,String> axisAndDots = new HashMap<>();
        HashMap<String,HashMap<String,String>> mainHash = new HashMap<>();
        axisAndDots.put(nonChangingAxis,dots.toString());
        mainHash.put(direction,axisAndDots);

        return mainHash;
    }

    private int[] getLocAsArray(String locString){
        String[] split = locString.replace(""("", """").replace("")"", """").split("","");

        return new int[]{
                Integer.parseInt(split[0]),
                Integer.parseInt(split[1])
        };
    }

    private String getLocAsString(int[] arr){
        return ""(""+(arr[0])+"",""+(arr[1])+"")"";
    }

}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);
}
",8831,240,41.90731707317073,122,0.025,0.020833333333333332,0.0375,0.008333333333333333,0.4875,0.0,0.1375,0.12916666666666668,False,True,False,False,False,True,2,0.0375,0.0125,0.175,0.004166666666666667,0.6041666666666666,0.4041666666666667,0.016666666666666666,7.694444444444445,19,7.666666666666667,10
student123,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Cell {

    private boolean borderNorth;
    private boolean borderEast;
    private boolean borderSouth;
    private boolean borderWest;

    public Cell(){
        borderNorth = false;
        borderEast = false;
        borderSouth = false;
        borderWest = false;
    }

    public boolean isBorderNorth() {
        return borderNorth;
    }

    public boolean isBorderEast() {
        return borderEast;
    }

    public boolean isBorderSouth() {
        return borderSouth;
    }

    public boolean isBorderWest() {
        return borderWest;
    }

    public void setBorderNorth(boolean borderNorth) {
        this.borderNorth = borderNorth;
    }

    public void setBorderEast(boolean borderEast) {
        this.borderEast = borderEast;
    }

    public void setBorderSouth(boolean borderSouth) {
        this.borderSouth = borderSouth;
    }

    public void setBorderWest(boolean borderWest) {
        this.borderWest = borderWest;
    }
}

package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements GoAble {

    private final Cell[][] grid;

    private final int outerBorderx;
    private final int outerBordery;

    private int turobotx;
    private int turoboty;

    public Exercise0(){
        this.outerBorderx = 11;
        this.outerBordery = 8;
        this.grid = new Cell[outerBorderx][outerBordery];
        this.turobotx = 1;
        this.turoboty = 6;

        for(int i = 0; i < outerBorderx;i++){
            for (int j = 0; j < outerBordery;j++){
                this.grid[i][j] = new Cell();
            }
        }
        this.setBorder(0,6,1,6);
        this.setBorder(3,6,3,7);
        this.setBorder(1,5,8,5);
        this.setBorder(9,1,9,4);
    }

    private void setBorder(int startx, int starty, int endx, int endy){
        if((endx - startx) != 0){
            for( int i = startx; i<=endx;i++){
                this.grid[i][starty].setBorderSouth(true);
                this.grid[i][starty - 1].setBorderNorth(true);
            }
        }
        else if((endy - starty) != 0){
            for( int i = starty; i<=endy;i++){
                this.grid[startx][i].setBorderWest(true);
                this.grid[startx - 1][i].setBorderEast(true);
            }
        }
    }
    @Override
    public String go(String goCommandString) {
        String[] commandValue = goCommandString.split("","");
        String direction = commandValue[0].substring(1);
        int amount = Integer.parseInt(commandValue[1].substring(0,commandValue[1].length()-1));
        switch (direction){
            case ""no"":
                this.moveNorth(amount);
                break;
            case ""so"":
                this.moveSouth(amount);
                break;
            case ""ea"":
                this.moveEast(amount);
                break;
            case ""we"":
                this.moveWest(amount);
                break;
        }
        return ""("" + this.turobotx +"","" + this.turoboty + "")"";
    }

    private void moveNorth(int amount){
        for(int i = amount; i > 0; i--){
            if(!this.grid[this.turobotx][this.turoboty].isBorderNorth() && this.turoboty + 1 < this.outerBordery) {
                this.turoboty++;
            }else return;
        }
    }
    private void moveSouth(int amount){
        for(int i = amount; i > 0; i--){
            if(!this.grid[this.turobotx][this.turoboty].isBorderSouth() && this.turoboty - 1 >=0) {
                this.turoboty--;
            } else return;
        }
    }
    private void moveEast(int amount){
        for(int i = amount; i > 0; i--){
            if(!this.grid[this.turobotx][this.turoboty].isBorderEast() && this.turobotx + 1 < this.outerBorderx) {
                this.turobotx++;
            }else return;
        }
    }
    private void moveWest(int amount){
        for(int i = amount; i > 0; i--){
            if(!this.grid[this.turobotx][this.turoboty].isBorderWest() && this.turobotx - 1 >= 0) {
                this.turobotx--;
            }else return;
        }
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String go(String goCommandString);
}
",4196,150,31.609375,115,0.0,0.04,0.05333333333333334,0.006666666666666667,0.32,0.0,0.14666666666666667,0.0,True,False,False,False,False,False,3,0.1,0.06,0.02,0.013333333333333334,0.6666666666666666,0.14,0.0,7.5,12,0.0,0
student124,student,,,"package thkoeln.st.st2praktikum.exercise;

import java.util.ArrayList;
import java.util.List;

public class Exercise0 implements GoAble {

    private List<Path> walls = new ArrayList<>();
    private Point position = new Point(8, 3);
    private int width = 12;
    private int height = 9;

    public Exercise0() {
        walls.add(new Path(new Point(4, 1), new Point(4, 7)));
        walls.add(new Path(new Point(6, 2), new Point(9, 2)));
        walls.add(new Path(new Point(6, 2), new Point(6, 5)));
        walls.add(new Path(new Point(6, 5), new Point(9, 5)));
    }

    @Override
    public String go(String goCommandString) {
        String direction = goCommandString.substring(1, 3);
        int steps = Integer.parseInt(goCommandString.substring(4, goCommandString.length() - 1));

        Movement movement;

        switch(direction) {
            case ""no"":
                movement = new Movement(
                        new Point (position.getX(), position.getY()),
                        new Point(position.getX(), position.getY() + steps),
                        Movement.Direction.NORTH
                );
                break;
            case ""ea"":
                movement = new Movement(
                        new Point (position.getX(), position.getY()),
                        new Point(position.getX() + steps, position.getY()),
                        Movement.Direction.EAST
                );
                break;
            case ""so"":
                movement = new Movement(
                        new Point (position.getX(), position.getY()),
                        new Point(position.getX(), position.getY() - steps),
                        Movement.Direction.SOUTH
                );
                break;
            case ""we"":
                movement = new Movement(
                        new Point (position.getX(), position.getY()),
                        new Point(position.getX() - steps, position.getY()),
                        Movement.Direction.WEST
                );
                break;
            default:
                throw new IllegalStateException(""Unexpected value: "" + direction);
        }

        System.out.println(""From: "" + movement.getFrom().toString());
        System.out.println(""To: "" + movement.getTo().toString());

        Point collisionPoint = movement.getLastPossibleMovementPoint(walls, width, height);
        if(collisionPoint != null) {
            System.out.println(""Collides with path at "" + collisionPoint);
            position = collisionPoint;
            return position.toString();
        }

        System.out.println("""");

        position = movement.getTo();

        return position.toString();
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String go(String goCommandString);
}

package thkoeln.st.st2praktikum.exercise;

import java.util.List;

public class Movement extends Path {

    private Direction direction;

    enum Direction {
        NORTH,
        EAST,
        SOUTH,
        WEST
    }

    public Movement(Point start, Point end, Direction direction) {
        super(start, end);
        this.direction = direction;
    }

    public Point getLastPossibleMovementPoint(List<Path> walls, int mapWidth, int mapHeight) {
        // mache bewegung und überprüfe jedes mal ob man eine wall berührt auf diesem Punkt
        Point position = getFrom();

        System.out.println();

        while (!position.equals(getTo())) {
            for (Path wall: walls) {
                if(stepCollidesWithWall(position, wall, direction)) {
                    System.out.println(wall);
                    System.out.println(""Collides with wall"");
                    return position;
                }
            }

            Point newPosition = move(position, 1);

            System.out.println(""New position: "" + newPosition);

            if(newPosition.isOutOfBounds(mapWidth, mapHeight)) {
                System.out.println(""Is out of bounds"");
                return position;
            }

            position = newPosition;

            System.out.println(position);
            System.out.println(getTo());
            System.out.println(position.equals(getTo()));

            System.out.println();
        }

        return position;
    }

    private Point move(Point position, int i) {
        switch (direction) {
            case NORTH:
                return new Point(position.getX(), position.getY() + 1);
            case EAST:
                return new Point(position.getX() + 1, position.getY());
            case SOUTH:
                return new Point(position.getX(), position.getY() - 1);
            case WEST:
                return new Point(position.getX() - 1, position.getY());
            default:
                throw new IllegalStateException(""Unexpected value: "" + direction);
        }
    }

    private boolean stepCollidesWithWall(Point position, Path wall, Direction direction) {

        int pathMinX = Math.min(wall.getFrom().getX(), wall.getTo().getX());
        int pathMaxX = Math.max(wall.getFrom().getX(), wall.getTo().getX());
        int pathMinY = Math.min(wall.getFrom().getY(), wall.getTo().getY());
        int pathMaxY = Math.max(wall.getFrom().getY(), wall.getTo().getY());

        int x = position.getX();
        int y = position.getY();

        switch (direction) {
            case NORTH:
            case SOUTH:
                // wall muss vertikal sein

                // ist wall vertikal?
                if(pathMinY == pathMaxY) {
                    System.out.println(""Wall ist vertikal"");

                    // kann es auf y-Achse Berührung geben
                    if(direction == Direction.SOUTH) {
                        // (8,2) -> (8,1)
                        if(y != pathMinY) {
                            return false;
                        }
                    } else {
                        // (8,1) -> (8,2)
                        if(y + 1 != pathMinY) {
                            return false;
                        }
                    }
                    return x >= pathMinX && x < pathMaxX;
                }
                break;
            default:
                // wall muss horizontal sein

                // ist wall horizontal?
                if(pathMinX == pathMaxX) {
                    System.out.println(""Wall ist horizontal"");

                    // kann es auf y-Achse Berührung geben
                    if(direction == Direction.WEST) {
                        // (8,2) -> (8,1)
                        if(x != pathMinX) {
                            return false;
                        }
                    } else {
                        // (8,1) -> (8,2)
                        if(x + 1 != pathMinX) {
                            return false;
                        }
                    }
                    return y >= pathMinY && y < pathMaxY;
                }
                break;
        }

        return false;
    }

    public Direction getDirection() {
        return direction;
    }
}

package thkoeln.st.st2praktikum.exercise;

class Path {
    private Point from;
    private Point to;

    public Path(Point start, Point end) {
        this.from = start;
        this.to = end;
    }

    public Point getFrom() {
        return from;
    }

    public Point getTo() {
        return to;
    }

    @Override
    public String toString() {
        return ""Path{"" + ""from="" + from + "", to="" + to +'}';
    }
}
package thkoeln.st.st2praktikum.exercise;

import java.util.Objects;

class Point {
    private int x;
    private int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    public boolean isOutOfBounds(int width, int height) {
        return x >= width || y >= height || x < 0 || y < 0;
    }

    @Override
    public String toString() {
        return ""("" + x + "","" + y + "")"";
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Point point = (Point) o;
        return x == point.x && y == point.y;
    }
}",8292,282,35.290748898678416,97,0.03900709219858156,0.04609929078014184,0.0035460992907801418,0.010638297872340425,0.20212765957446807,0.0070921985815602835,0.1950354609929078,0.05319148936170213,False,True,False,True,False,False,5,0.04964539007092199,0.031914893617021274,0.04609929078014184,0.014184397163120567,0.3475177304964539,0.3120567375886525,0.014184397163120567,5.552631578947368,14,26.545454545454547,80
student125,student,,,"package thkoeln.st.st2praktikum.exercise;

import java.util.List;

public class Exercise0 implements Walkable
{
    private Position currentPosition;
    private Room room;

    public Exercise0()
    {
        //generate the room (Grid of Field objects)
        this.room = new Room(12, 9);

        //setup barriers on our individual field
        room.setupBarrierAt(4, 1, List.of(""we""));
        room.setupBarrierAt(4, 2, List.of(""we""));
        room.setupBarrierAt(4, 3, List.of(""we""));
        room.setupBarrierAt(4, 4, List.of(""we""));
        room.setupBarrierAt(4, 5, List.of(""we""));
        room.setupBarrierAt(4, 6, List.of(""we""));

        room.setupBarrierAt(6, 2, List.of(""we"", ""so""));
        room.setupBarrierAt(7, 2, List.of(""so""));
        room.setupBarrierAt(8, 2, List.of(""so""));

        room.setupBarrierAt(6, 3, List.of(""we""));

        room.setupBarrierAt(6, 4, List.of(""we"", ""no""));
        room.setupBarrierAt(7, 4, List.of(""no""));
        room.setupBarrierAt(8, 4, List.of(""no""));

        //bring our little robot into starting position
        spawnRobotAtPosition(new Position(8, 3));
    }

    //true if robot collides with field at given position
    private boolean collidesAtPosition(Position position, String walkDirection)
    {
        switch(walkDirection)
        {
            case ""no"":
            {
                return room.roomLayout[position.posX][position.posY].hasNorthernBarrier;
            }
            case ""so"":
            {
                return room.roomLayout[position.posX][position.posY].hasSouthernBarrier;
            }
            case ""we"":
            {
                return room.roomLayout[position.posX][position.posY].hasWesternBarrier;
            }
            case ""ea"":
            {
                return room.roomLayout[position.posX][position.posY].hasEasternBarrier;
            }
            default: {}
        }

        return false;
    }

    private void spawnRobotAtPosition(Position position)
    {
        this.currentPosition = position;
    }

    @Override
    public String walk(String walkCommandString)
    {
        String direction = walkCommandString.split("","")[0].replace(""["", """");
        int amount = Integer.valueOf(walkCommandString.split("","")[1].replace(""]"", """"));

        switch (direction)
        {
            case ""no"":
            {
                for (int i = 0; i < amount; i++)
                {
                    if (!collidesAtPosition(currentPosition, direction))
                        ++currentPosition.posY;
                }
                break;
            }
            case ""so"":
            {
                for (int i = 0; i < amount; i++)
                {
                    if (!collidesAtPosition(currentPosition, direction))
                        --currentPosition.posY;
                }
                break;
            }
            case ""ea"":
            {
                for (int i = 0; i < amount; i++)
                {
                    if (!collidesAtPosition(currentPosition, direction))
                        ++currentPosition.posX;
                }
                break;
            }
            case ""we"":
            {
                for (int i = 0; i < amount; i++)
                {
                    if (!collidesAtPosition(currentPosition, direction))
                        --currentPosition.posX;
                }
                break;
            }
            default: {}
        }

        return ""("" + currentPosition.posX + "","" + currentPosition.posY + "")"";
    }

    public class Position
    {
        int posX, posY;

        public Position(int x, int y)
        {
            this.posX = x;
            this.posY = y;
        }
    }

    public class Room
    {
        public Field[][] roomLayout;

        public Room(int x, int y)
        {
            roomLayout = new Field[x][y];

            for(int i = 0; i < x; i++)
            {
                for (int j = 0; j < y; j++)
                {
                    roomLayout[i][j] = new Field();
                }
            }
        }

        public void setupBarrierAt(int x, int y, List<String> directions)
        {
            for (String direction : directions)
            {
                switch(direction)
                {
                    case ""no"":
                    {
                        roomLayout[x][y].hasNorthernBarrier = true;
                        break;
                    }
                    case ""so"":
                    {
                        roomLayout[x][y].hasSouthernBarrier = true;
                        break;
                    }
                    case ""we"":
                    {
                        roomLayout[x][y].hasWesternBarrier = true;
                        break;
                    }
                    case ""ea"":
                    {
                        roomLayout[x][y].hasEasternBarrier = true;
                        break;
                    }
                    default: {}
                }
            }
        }
    }

    public class Field
    {
        public boolean hasNorthernBarrier;
        public boolean hasSouthernBarrier;
        public boolean hasWesternBarrier;
        public boolean hasEasternBarrier;

        public Field()
        {
            this.hasNorthernBarrier = false;
            this.hasSouthernBarrier = false;
            this.hasWesternBarrier = false;
            this.hasEasternBarrier = false;
        }
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",5608,200,30.727272727272727,88,0.02,0.025,0.035,0.015,0.215,0.0,0.12,0.0,True,False,False,False,False,False,2,0.025,0.045,0.01,0.02,0.425,0.18,0.005,8.722222222222221,18,43.75,51
student126,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements GoAble {

    private int x;
    private int y;
    private String[][] movGrid;

    public Exercise0() {
        movGrid = new String[11][8];
        x = 4;
        y = 0;
        initMovGrid();
    }

    private void initMovGrid() {
        for (int i = 0; i < 6; i++) {
            movGrid[0][i] = ""ea"";
            movGrid[1][i] = ""we"";
            if (i != 0) {
                movGrid[6][i] = ""ea"";
                movGrid[7][i] = ""we"";
            }
        }
        for (int i = 1; i < 7; i++) {
            if (i != 4) {
                movGrid[i][5] += "" no"";
                movGrid[i][6] += "" so"";
            }
        }
    }

    @Override
    public String go(String goCommandString) {
        String[] commands = goCommandString.substring(1, goCommandString.length() - 1).split("","");
        int distance = Integer.parseInt(commands[1]);
        switch (commands[0]) {
            case ""no"":
                moveNo(distance);
                break;
            case ""so"":
                moveSo(distance);
                break;
            case ""we"":
                moveWe(distance);
                break;
            case ""ea"":
                moveEa(distance);
        }
        return (""("" + x + "","" + y + "")"");
    }

    private void moveNo(int distance) {
        for (int i = 0; i < distance; i++) {
            if (movGrid[x][y] != null) {
                String[] moves = movGrid[x][y].split("" "");
                if (y + 1 == 8 || moves[0].equals(""no"") || (moves.length > 1 && moves[1].equals(""no""))) {
                    break;
                } else {
                    y++;
                }
            } else if (y + 1 != 8) {
                y++;
            } else {
                break;
            }
        }
    }

    private void moveSo(int distance) {
        for (int i = 0; i < distance; i++) {
            if (movGrid[x][y] != null) {
                String[] moves = movGrid[x][y].split("" "");
                if (y - 1 == -1 || moves[0].equals(""so"") || (moves.length > 1 && moves[1].equals(""so""))) {
                    break;
                } else{
                    y--;
                }
            } else if (y - 1 != -1) {
                y--;
            } else {
                break;
            }
        }
    }

    private void moveWe(int distance) {
        for (int i = 0; i < distance; i++) {
            if (movGrid[x][y] != null) {
                String[] moves = movGrid[x][y].split("" "");
                if (x - 1 == -1 || moves[0].equals(""we"") || (moves.length > 1 && moves[1].equals(""we""))) {
                    break;
                } else {
                    x--;
                }
            } else if (x - 1 != -1) {
                x--;
            } else {
                break;
            }
        }
    }

    private void moveEa(int distance) {
        for (int i = 0; i < distance; i++) {
            if (movGrid[x][y] != null) {
                String[] moves = movGrid[x][y].split("" "");
                if (x + 1 == 11 || moves[0].equals(""ea"") || (moves.length > 1 && moves[1].equals(""ea""))) {
                    break;
                } else {
                    x++;
                }
            } else if (x + 1 != 11) {
                x++;
            } else {
                break;
            }
        }
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String go(String goCommandString);
}
",3514,126,29.46086956521739,106,0.0,0.1111111111111111,0.047619047619047616,0.007936507936507936,0.46825396825396826,0.0,0.0873015873015873,0.0,False,False,False,False,False,False,2,0.05555555555555555,0.023809523809523808,0.047619047619047616,0.007936507936507936,0.7380952380952381,0.16666666666666666,0.0,4.625,8,0.0,0
student127,student,,,"package thkoeln.st.st2praktikum.exercise;

import java.util.ArrayList;
import java.util.List;

public class Barrier {
    private int[] start;
    private int[] end;

    private Character getAxis() {
        if (start[1]==end[1]) {
            return 'h';
        } else if (start[0]==end[0]) {
            return 'v';
        } else {
            throw new IllegalStateException();
        }
    }

    private Boolean isCrossingThePlane(int plane, int current, int next) {
        return current < plane && next == plane;
    }

    private Boolean isNotInOrder(int[] currentPosition, int[] nextPosition) {
        return currentPosition[0]==nextPosition[0] && currentPosition[1] > nextPosition[1]
                || currentPosition[1]==nextPosition[1] && currentPosition[0] > nextPosition[0];
    }

    public Boolean isBlocking(int[] currentPosition, int[] nextPosition) {
        //sorting to half the possible cases
        if (isNotInOrder(currentPosition,nextPosition)) {
            int[] temp = currentPosition;
            currentPosition = nextPosition;
            nextPosition = temp;
        }

        if ( getAxis() == 'h' && isCrossingThePlane(start[1], currentPosition[1], nextPosition[1]) ) {
            return nextPosition[0] >= start[0] && nextPosition[0] < end[0];
        } else if ( getAxis() == 'v' && isCrossingThePlane(start[0], currentPosition[0], nextPosition[0]) ) {
            return nextPosition[1] >= start[1] && nextPosition[1] < end[1];
        }

        return false;
    }

    public Barrier(int[] start, int[] end) {
        this.start = start;
        this.end = end;
    }

    public static List<Barrier> getDefaultBarrierList() {
        List<Barrier> allBarriers = new ArrayList<>();

        //borders of the map
        allBarriers.add( new Barrier(new int[]{0,0}, new int[]{0,8}) );
        allBarriers.add( new Barrier(new int[]{0,0}, new int[]{12,0}) );
        allBarriers.add( new Barrier(new int[]{12,0}, new int[]{12,8}) );
        allBarriers.add( new Barrier(new int[]{0,8}, new int[]{12,8}) );

        //additional barriers
        allBarriers.add( new Barrier(new int[]{1,6}, new int[]{6,6}) );
        allBarriers.add( new Barrier(new int[]{3,3}, new int[]{9,3}) );
        allBarriers.add( new Barrier(new int[]{4,1}, new int[]{4,3}) );
        allBarriers.add( new Barrier(new int[]{6,2}, new int[]{6,8}) );

        return allBarriers;
    }
}

package thkoeln.st.st2praktikum.exercise;

public enum Direction { no, ea, so, we }

package thkoeln.st.st2praktikum.exercise;

import org.springframework.data.util.Pair;

import java.util.List;
import java.util.StringTokenizer;
import java.util.function.Predicate;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Exercise0 implements Walkable {
    // default barriers and starting position
    private int[] position = new int[] {5, 3};
    List<Barrier> barriers = Barrier.getDefaultBarrierList();

    @Override
    public String walk(String walkCommandString) {
        if (!isValidInput(walkCommandString)) {
            throw new IllegalArgumentException();
        }

        Pair<Direction, Integer> walkCommand = getPairOf(walkCommandString);

        for(int currentStep = 0; currentStep < walkCommand.getSecond(); currentStep++) {
            int[] nextPosition = getNextPosition(walkCommand.getFirst());

            Predicate<Barrier> p = element -> element.isBlocking(position, nextPosition);
            if (barriers.stream().anyMatch(p)) {
                break;
            }

            position = nextPosition;
        }

        return ""("" + position[0] + "","" + position[1] + "")"";
    }

    public Boolean isValidInput(String walkCommandString) {
        Pattern st = Pattern.compile(""^\\[((no)|(ea)|(so)|(we)),\\d*\\]\\z$"");
        Matcher mt = st.matcher(walkCommandString);
        return mt.matches();
    }

    public Pair<Direction, Integer> getPairOf(String walkCommandString) {
        final StringTokenizer st = new StringTokenizer(walkCommandString, ""[],"");

        Direction direction = Direction.valueOf(st.nextToken());
        Integer steps = Integer.parseInt(st.nextToken());

        return Pair.of(direction,steps);
    }

    public int[] getNextPosition(Direction direction) {
        switch (direction) {
            case no:
                return new int[] {position[0], position[1]+1};
            case ea:
                return new int[] {position[0]+1, position[1]};
            case so:
                return new int[] {position[0], position[1]-1};
            case we:
                return new int[] {position[0]-1, position[1]};
            default:
                throw new IllegalArgumentException();
        }
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",4840,146,41.175438596491226,109,0.0273972602739726,0.04794520547945205,0.00684931506849315,0.00684931506849315,0.5753424657534246,0.02054794520547945,0.2191780821917808,0.0,False,True,True,False,False,False,4,0.0684931506849315,0.0273972602739726,0.0684931506849315,0.0136986301369863,0.4589041095890411,0.2054794520547945,0.0547945205479452,8.0,17,27.25,38
student128,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Dam {


    Position from, to;

    public Dam() {
    }

    public Dam(Position from, Position to) {
        this.from = from;
        this.to = to;
    }

    public Position getFrom() {
        return from;
    }

    public void setFrom(Position from) {
        this.from = from;
    }

    public Position getTo() {
        return to;
    }

    public void setTo(Position to) {
        this.to = to;
    }
}
package thkoeln.st.st2praktikum.exercise;

import java.util.ArrayList;
import java.util.List;

public class Exercise0 implements  Walkable {

    Position cleaningdvice;
    int endof_x = 11, endof_y = 8;
    List<Dam> damList = new ArrayList<>();
    public Exercise0() {
        cleaningdvice = new Position(1, 7);
        Position damposition1 = new Position(3, 3);
        Position damposition2 = new Position(3, 9);
        Position damposition3 = new Position(5, 3);
        Position damposition4 = new Position(5, 0);
        Position damposition5 = new Position(5, 2);
        Position damposition6 = new Position(6, 0);
        Position damposition7 = new Position(6, 4);
        damList.add(new Dam(damposition1, damposition2));
        damList.add(new Dam(damposition1, damposition3));
        damList.add(new Dam(damposition4, damposition5));
        damList.add(new Dam(damposition6, damposition7));
    }


    String run_commend(String direction, int steps) {
        switch (direction) {
            case ""no"":
                up_and_down(steps, 1);
                break;
            case ""so"":
                up_and_down(steps, -1);
                break;
            case ""ea"":
                right_and_left(steps,1);
                break;
            case ""we"":
                right_and_left(steps,-1);
                break;
        }
        return """";
    }

    private void right_and_left(int movment, int right_or_left) {
        int right=0;if(right_or_left>0)right=1;
        for (int i = 1; i <= movment; i++) {
            boolean can_move = true;
            if (cleaningdvice.getX() + right_or_left <= endof_x && cleaningdvice.getX() + right_or_left >= 0) {
                for (Dam dam : damList) {
                    if (dam.getFrom().getX() == dam.getTo().getX()) {
                        if (cleaningdvice.getX()+right == dam.getFrom().getX() && cleaningdvice.getY() >= dam.getFrom().getY() && cleaningdvice.getY() < dam.getTo().getY()) {
                            can_move = false;
                            break;
                        }
                    }
                }
            }else can_move = false;
            if (can_move) cleaningdvice.setX(cleaningdvice.getX()+right_or_left);
            else break;
        }
    }



    private void up_and_down(int movment, int up_or_down) {
        int up=0;if(up_or_down>0)up=1;
        for (int i = 1; i <= movment; i++) {
            boolean can_move = true;
            if (cleaningdvice.getY() + up_or_down <= endof_y && cleaningdvice.getY() + up_or_down >= 0) {
                for (Dam dam : damList) {
                    if (dam.getFrom().getY() == dam.getTo().getY()) {
                        if (cleaningdvice.getY()+up == dam.getFrom().getY() && cleaningdvice.getX() >= dam.getFrom().getX() && cleaningdvice.getX() < dam.getTo().getX()) {
                            can_move = false;
                            break;
                        }
                    }
                }
            } else can_move = false;
            if (can_move) cleaningdvice.setY(cleaningdvice.getY()+up_or_down);
            else break;
        }
    }


    @Override
    public String walkTo(String walkCommandString) {
        String newcommand[]=walkCommandString.replace(""["","""").replace(""]"","""").split("","");
        String direction=newcommand[0];
        int steps =Integer.parseInt(newcommand[1]);



        run_commend(direction,steps);
        return cleaningdvice.toString();
    }



}

package thkoeln.st.st2praktikum.exercise;

public class Position {


    int x,y;

    public Position() {
    }

    public Position(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return x;
    }

    public void setX(int x) {
        this.x = x;
    }

    public int getY() {
        return y;
    }

    public void setY(int y) {
        this.y = y;
    }

    @Override
    public String toString() {
        return ""("" + x +"","" + y +')';
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);
}
",4598,174,32.77037037037037,174,0.0,0.05747126436781609,0.022988505747126436,0.005747126436781609,0.3218390804597701,0.0,0.1839080459770115,0.0,True,True,False,False,False,False,4,0.08045977011494253,0.04597701149425287,0.08045977011494253,0.017241379310344827,0.39080459770114945,0.27586206896551724,0.011494252873563218,7.84,13,0.0,0
student129,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Moveable {
    int[][] matrix = {
            {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0},
            {1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    };
    int posX = 1;
    int posY = 1;
    int steps = 0;
    boolean no_change = true;

    @Override
    public String move(String moveCommandString) {

        if (moveCommandString.charAt(0) == 'n') {
            steps = moveCommandString.charAt(3) - '0';
            for (int i = 0; i < steps; i++) {
                if (posY <= 0) {
                    break;
                } else if (matrix[posY - 1][posX] == 1) {
                    break;
                } else {
                    no_change = false;
                    posY--;
                }
                if (posY <= 0) {
                    break;
                }
            }
        } else if (moveCommandString.charAt(0) == 'e') {
            steps = moveCommandString.charAt(3) - '0';
            for (int i = 0; i < steps; i++) {
                if (posX >= 10) {
                    break;
                } else {
                    posX++;
                }
                if (matrix[posY][posX] == 1) {
                    posX--;
                    break;
                }
                if (posX >= 10) {
                    break;
                }
            }

        } else if (moveCommandString.charAt(0) == 's') {
            steps = moveCommandString.charAt(3) - '0';
            for (int i = 0; i < steps; i++) {
                if (posY <= 0) {
                    break;
                } else if (matrix[posY + 1][posX] == 1) {
                    break;
                } else {
                    no_change = false;
                    posY++;
                }
                if (posY >= 8) {
                    break;
                }
            }

        } else if (moveCommandString.charAt(0) == 'w') {
            steps = moveCommandString.charAt(3) - '0';
            for (int i = 0; i < steps; i++) {
                if (posX <= 0) {
                    break;
                } else {
                    posX--;
                }
                if (matrix[posY][posX] == 1) {
                    posX++;
                    break;
                }
                if (posX <= 0) {
                    break;
                }
            }
        }
        if (no_change) {
            return ""("" + posX + "","" + (7 - posY) + "")"";
        } else {
            return ""("" + posX + "","" + (8 - posY) + "")"";
        }
        //throw new UnsupportedOperationException();
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String move(String moveCommandString);
}
",3054,101,31.414893617021278,57,0.009900990099009901,0.16831683168316833,0.039603960396039604,0.0,1.3762376237623761,0.009900990099009901,0.06930693069306931,0.0,True,False,False,False,False,False,2,0.019801980198019802,0.04950495049504951,0.0,0.009900990099009901,0.48514851485148514,0.07920792079207921,0.0,4.833333333333333,9,42.0,42
student13,student,,,"package thkoeln.st.st2praktikum.exercise;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class Exercise0 implements Walkable {

        final int xCoordinateSize = 12;
        final int yCoordinateSize = 9;

        int currentXPosition = 1;
        int currentYPosition = 7;

        Room r;
        Room [][] field = new Room[xCoordinateSize][yCoordinateSize];

        public void createRoom() {
            for (int i = 0; i < xCoordinateSize; i++) {
                for (int j = 0; j < yCoordinateSize; j++) {
                    field[i][j] = new Room(i, j);
                }
            }
        }


    public void determineNeighbor(){

        for(int i = 0; i < field.length; i++){
            for(int j = 0; j < field[i].length; j++){

                System.out.printf(""%d,%d\n"",i,j);
                if(j+1 < field[i].length && field[i][j+1] != null) {
                    field[i][j].setNorth(field[i][j + 1]);
                }
                if(i+1 < field.length && field[i+1][j] != null){
                    field[i][j].setEast(field[i+1][j]);
                }
                if(j-1 >= 0 ){
                    field[i][j].setSouth(field[i][j-1]);
                }

                if(i-1 >= 0 && i-1 < field[i].length && field[i-1][j] != null){
                    field[i][j].setWest(field[i-1][j]);
                }
            }
        }
    }

        public void verticallyWalls(){

            //1.wall
            for(int i = 3; i <= 8; i++ ){
                //from east
                field[2][i].setEast(null);
                // from west
                field[3][i].setWest(null);
            }

            //2.wall
            for(int i = 0; i <= 1; i++){
                //from east
                field[4][i].setEast(null);
                //from west
                field[5][i].setWest(null);
            }

            //3.wall
            for(int i = 0; i <= 3; i++){
                //from east
                field[5][i].setEast(null);
                //from west
                field[7][i].setWest(null);
            }
        }

        public void horizontallyWalls(){
                //4.wall
                //from north
                field[3][2].setNorth(null);
                field[4][2].setNorth(null);

                //from south
                field[4][4].setSouth(null);


        }

    public Exercise0(){
        createRoom();
        determineNeighbor();
        verticallyWalls();
        horizontallyWalls();
        r = field[currentXPosition][currentYPosition];
    }

    //@Override
        public String walkTo(String walkCommandString) {

            String [] coordinates = walkCommandString
                    .substring(1,walkCommandString.length()-1)
                    .split("","");

            String direction = coordinates[0];
            int numberOfSteps = Integer.parseInt(coordinates[1]);


            switch (direction) {
                case ""no"": r = r.moveNorth(numberOfSteps);
                    break;
                case ""so"": r = r.moveSouth(numberOfSteps);
                    break;
                case ""ea"": r = r.moveEast(numberOfSteps);
                    break;
                case ""we"": r = r.moveWest(numberOfSteps);
                    break;
            }

            String xCoordinate = String.valueOf(r.xPosition);
            String yCoordinate = String.valueOf(r.yPosition);
            return ""("" + xCoordinate + "","" + yCoordinate + "")"";
        }


        public static void main(String[]args){

            Exercise0 r = new Exercise0();

//            System.out.println(r.walkTo(""[ea,3]""));
//            System.out.println(r.walkTo(""[we,2]""));
//            System.out.println(r.walkTo(""[ea,4]""));
//            System.out.println(r.walkTo(""[so,5]""));

            //System.out.println(r.walkTo(""[so,5]""));
            //System.out.println(r.walkTo(""[ea,1]"")); // expected position (4,0)

            //HiddenTest1
            System.out.println(r.walkTo(""[so,5]""));
            System.out.println(r.walkTo(""[ea,4]""));
            System.out.println(r.walkTo(""[no,1]""));
            System.out.println(r.walkTo(""[we,3]""));


//            System.out.println(r.walkTo(""[so,5]""));
//            System.out.println(r.walkTo(""[ea,5]""));
//            System.out.println(r.walkTo(""[so,4]""));
//            System.out.println(r.walkTo(""[no,5]""));



        }
    }


package thkoeln.st.st2praktikum.exercise;

public class Room {

    public int xPosition;
    public int yPosition;

    private Room north;
    private Room south;
    private Room east;
    private Room west;


    public void setEast(Room east) {
        this.east = east;
    }

    public void setNorth(Room north) {
        this.north = north;
    }

    public void setWest(Room west) {
        this.west = west;
    }

    public void setSouth(Room south) {
        this.south = south;
    }

    //Konstruktor
    public Room(int xPosition, int yPosition){
        this.xPosition = xPosition;
        this.yPosition = yPosition;
    }

    // TODO: public Room moveNorth(int steps){ }
    // TODO: public Room moveSouth(int steps){ }
    // TODO: public Room moveEast(int steps){ }
    // TODO: public Room moveWest(int steps){ }

    public Room moveNorth(int steps) {
        if(north == null || steps == 0 ) return this;
        return north.moveNorth(steps-1);
    }

    public Room moveSouth(int steps){
        if(south == null || steps == 0) return this;
        return south.moveSouth(steps-1);
    }

    public Room moveEast(int steps){
        if(east == null || steps == 0) return this;
        return east.moveEast(steps-1);
    }

    public Room moveWest(int steps){
        if(west == null || steps == 0) return this;
        return west.moveWest(steps-1);
    }

}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);
}
",5950,221,34.72121212121212,80,0.13574660633484162,0.03619909502262444,0.03167420814479638,0.004524886877828055,0.3665158371040724,0.0,0.2171945701357466,0.06787330316742081,False,False,False,False,False,False,3,0.06787330316742081,0.05429864253393665,0.027149321266968326,0.00904977375565611,0.5972850678733032,0.18099547511312217,0.013574660633484163,8.26086956521739,16,24.413793103448278,66
student130,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements GoAble {

    int[][] room = new int[12][9];
    int[] robot = {8, 3};

    private void init() {
        // fill room
        for(int i = 0; i < 11; i++)
            for(int j = 0; j < 8; j++)
                room[i][j] = 0;

        // wall 1
        room[4][1] = 1;
        room[4][2] = 1;
        room[4][3] = 1;
        room[4][4] = 1;
        room[4][5] = 1;
        room[4][6] = 1;

        // wall 2
        room[7][5] = 1;
        room[8][5] = 1;
        room[9][5] = 1;

        // wall 3
        room[6][2] = 1;
        room[6][3] = 1;
        room[6][4] = 1;
        room[6][5] = 1;

        // wall 4
        room[7][2] = 1;
        room[8][2] = 1;
        room[9][2] = 1;
    }

    @Override
    public String go(String goCommandString) {

        init();
        String dir = goCommandString.substring(1, 3);
        int len = Integer.parseInt(goCommandString.substring(4, 5));

        switch (dir) {
            case ""no"":
                for (int i = 0; i < len; i++)
                    if(robot[1] == 8 || (room[robot[0]][robot[1] + 1] == 1 && room[robot[0] + 1][robot[1] + 1] == 1))
                        return ""("" + robot[0] + "","" + robot[1] + "")"";
                    else robot[1] ++;
                return ""("" + robot[0] + "","" + robot[1] + "")"";
            case ""ea"":
                for (int i = 0; i < len; i++)
                    if(robot[0] == 11 || (room[robot[0] + 1][robot[1]] == 1 && room[robot[0] + 1][robot[1] + 1] == 1))
                        return ""("" + robot[0] + "","" + robot[1] + "")"";
                    else robot[0] ++;
                return ""("" + robot[0] + "","" + robot[1] + "")"";
            case ""so"":
                for (int i = 0; i < len; i++)
                    if(robot[1] == 0 || (room[robot[0]][robot[1]] == 1 && room[robot[0] + 1][robot[1]] == 1))
                        return ""("" + robot[0] + "","" + robot[1] + "")"";
                    else robot[1] --;
                return ""("" + robot[0] + "","" + robot[1] + "")"";
            case ""we"":
                for (int i = 0; i < len; i++)
                    if(robot[0] == 0 || (room[robot[0]][robot[1]] == 1 && room[robot[0]][robot[1] + 1] == 1))
                        return ""("" + robot[0] + "","" + robot[1] + "")"";
                    else robot[0] --;
                return ""("" + robot[0] + "","" + robot[1] + "")"";
            default: return """";
        }
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String go(String goCommandString);
}
",2569,80,36.60294117647059,118,0.0625,0.05,0.075,0.0125,1.6875,0.0,0.15,0.0,False,False,False,False,False,False,2,0.0375,0.025,0.025,0.0125,1.05,0.05,0.0,2.8333333333333335,5,6.6,9
student131,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Dam {


    Position from, to;

    public Dam() {}


    public Dam(Position from, Position to) {
            this.from = from;
            this.to = to;
        }

        public Position getFrom () {
            return from;
        }

        public void setFrom (Position from){
            this.from = from;
        }

        public Position getTo () {
            return to;
        }

        public void setTo (Position to){
            this.to = to;
        }
    }
package thkoeln.st.st2praktikum.exercise;

import java.util.ArrayList;
import java.util.List;

public class Exercise0 implements  GoAble {

    Position cleaningdvice;
    int endof_x = 10, endof_y = 7;
    List<Dam> damList = new ArrayList<>();
    public Exercise0() {
        cleaningdvice = new Position(1, 6);
        Position damposition1 = new Position(9, 1);
        Position damposition2 = new Position(9, 5);
        Position damposition3 = new Position(0, 6);
        Position damposition4 = new Position(2, 6);
        Position damposition5 = new Position(3, 6);
        Position damposition6 = new Position(3, 8);
        Position damposition7 = new Position(1, 5);
        Position damposition8 = new Position(9, 5);
        damList.add(new Dam(damposition1, damposition2));
        damList.add(new Dam(damposition3, damposition4));
        damList.add(new Dam(damposition5, damposition6));
        damList.add(new Dam(damposition7, damposition8));
    }


    String run_commend(String direction, int steps) {
        switch (direction) {
            case ""no"":
                up_and_down(steps, 1);
                break;
            case ""so"":
                up_and_down(steps, -1);
                break;
            case ""ea"":
                right_and_left(steps,1);
                break;
            case ""we"":
                right_and_left(steps,-1);
                break;
        }
        return """";
    }

    private void right_and_left(int movment, int right_or_left) {
        int right=0;if(right_or_left>0)right=1;
        for (int i = 1; i <= movment; i++) {
            boolean can_move = true;
            if (cleaningdvice.getX() + right_or_left <= endof_x && cleaningdvice.getX() + right_or_left >= 0) {
                for (Dam dam : damList) {
                    if (dam.getFrom().getX() == dam.getTo().getX()) {
                        if (cleaningdvice.getX()+right == dam.getFrom().getX() && cleaningdvice.getY() >= dam.getFrom().getY() && cleaningdvice.getY() < dam.getTo().getY()) {
                            can_move = false;
                            break;
                        }
                    }
                }
            }else can_move = false;
            if (can_move) cleaningdvice.setX(cleaningdvice.getX()+right_or_left);
            else break;
        }
    }



    private void up_and_down(int movment, int up_or_down) {
        int up=0;if(up_or_down>0)up=1;
        for (int i = 1; i <= movment; i++) {
            boolean can_move = true;
            if (cleaningdvice.getY() + up_or_down <= endof_y && cleaningdvice.getY() + up_or_down >= 0) {
                for (Dam dam : damList) {
                    if (dam.getFrom().getY() == dam.getTo().getY()) {
                        if (cleaningdvice.getY()+up == dam.getFrom().getY() && cleaningdvice.getX() >= dam.getFrom().getX() && cleaningdvice.getX() < dam.getTo().getX()) {
                            can_move = false;
                            break;
                        }
                    }
                }
            } else can_move = false;
            if (can_move) cleaningdvice.setY(cleaningdvice.getY()+up_or_down);
            else break;
        }
    }


    @Override
    public String go(String goCommandString) {
        String newcommand[]=goCommandString.replace(""["","""").replace(""]"","""").split("","");
        String direction=newcommand[0];
        int steps =Integer.parseInt(newcommand[1]);



        run_commend(direction,steps);
        return cleaningdvice.toString();
    }



}

package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String go(String goCommandString);
}

package thkoeln.st.st2praktikum.exercise;

public class Position {


    int x,y;

    public Position() {
    }

    public Position(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return x;
    }

    public void setX(int x) {
        this.x = x;
    }

    public int getY() {
        return y;
    }

    public void setY(int y) {
        this.y = y;
    }

    @Override
    public String toString() {
        return ""("" + x +"","" + y +')';
    }
}
",4694,175,33.474074074074075,174,0.0,0.05714285714285714,0.022857142857142857,0.005714285714285714,0.33714285714285713,0.0,0.18285714285714286,0.0,True,True,False,False,False,False,4,0.08,0.045714285714285714,0.08571428571428572,0.017142857142857144,0.38857142857142857,0.2742857142857143,0.011428571428571429,8.0,13,0.0,0
student132,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Walkable {

    private static final Integer startX = 3;
    private static final Integer startY = 0;
    //obstacles
    private static final String[] obstacles = {""(1,4)-(8,4)"", ""(3,0)-(3,3)"", ""(4,3)-(7,3)"", ""(7,0)-(7,2)""};
    private Integer x = startX;
    private Integer y = startY;

    @Override
    public String walkTo(String walkCommandString) {
        //Parse Command String
        String direction = parseCommandDirection(walkCommandString); //north, east, south, west
        Integer distance = parseCommandDistance(walkCommandString); //Integer

        return move(distance, direction);
    }


    private String parseCommandDirection(String walkCommandString) {
        if (walkCommandString.contains(""no"")) {
            return ""north"";
        } else if (walkCommandString.contains(""ea"")) {
            return ""east"";
        } else if (walkCommandString.contains(""so"")) {
            return ""south"";
        } else if (walkCommandString.contains(""we"")) {
            return ""west"";
        } else {
            return """";
        }
    }

    private Integer parseCommandDistance(String walkCommandString) {
        return Character.getNumericValue(walkCommandString.toCharArray()[4]);
    }

    private String move(Integer dis, String dir) {
        if (dis > 0) {
            switch (dir) {
                case ""north"":
                    if (canMove(dir)) this.y++;
                    break;
                case ""east"":
                    if (canMove(dir)) this.x++;
                    break;
                case ""south"":
                    if (canMove(dir)) this.y--;
                    break;
                case ""west"":
                    if (canMove(dir)) this.x--;
                    break;
            }
            return move(dis - 1, dir);
        } else {
            return ""("" + x + "","" + y + "")"";
        }
    }

    private Boolean canMove(String dir) {
        for (String s : obstacles) {
            char[] obstacle = s.toCharArray();
            Integer x1 = Character.getNumericValue(obstacle[1]);
            Integer x2 = Character.getNumericValue(obstacle[7]);
            Integer y1 = Character.getNumericValue(obstacle[3]);
            Integer y2 = Character.getNumericValue(obstacle[9]);

            if (x == 0 && dir.equals(""west"")) return false;
            if (y == 0 && dir.equals(""south"")) return false;
            if (x == 11 && dir.equals(""east"")) return false;
            if (y == 7 && dir.equals(""north"")) return false;

            if (x1.equals(x2) && y1 <= y && y < y2) {
                if (x.equals(x1) && dir.equals(""west"")) {
                    return false;
                } else if (x.equals(x1 - 1) && dir.equals(""east"")) {
                    return false;
                }
            } else if (y1.equals(y2) && x1 <= x && x < x2) {
                if (y.equals(y1) && dir.equals(""south"")) {
                    return false;
                } else if (y.equals(y1 - 1) && dir.equals(""north"")) {
                    return false;
                }
            }
        }

        return true;
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);
}
",3290,97,38.01190476190476,107,0.041237113402061855,0.1958762886597938,0.010309278350515464,0.010309278350515464,0.5257731958762887,0.0,0.12371134020618557,0.0,False,False,True,False,False,False,2,0.061855670103092786,0.05154639175257732,0.07216494845360824,0.010309278350515464,0.44329896907216493,0.3402061855670103,0.0,5.266666666666667,17,15.0,24
student134,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Walkable {

    /**
     * Initialisierung der Koordinaten des Roboters und
     * den Waenden.
     */

    private String robot_coordinates = ""5,3"";
    private int robot_x = Integer.parseInt(robot_coordinates.substring(0,1));
    private int robot_y = Integer.parseInt(robot_coordinates.substring(2));

    private String[] wall1_coordinates = {""1,6"",""2,6"",""3,6"",""4,6"",""5,6"",""6,6""};
    private String[] wall2_coordinates = {""6,8"",""6,7"",""6,6"",""6,5"",""6,4"",""6,3"",""6,2""};
    private String[] wall3_coordinates = {""3,3"",""4,3"",""5,3"",""6,3"",""7,3"",""8,3"",""9,3""};
    private String[] wall4_coordinates = {""4,1"",""4,2"",""4,3""};

    @Override

    /**
     * Methode walk:
     * Der Roboter bewegt sich abhaengig davon ob der Weg frei ist.
     * @param walkCommandString Der Befehl, wie der Roboter sich bewegen soll, wird uebergeben. (Richtung, Schrittanzahl)
     * @return robot_coordinates gibt den aktuellen Standpunkt des Roboters wieder.
     */

    public String walk(String walkCommandString) {


        // Der String Befehl wird aufgeteilt in 2 Strings:
        // Die Richtung ""direction"" und die Schrittanzahl ""steps""
        String direction = walkCommandString.substring(1,3);
        int steps = Integer.parseInt(walkCommandString.substring(4,5));

            switch (direction) {
                case ""no"": {
                    // For-Schleifen laeufen solange wie es Schritte gibt.
                    for (int i = 0; i < steps; i++) {
                        if (robot_y < 7) {
                            // Methode test wird aufgerufen und die Variable ""direction wird uebergeben""
                            if (test(direction) == true) {
                                robot_y++;
                            }
                        }
                    }
                    break;
                }

                case ""ea"": {
                    for (int i = 0; i < steps; i++) {
                        if (robot_x < 11) {
                            if (test(direction) == true) {
                                robot_x++;
                            }
                        }
                    }
                    break;
                }

                case ""so"": {
                    for (int i = 0; i < steps; i++) {
                        if (robot_y > 0) {
                            if (test(direction) == true) {
                                robot_y--;
                            }
                        }
                    }
                    break;
                }

                case ""we"": {
                    for (int i = 0; i < steps; i++) {
                        if (robot_x > 0) {
                            if (test(direction) == true) {
                                robot_x--;
                            }
                        }
                    }
                    break;
                }
            }
        // Konvertiert die Werte vom Typen Integer in die gewuenschte String Syntax um.
        robot_coordinates = ""("" + String.valueOf(robot_x) + "","" + String.valueOf(robot_y) + "")"";
        return robot_coordinates;
    }

    /**
     * Methode no:
     * Prueft ob in der Richtung Norden eine Wand existiert.
     * @param wall die Koordinaten der Wand werden uebergeben.
     * @return boolean 
     */

    public boolean no(String [] wall){
        
        // Zaehler der anfaengt zu zaehlen wenn ein Wandpunkt erreicht wird.
        int wall_counter = 0;

        for (int i = 0; i < wall.length; i++){
            // Prueft ob bei dem naechsten Schritt ein Wandpunkt vorhanden ist.
            if (wall[i].equals(robot_x + "","" + (robot_y + 1))){
                wall_counter++;
            }
            if (wall[i].equals((robot_x + 1) + "","" + (robot_y + 1))){
                wall_counter++;
            }
        }
        if(wall_counter == 2){
            return false;
        }
        return true;
    }

    /**
     * Methode so:
     * Prueft ob in der Richtung Sueden eine Wand existiert.
     * @param wall die Koordinaten der Wand werden uebergeben.
     * @return
     */
    public boolean so(String [] wall){

        int wall_counter = 0;
        for (int i = 0; i < wall.length; i++){
            if (wall[i].equals(robot_x + "","" + (robot_y))){
                wall_counter++;
            }
            if (wall[i].equals((robot_x + 1) + "","" + robot_y)){
                wall_counter++;
            }
        }
        if(wall_counter == 2){
            return false;
        }
        return true;
    }

    /**
     * Methode ea:
     * Prueft ob in der Richtung Osten eine Wand existiert.
     * @param wall
     * @return boolean
     */

    public boolean ea(String [] wall){

        int wall_counter = 0;
        String a = (robot_x + 1) + "","" + (robot_y + 1);
        String b = (robot_x + 1) + "","" + robot_y;
        for (int i = 0; i < wall.length; i++){
            if (wall[i].equals(a)){
                wall_counter++;
            }
            if (wall[i].equals(b)){
                wall_counter++;
            }
        }
        if(wall_counter == 2){
            return false;
        }
        return true;
    }

    /**
     * Methode we:
     * Prueft ob in der Richtung Westen eine Wand existiert.
     * @param wall
     * @return
     */

    public boolean we(String [] wall){

        int wall_counter = 0;
        for (int i = 0; i < wall.length; i++){
            if (wall[i].equals(robot_x + "","" + (robot_y + 1))){
                wall_counter++;
            }
            if (wall[i].equals(robot_coordinates)){
                wall_counter++;
            }
        }
        if(wall_counter == 2){
            return false;
        }
        return true;
    }

    /**
     * Methode no_so_ea_we:
     * @param wall
     * @param direction
     * @return
     */

    public boolean no_so_ea_we(String [] wall, String direction) {
        switch (direction) {
            case ""no"":
                if (no(wall) == false) return false;
                break;
            case ""so"":
                if (so(wall) == false) return false;
                break;
            case ""ea"":
                if (ea(wall) == false) return false;
                break;
            case ""we"":
                if (we(wall) == false) return false;
                break;
        }
        return true;
    }

    /**
     * Methode test:
     * @param direction
     * @return
     */

    public boolean test(String direction){

        if(no_so_ea_we(wall1_coordinates,direction) == false)
            return false;
        if(no_so_ea_we(wall2_coordinates,direction) == false)
            return false;
        if(no_so_ea_we(wall3_coordinates,direction) == false)
            return false;
        if(no_so_ea_we(wall4_coordinates,direction) == false)
            return false;
        return true;
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",7051,237,33.077669902912625,121,0.06329113924050633,0.12236286919831224,0.03375527426160337,0.008438818565400843,0.4050632911392405,0.0,0.12658227848101267,0.0,False,False,False,False,False,False,2,0.03375527426160337,0.029535864978902954,0.03375527426160337,0.004219409282700422,0.4177215189873418,0.12236286919831224,0.0,9.2,17,30.818181818181817,116
student135,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Barrier {
    private Vector2 start;
    private Vector2 end;
    private boolean isHorizontal;

    public Barrier(Vector2 _start, Vector2 _end) {
        if(_start.x == _end.x || _start.y == _end.y){
            start = _start;
            end = _end;
            isHorizontal = start.y == end.y;
        }
    }

    public boolean checkCross(Vector2 pos, Vector2 dir){
        if(isHorizontal && start.x <= pos.x && pos.x < end.x){
            if(pos.y < start.y && pos.add(dir).y >= start.y){
                return true;
            }
            else if(pos.y >= start.y && pos.add(dir).y <= start.y){
                return true;
            }
        }
        else if(!isHorizontal && start.y <= pos.y && pos.y < end.y){
            if(pos.x < start.x && pos.add(dir).x >= start.x){
                return true;
            }
            else if(pos.x >= start.x && pos.add(dir).x <= start.x){
                return true;
            }
        }
        return false;
    }

    public Vector2 limit(Vector2 pos){
        Vector2 res = pos.clone();
        if(isHorizontal){
            if(pos.y > start.y){
                res.y = start.y;
            }
            else{
                res.y = start.y-1;
            }
        }
        else{
            if(pos.x > start.x){
                res.x = start.x;
            }
            else{
                res.x = start.x-1;
            }
        }
        return res;
    }
}

package thkoeln.st.st2praktikum.exercise;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Exercise0 implements GoAble {

    Map map = new Map(new Vector2(0,2),
            new Vector2(12,9),
            new Barrier(new Vector2(3,0), new Vector2(3,3)),
            new Barrier(new Vector2(5,0), new Vector2(5,4)),
            new Barrier(new Vector2(4,5), new Vector2(7,5)),
            new Barrier(new Vector2(7,5), new Vector2(7,9))
            );

    public Exercise0(){

    }
    @Override
    public String go(String goCommandString) {
        Vector2 dir = decypher(goCommandString);
        Vector2 newPos = map.getPlayerPosition().add(dir);
        for(Barrier b: map.getBarriers()){
            if(b.checkCross(map.getPlayerPosition(),dir)){
                Vector2 possibleNewPos = b.limit(map.getPlayerPosition());
                if(possibleNewPos.clone().add(map.getPlayerPosition().multiply(-1)).length() < newPos.clone().add(map.getPlayerPosition().multiply(-1)).length()){
                    newPos = possibleNewPos;
                }
            }
        }
        if(newPos.x >= map.getDimensions().x){
            newPos.x = map.getDimensions().x-1;
        }
        else if(newPos.x < 0){
            newPos.x = 0;
        }
        if(newPos.y >= map.getDimensions().y){
            newPos.y = map.getDimensions().y-1;
        }
        else if(newPos.y < 0){
            newPos.y = 0;
        }
        map.setPlayerPosition(newPos);
        return map.getPlayerPosition().toString();
    }

    public Vector2 decypher(String s){
        Vector2 dir = new Vector2(0,0);
        Pattern p = Pattern.compile(""\\[(so|we|no|ea),\\d+]"");
        Matcher m = p.matcher(s);
        if(m.matches()){
            p = Pattern.compile(""(so|no|ea|we)"");
            Matcher a = p.matcher(s);
            a.find();
            switch(a.group()){
                case ""no"":
                    dir.y += 1;
                    break;
                case ""ea"":
                    dir.x += 1;
                    break;
                case ""so"":
                    dir.y -= 1;
                    break;
                case ""we"":
                    dir.x -= 1;
                    break;
            }

            p = Pattern.compile(""\\d+"");
            a = p.matcher(s);
            a.find();
            dir.multiply(Integer.parseInt(a.group()));
        }
        return dir;
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String go(String goCommandString);
}

package thkoeln.st.st2praktikum.exercise;

import java.util.ArrayList;

public class Map {
    private Vector2 player;
    private Vector2 dimensions;
    private ArrayList<Barrier> barriers = new ArrayList<Barrier>();

    public Map(Vector2 player, Vector2 dimensions, Barrier... barriers){
        this.player = player;
        this.dimensions = dimensions;
        for(Barrier b: barriers){
            this.barriers.add(b);
        }
    }

    public Vector2 getPlayerPosition(){
        return player.clone();
    }

    public void setPlayerPosition(Vector2 pos){
        player.x = pos.x;
        player.y = pos.y;
    }

    public Vector2 getDimensions(){
        return dimensions.clone();
    }

    public ArrayList<Barrier> getBarriers(){
        return (ArrayList<Barrier>) barriers.clone();
    }

    public void addBarrier(Barrier b){
        barriers.add(b);
    }

    public void addBarrier(Vector2 start, Vector2 end) throws Exception {
        barriers.add(new Barrier(start, end));
    }


}

package thkoeln.st.st2praktikum.exercise;

public class Vector2 {
    int x, y;
    Vector2(int _x, int _y){
        x = _x;
        y = _y;
    }

    public Vector2 add(Vector2 c){
        x += c.x;
        y += c.y;
        return this;
    }

    public Vector2 multiply(int skalar){
        x *= skalar;
        y *= skalar;
        return this;
    }

    public Vector2 clone(){
        return new Vector2(this.x, this.y);
    }

    @Override
    public String toString() {
        return ""("" + x + ',' + y + ')';
    }

    public double length(){
        return Math.sqrt(x*x + y*y);
    }
}
",5668,220,29.13368983957219,162,0.0,0.07727272727272727,0.00909090909090909,0.004545454545454545,0.38636363636363635,0.0,0.14545454545454545,0.0,True,False,False,False,True,False,5,0.07272727272727272,0.04090909090909091,0.03636363636363636,0.01818181818181818,0.5363636363636364,0.22727272727272727,0.013636363636363636,4.129032258064516,15,0.0,0
student137,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements GoAble {
    int startY = 7;
    int startX = 11;
    @Override
    public String goTo(String goCommandString) {
        // throw new UnsupportedOperationException();

        String direction = goCommandString.substring(1,3); // substring the incoming value for direction
        int amount = Integer.parseInt(goCommandString.substring(4,5)); // substring incoming value for moving amount

        // define raster with bounds
        int  [][] lab = new int [8][12]; // define array size
        // define the blocked directions per field
        int  [] WEarray = {1, 5, 8, 9, 11, 12};
        int  [] NOarray = {2, 5, 6, 9, 10, 12};
        int  [] EAarray = {3, 6, 7, 9, 10, 11};
        int  [] SOarray = {4, 7, 8, 10, 11, 12};
        // fill entire array with 0
        for(int y = 0; y <8; y++) {
            for(int x = 0; x < 12; x++){
                lab[y][x] = 0;
            }
        }
        // fill outer barrier
        for(int x = 1; x <11; x++) {
            lab[0][x] = 4;
        }
        for(int x = 1; x <11; x++) {
            lab[7][x] = 2;
        }
        for(int y = 1; y <7; y++) {
            lab[y][0] = 1;
        }
        for(int y = 1; y <7; y++) {
            lab[y][11] = 3;
        }
        // fill outer corner barrier
        lab[0][0] = 8;
        lab[0][11] = 7;
        lab[7][0] = 5;
        lab[7][11] = 6;

        // define specific barriers inside the raster
        for(int x = 5; x <11; x++) {
            lab[6][x] = 4;
        }
        for(int x = 6; x <11; x++) {
            lab[5][x] = 2;
        }
        for(int y = 2; y <5; y++) {
            lab[y][6] = 1;
        }
        for(int y = 2; y <4; y++) {
            lab[y][5] = 3;
        }
        lab[5][5] = 12;
        lab[4][5] = 6;
        lab[5][4] = 3;
        lab[6][11] = 7;
        lab[5][11] = 6;

        // switch case to move depending on direction
        // first checking current field value to decide if movement in direction is possible.
        // moving one field in direction and checking for next movement
        // movement aborts on hitting any barrier, stays in current position and continues with direction change for another movement test
        switch (direction) {

            case ""we"" : outerloop:
                        for (int m = 0; m < amount; m++) { // itterate in single steps for every move
                            for (int i : WEarray) { // check for every step if movement in direction is possible
                                if (lab[startY][startX] == i) { // if movement is not possible in desired direction, abort action
                                    break outerloop; // abort outer loop
                                }
                            }
                            startX = startX - 1; // if movement is possible, continue by one value (in this case negative x) and repeat loop
                        }
                        break;

            case ""no"" : outerloop:
                        for (int m = 0; m < amount; m++) { // see documentation for ""we"" movement
                            for (int i : NOarray) {
                                if (lab[startY][startX] == i) {
                                    System.out.println();
                                    break outerloop;
                                }
                            }
                            startY = startY + 1;
                        }
                            break;

            case ""ea"" : outerloop:
                        for (int m = 0; m < amount; m++) { // see documentation for ""we"" movement
                            for (int i : EAarray) {
                                if (lab[startY][startX] == i) {
                                    break outerloop;
                                }
                            }
                            startX = startX + 1;
                        }
                            break;

            case ""so"" : outerloop:
                        for (int m = 0; m < amount; m++) { // see documentation for ""we"" movement
                            for (int i : SOarray) {
                                if (lab[startY][startX] == i) {
                                    break outerloop;
                                }
                            }
                            startY = startY - 1;
                        }
                            break;
        }

        //test output of outta bounds
/*
        for(int y = 7; y>=0; y--) {
            for(int x = 0; x < 12; x++){
                System.out.print(lab[y][x] + ""  "");
            }
            System.out.println();
        }
        System.out.println();

 */

        return ""("" + startX + "",""  + startY + "")"";
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface GoAble {

    String goTo(String goCommandString);

}
",4945,138,39.40163934426229,140,0.17391304347826086,0.06521739130434782,0.21014492753623187,0.014492753623188406,0.9782608695652174,0.007246376811594203,0.11594202898550725,0.028985507246376812,False,False,False,False,False,False,2,0.014492753623188406,0.014492753623188406,0.050724637681159424,0.007246376811594203,0.6594202898550725,0.028985507246376812,0.0,4.769230769230769,9,37.25806451612903,127
student138,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements GoAble {
    int posx = 4;
    int posy = 7;
    int[][] cord = {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 2, 2, 2, 0, 2, 2, 0, 0, 0, 0},
            {0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0},
            {0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0},
            {0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0},
            {0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0},
            {0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0},
            {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0}};
    @Override
    public String goTo(String goCommandString) {
        String[] commands = goCommandString.split("","");
        String direction = commands[0].replace(""["", """");
        int amount = Integer.parseInt(commands[1].replace(""]"", """"));

        int u = cord[7][4];
        for (int i = 0; i < amount; i++)
        {
            switch (direction)
            {
                case ""no"":
                    if (posy != 0)
                    {
                        if (cord[posy - 1][posx] != 2)
                            posy--;
                    }
                    break;
                case ""ea"":
                    if (posx != 10)
                    {
                        if (cord[posy][posx + 1] != 1)
                            posx++;
                    }
                    break;
                case ""so"":
                    if (posy != 7)
                    {
                        if (cord[posy][posx] != 2)
                            posy++;
                    }
                    break;
                case ""we"":
                    if (posx != 0)
                    {
                        if (cord[posy][posx] != 1)
                            posx--;
                    }
                    break;
            }
        }

        return ""("" + posx + "","" + (7 - posy) + "")"";
    }

    public static void main(String[] args){
        Exercise0 ex =  new Exercise0();
        String res = ex.goTo(""[no,5]"");
        res = ex.goTo(""[we,3]"");
        res = ex.goTo(""[so,2]"");
        res = ex.goTo(""[ea,1]"");

    }
}

package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String goTo(String goCommandString);
}
",2209,74,31.865671641791046,68,0.0,0.10810810810810811,0.013513513513513514,0.013513513513513514,1.5675675675675675,0.0,0.0945945945945946,0.0,False,False,False,False,False,False,2,0.04054054054054054,0.04054054054054054,0.08108108108108109,0.013513513513513514,0.43243243243243246,0.10810810810810811,0.0,4.875,9,0.0,0
student140,student,,,"package thkoeln.st.st2praktikum.exercise;


public class Exercise0 implements GoAble {
    static String[][] grid = new String[11][8];
    int positionX = 1;
    int positionY = 6;

    public static void initialize() {
        grid[0][6] = ""horizontal"";
        grid[1][6] = ""horizontal"";

        grid[3][6] = ""vertical"";
        grid[3][7] = ""vertical"";

        grid[1][5] = ""horizontal"";
        grid[2][5] = ""horizontal"";
        grid[3][5] = ""horizontal"";
        grid[4][5] = ""horizontal"";
        grid[5][5] = ""horizontal"";
        grid[6][5] = ""horizontal"";
        grid[7][5] = ""horizontal"";
        grid[8][5] = ""horizontal"";

        grid[9][1] = ""vertical"";
        grid[9][2] = ""vertical"";
        grid[9][3] = ""vertical"";
        grid[9][4] = ""vertical"";
    }

    @Override
    public String go(String goCommandString) {
        initialize();

        String direction = """";
        String commandStart = """";
        String commandEnd = """";

        String[] stringSplit = goCommandString.split("","");

        if(stringSplit.length > 1) {
        direction = stringSplit[0].substring(1);
        commandStart = stringSplit[0].substring(0,1);


            commandEnd = stringSplit[1].substring(stringSplit[1].length() - 1);
        }


        if(commandStart.equals(""["") && commandEnd.equals(""]"")) {

            int count;
            try {
                count = Integer.parseInt(stringSplit[1].substring(0, stringSplit[1].length() - 1));
            } catch (NumberFormatException e) {
                count = 0;
            }


            switch (direction) {
                case ""no"":
                    if (count >= 0) {
                        for (int counter = 0; counter < count; counter++) {
                            if (positionY + 1 < grid[1].length) {
                                if (grid[positionX][positionY + 1] == null || grid[positionX][positionY + 1] == ""vertical"") {
                                    positionY += 1;
                                } else if (grid[positionX][positionY + 1] == ""horizontal"") {
                                    break;
                                }
                            } else break;
                        }
                    } else if (count < 0) {
                        count *= -1;
                        go(""[so"" + "","" + count + ""]"");
                    }
                    break;

                case ""ea"":
                    if (count >= 0) {
                        for (int counter = 0; counter < count; counter++) {
                            if (positionX + 1 < grid.length) {
                                if (grid[positionX + 1][positionY] == null || grid[positionX + 1][positionY] == ""horizontal"") {
                                    positionX += 1;
                                } else if (grid[positionX + 1][positionY] == ""vertical"") {
                                    break;
                                }
                            } else break;
                        }
                    } else if (count < 0) {
                        count *= -1;
                        go(""[we"" + "","" + count + ""]"");
                    }
                    break;
                case ""so"":
                    if (count >= 0) {
                        if (grid[positionX][positionY] != ""horizontal"") {
                            for (int counter = 0; counter < count; counter++) {
                                if (positionY - 1 >= 0) {
                                    if (grid[positionX][positionY - 1] == null || grid[positionX][positionY - 1] == ""vertical"") {
                                        positionY -= 1;
                                    } else if (grid[positionX][positionY - 1] == ""horizontal"") {
                                        positionY -= 1;
                                        break;
                                    }
                                } else break;
                            }
                        }
                    } else if (count < 0) {
                        count *= -1;
                        go(""[no"" + "","" + count + ""]"");
                    }
                    break;
                case ""we"":
                    if (count >= 0) {
                        if (grid[positionX][positionY] != ""vertical"") {
                            for (int counter = 0; counter < count; counter++) {
                                if (positionX - 1 >= 0) {
                                    if (grid[positionX - 1][positionY] == null || grid[positionX - 1][positionY] == ""horizontal"") {
                                        positionX -= 1;
                                    } else if (grid[positionX - 1][positionY] == ""vertical"") {
                                        positionX -= 1;
                                        break;
                                    }
                                } else break;
                            }
                        }
                    } else if (count < 0) {
                        count *= -1;
                        go(""[ea"" + "","" + count + ""]"");
                    }
                    break;
            }

        }
        return ""("" + positionX + "","" + positionY + "")"";
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String go(String goCommandString);
}",5371,142,42.868852459016395,131,0.0,0.16901408450704225,0.028169014084507043,0.007042253521126761,0.6690140845070423,0.0,0.11267605633802817,0.0,False,False,False,False,False,False,2,0.02112676056338028,0.02112676056338028,0.035211267605633804,0.007042253521126761,0.8028169014084507,0.1056338028169014,0.0,8.2,12,0.0,0
student142,student,,,"package thkoeln.st.st2praktikum.exercise;

public class  Exercise0 implements GoAble {

    int X_MAX = 12;
    int Y_MAX = 9;

    int xDroid = 0;
    int yDroid = 0;


    class Obstacle{
        boolean North = false;
        boolean South = false;
        boolean East = false;
        boolean West = false;
    }

    public Exercise0(){
        InitializeDeck();
    }

    public static void main(String[] args){
        Exercise0 ex = new Exercise0();
        System.out.println(ex.goTo(""[so,5]""));
        System.out.println(ex.goTo(""[ea,5]""));
        System.out.println(ex.goTo(""[so,4]""));
        System.out.println(ex.goTo(""[no,5]""));
    }

    Obstacle [][] obstaclesInDeck = new Obstacle[X_MAX][Y_MAX];

    public enum Direction{
        North, South, East, West, None
    }

    void goToDirection(Direction d, int steps){

        if (steps <= 0)
            return;

        int newX = xDroid;
        int newY = yDroid;

        switch (d){
            case North:
                newY = newY +1;
                break;
            case South:
                newY = newY-1;
                break;
            case East:
                newX = newX +1;
                break;
            case West:
                newX = newX-1;
                break;
        }

        if (newX < 0 || newX >= X_MAX || newY < 0 || newY >= Y_MAX)
            return;

        boolean obstacleExists = false;

        switch  (d){
            case North:
                obstacleExists = obstaclesInDeck[xDroid][yDroid].North ||
                        obstaclesInDeck[newX][newY].South;
                break;
            case South:
                obstacleExists = obstaclesInDeck[xDroid][yDroid].South ||
                        obstaclesInDeck[newX][newY].North;
                break;

            case West:
                obstacleExists = obstaclesInDeck[xDroid][yDroid].West ||
                        obstaclesInDeck[newX][newY].East;
                break;

            case East:
                obstacleExists = obstaclesInDeck[xDroid][yDroid].East ||
                        obstaclesInDeck[newX][newY].West;
                break;
        }
        if (!obstacleExists){
            xDroid = newX;
            yDroid = newY;
            goToDirection(d, steps-1);
        }else{
            // obstacle found. exit
        }
    }

    void InitializeDeck(){
        xDroid = 1;
        yDroid = 7;

        for( int i = 0; i < X_MAX; i++)
            for( int j = 0; j < Y_MAX; j++)
                obstaclesInDeck[i][j] = new Obstacle();



        for( int j = 3; j < Y_MAX; j++)
            obstaclesInDeck[3][j].West = true;

        obstaclesInDeck[3][2].North = true;
        obstaclesInDeck[4][2].North = true;

        obstaclesInDeck[4][0].East = true;
        obstaclesInDeck[4][1].East = true;

        obstaclesInDeck[5][0].East = true;
        obstaclesInDeck[5][1].East = true;
        obstaclesInDeck[5][2].East = true;
        obstaclesInDeck[5][3].East = true;

    }

    @Override
    public String goTo(String goCommandString) {
        boolean found = false;
        goCommandString = goCommandString.toLowerCase();
        String dirString = """";
        String stepString = """";

        int indexBrakeLeft = goCommandString.indexOf(""["");
        if (indexBrakeLeft >=0){
            int indexComma = goCommandString.indexOf("","", indexBrakeLeft + 1);
            if (indexComma >= 0){
                dirString = goCommandString.substring(indexBrakeLeft +1, indexComma);
                int indexBrakeRight = goCommandString.indexOf(""]"", indexComma+1);
                if (indexBrakeRight >= 0){
                    stepString = goCommandString.substring(indexComma + 1, indexBrakeRight);
                    found = true;
                }
            }
        }

        if (found){
            Direction d = Direction.None;
            switch(dirString){
                case ""no"": d = Direction.North; break;
                case ""ea"": d = Direction.East; break;
                case ""so"": d = Direction.South; break;
                case ""su"": d = Direction.South; break;
                case ""we"": d = Direction.West; break;
            }
            int steps = Integer.parseInt(stepString);
            goToDirection(d,steps);
        }

        String newPosition = ""("" + xDroid + "","" + yDroid + "")"";
        return newPosition;

    }

}


package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String goTo(String goCommandString);
}
",4506,165,33.651162790697676,92,0.006060606060606061,0.04242424242424243,0.01818181818181818,0.01818181818181818,0.3151515151515151,0.0,0.2,0.024242424242424242,True,False,False,False,False,False,2,0.030303030303030304,0.05454545454545454,0.07878787878787878,0.012121212121212121,0.7818181818181819,0.10909090909090909,0.0,7.12,15,20.0,20
student143,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Walkable {

    enum Direction {NORTH, SOUTH, EAST, WEST};
    class Coordinate {
        public int x;
        public int y;
        public Coordinate(int x, int y){this.x = x; this.y = y;}
        @Override
        public String toString() { return ""("" + x + "","" + y + ')'; }
    }

    class Wall {
        public Coordinate start;
        public Coordinate end;
        public Wall(Coordinate start, Coordinate end){this.start = start; this.end = end;}
    }

    Wall [] walls;
    Coordinate miningMachine;

    // little helper function to look if the mining machine
    // is at the same level as a wall
    private boolean between(int i, int first, int second) {
        int min = Integer.min(first,second);
        int max = Integer.max(first,second);
        return  (i >= min && i < max) ;
    }

    private void moveMachine(Direction direction, int steps){

        // movement boundaries for the mining machine
        int maxRight = Integer.MAX_VALUE;
        int maxLeft = Integer.MIN_VALUE;
        int maxTop = Integer.MAX_VALUE;
        int maxBottom = Integer.MIN_VALUE;

        // get the smallest bound
        for(Wall wall : walls){
            // if there is a wall at the same ground area
            if(between(miningMachine.x,wall.end.x,wall.start.x)){
                // get the vertical distance
                int distance = wall.start.y - miningMachine.y;
                if(distance > 0){ // wall at the top
                    distance--; // correction due to coordinate at bottom left corner
                    if(distance < maxTop){ maxTop = distance;}
                } else {  // wall at bottom
                    if(distance > maxBottom){maxBottom = distance;}
                }
            }
            // if there is a wall at the same height
            if(between(miningMachine.y,wall.end.y, wall.start.y)){
                int distance = wall.start.x - miningMachine.x;
                if(distance > 0){ // wall at right
                    distance--; // correction due to coordinate at bottom left corner
                    if(distance < maxRight){maxRight=distance;}
                } else {
                    if(distance > maxLeft){maxLeft=distance;}
                }
            }
        }

        // do the steps for the mining machine
        switch (direction){
            case NORTH:
                int stepsUp = Integer.min(maxTop,steps);
                miningMachine.y += stepsUp;
                break;
            case EAST:
                int stepsRight = Integer.min(maxRight,steps);
                miningMachine.x += stepsRight;
                break;
            case WEST:
                int stepsLeft = Integer.min(-maxLeft,steps);
                miningMachine.x -= stepsLeft;
                break;
            case SOUTH:
                int stepsDown = Integer.min(-maxBottom,steps);
                miningMachine.y -= stepsDown;
        }
    }

    public Exercise0() {
        miningMachine = new Coordinate(11,7);
        walls = new Wall [] {
                // boundaries
                new Wall(new Coordinate(0,0), new Coordinate(12,0)),  // bottom
                new Wall(new Coordinate(0, 8), new Coordinate(12,8)), // top
                new Wall(new Coordinate(0,0), new Coordinate(0,8)),   // left
                new Wall(new Coordinate(12,0), new Coordinate(12,8)), // right

                // normal walls
                new Wall(new Coordinate(6,2), new Coordinate(6,5)),
                new Wall(new Coordinate(5,5), new Coordinate(6,5)),
                new Wall(new Coordinate(5,5), new Coordinate(5,6)),
                new Wall(new Coordinate(5,6), new Coordinate(12,6))
        };
    }



    @Override
    public String walkTo(String walkCommandString) {

        // parse string somehow
        // get steps
        int steps = Integer.parseInt(walkCommandString.replaceAll(""[^0-9]"",""""));
        // get direction
        Direction direction;
        String str = walkCommandString.replaceAll(""[\\[|\\]|0-9]|\\,"","""");
        if(str.equals(""we"")){ direction = Direction.WEST;}
        else if(str.equals(""no"")){direction = Direction.NORTH;}
        else if(str.equals(""so"")){direction = Direction.SOUTH;}
        else if(str.equals(""ea"")){direction = Direction.EAST;}
        else { throw new IllegalArgumentException(""couldn't parse string argument for walkTo""); }

        // do the movement
        moveMachine(direction,steps);

        return miningMachine.toString();
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);
}
",4693,129,41.49090909090909,97,0.17829457364341086,0.11627906976744186,0.031007751937984496,0.007751937984496124,0.3875968992248062,0.007751937984496124,0.13953488372093023,0.0,False,False,False,False,False,False,2,0.03875968992248062,0.046511627906976744,0.11627906976744186,0.023255813953488372,0.6356589147286822,0.13178294573643412,0.0,6.035714285714286,13,22.782608695652176,52
student144,student,,,"package thkoeln.st.st2praktikum.exercise;
import java.util.Arrays;
public class Exercise0 implements GoAble {
    Integer startUpDown = 2;
    Integer startLeftRight = 0;

    public Integer change(Integer anderungswert,Integer upDownOrLeftRight){
        if(anderungswert == 0){
            anderungswert = upDownOrLeftRight;
        }
        return anderungswert;
    }
    public Integer wallCheck(Integer startUpDown,Integer startLeftRight,Integer newLeftRight,Integer newUpDown){
        Integer anderungswert;
        anderungswert = 0;
        //Section1 Begin
        if(startLeftRight<=2 && startUpDown<=2){
            if(newLeftRight>2){
                anderungswert = 2;
            }
        }
        //Section1 End
        //Section2 Begin
        if(startLeftRight<=4 && startLeftRight >=3 && startUpDown<=2){
            if(newLeftRight<3){
                anderungswert=3;
            }
            if(newLeftRight>4){
                anderungswert=4;
            }
        }
        //Section2 End
        //Section3 Begin
        if(startLeftRight>=5&&startUpDown<=3){
            if(newLeftRight<5){
                anderungswert=5;
            }
        }
        //Section3 End
        //Section4 Begin
        if(startLeftRight>=7&&startUpDown>=5){
            if(newLeftRight<7){
                anderungswert=7;
            }
        }
        //Section4 End
        //Section5 Begin
        if(startLeftRight<=4&&startUpDown==3){
            if(newLeftRight>4){
                anderungswert=4;
            }
        }
        //Section5 End
        //Section6 Begin
        if(startLeftRight<=6&&startUpDown>=5){
            if(newLeftRight>6){
                anderungswert=6;
            }
            if(startLeftRight>=4){
                if(newUpDown<5&&newLeftRight==0){
                    anderungswert=5;
                }
            }
        }
        //Section6 End
        //Section7 Begin
        if(startLeftRight>=4&&startLeftRight<=6&&startUpDown<=4){
            if(newUpDown>4){
                anderungswert=4;
            }
        }
        return anderungswert ;
    }

    public Integer findAmount(String goCommandString){
        if(goCommandString.substring(5,6).equals(""]"")){
            return Integer.parseInt(goCommandString.substring(4,5));
        }
        if(goCommandString.substring(7,7).equals(""]"")){
            return Integer.parseInt(goCommandString.substring(4,7));
        }
        else{
            return Integer.parseInt(goCommandString.substring(4,6));
        }
    }

    @Override
    public String go(String goCommandString) {
        Integer newUpDown,newLeftRight,amount,upDown,leftRight,maxUpDown, minUpDown,maxLeftRight,minLeftRight;
        String direction,finish;

        direction = goCommandString.substring(1,3);
        amount = findAmount(goCommandString);
        upDown = startUpDown;
        leftRight = startLeftRight;
        maxLeftRight = 11;
        maxUpDown = 8;
        minLeftRight = 0;
        minUpDown = 0;
        newLeftRight = 0;
        newUpDown = 0;

        if(direction.equals(""no"")||direction.equals(""ea"")){
            if(direction.equals(""no"")){
                newUpDown = amount + upDown;
                newUpDown = change(wallCheck(startUpDown,startLeftRight,newLeftRight,newUpDown),newUpDown);
                if(newUpDown>maxUpDown){
                    newUpDown = maxUpDown;
                }
                if(newUpDown<minUpDown){
                    newUpDown = minUpDown;
                }
                startUpDown = newUpDown;
            }
            else{
                newLeftRight = amount+leftRight;
                newLeftRight = change(wallCheck(startUpDown,startLeftRight,newLeftRight,newUpDown),newLeftRight);
                if(newLeftRight>maxLeftRight){
                    newLeftRight = maxLeftRight;
                }
                if(newLeftRight<minLeftRight){
                    newLeftRight = minLeftRight;
                }
                startLeftRight = newLeftRight;
            }
        }
        if(direction.equals(""so"")||direction.equals(""we"")){
            if(direction.equals(""so"")){
                newUpDown = upDown - amount;
                if(newUpDown<0){
                    newUpDown = 0;
                }
                newUpDown = change(wallCheck(startUpDown,startLeftRight,newLeftRight,newUpDown),newUpDown);
                if(newUpDown<minUpDown){
                    newUpDown = minUpDown;
                }
                startUpDown = newUpDown;
            }
            else{
                newLeftRight = leftRight - amount;
                if(newLeftRight<0){
                    newLeftRight = 0;
                }
                newLeftRight = change(wallCheck(startUpDown,startLeftRight,newLeftRight,newUpDown),newLeftRight);
                if(newLeftRight<minLeftRight){
                    newLeftRight = minLeftRight;
                }
                startLeftRight = newLeftRight;
            }
        }
        finish = ""(""+startLeftRight+"",""+startUpDown+"")"";
        return finish;
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String go(String goCommandString);
}
",5215,160,33.03921568627451,113,0.08125,0.2,0.0,0.0,0.49375,0.0,0.04375,0.0,False,False,True,False,False,False,2,0.03125,0.0125,0.075,0.00625,0.81875,0.1625,0.00625,10.5625,17,13.076923076923077,14
student145,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements GoAble {

    int x, y;
    int rechts = 1;
    int hoch = 6;
    int[][] board;


    @Override
    public String goTo(String goCommandString) {


        board = new int[rechts][hoch];


        String c = String.valueOf(goCommandString.charAt(4));
        int a = Integer.valueOf(c);
        String b = String.valueOf(goCommandString.charAt(1));

        if (b.equals(""n"")) {
            if (this.rechts == 0) {
                if (this.hoch == 5){if(a > 0){this.hoch=5;}}
                else if (this.hoch == 4){if(a >= 1){this.hoch=5;}}
                else if (this.hoch == 3){if(a >= 2) { this.hoch = 5;}}
                else if (this.hoch == 2){if(a >= 3){this.hoch = 5;}}
                else if (this.hoch == 1){if(a >= 4){this.hoch = 5;}}
                else if (this.hoch == 0){if(a >= 5){this.hoch = 5;}}
                else {
                    this.hoch = hoch + a;
                }}

            else if (this.rechts == 1){
                if(this.hoch == 5){if (a >= 0){this.hoch = 5;}}
                else {
                    this.hoch = hoch + a;
                }}
            else if (this.rechts == 1){
                if(this.hoch == 4){if(a >= 0){this.hoch = 4;}}
                else if (this.hoch == 3){if (a >= 1){this.hoch = 4;}}
                else if (this.hoch == 2){if (a >= 2){this.hoch = 4;}}
                else if (this.hoch == 1){if (a >= 3){this.hoch = 4;}}
                else if (this.hoch == 0){if (a >= 4){this.hoch = 4;}}
                else {
                    this.hoch = hoch + a;
                }}
            else if (this.rechts == 2){
                if(this.hoch == 4){if(a > 0){this.hoch = 4;}}
                else if (this.hoch == 3){if (a >= 1){this.hoch = 4;}}
                else if (this.hoch == 2){if (a >= 2){this.hoch = 4;}}
                else if (this.hoch == 1){if (a >= 3){this.hoch = 4;}}
                else if (this.hoch == 0){if (a >= 4){this.hoch = 4;}}
                else {
                    this.hoch = hoch + a;
                }}
            else if (this.rechts == 3){
                if(this.hoch == 4){if(a > 0){this.hoch = 4;}}
                else if (this.hoch == 3){if (a >= 1){this.hoch = 4;}}
                else if (this.hoch == 2){if (a >= 2){this.hoch = 4;}}
                else if (this.hoch == 1){if (a >= 3){this.hoch = 4;}}
                else if (this.hoch == 0){if (a >= 4){this.hoch = 4;}}
                else {
                    this.hoch = hoch + a;
                }}
            else if (this.rechts == 4){
                if(this.hoch == 4){if(a > 0){this.hoch = 5;}}
                else if (this.hoch == 3){if (a >= 1){this.hoch = 4;}}
                else if (this.hoch == 2){if (a >= 2){this.hoch = 4;}}
                else if (this.hoch == 1){if (a >= 3){this.hoch = 4;}}
                else if (this.hoch == 0){if (a >= 4){this.hoch = 4;}}
                else {
                    this.hoch = hoch + a;
                }}
            else if (this.rechts == 5){
                if(this.hoch == 4){if(a > 0){this.hoch = 5;}}
                else if (this.hoch == 3){if (a >= 1){this.hoch = 4;}}
                else if (this.hoch == 2){if (a >= 2){this.hoch = 4;}}
                else if (this.hoch == 1){if (a >= 3){this.hoch = 4;}}
                else if (this.hoch == 0){if (a >= 4){this.hoch = 4;}}
                else {
                    this.hoch = hoch + a;
                }}
            else if (this.rechts == 6){
                if(this.hoch == 4){if(a > 0){this.hoch = 5;}}
                else if (this.hoch == 3){if (a >= 1){this.hoch = 4;}}
                else if (this.hoch == 2){if (a >= 2){this.hoch = 4;}}
                else if (this.hoch == 1){if (a >= 3){this.hoch = 4;}}
                else if (this.hoch == 0){if (a >= 4){this.hoch = 4;}}
                else {
                    this.hoch = hoch + a;
                }}
            else if (this.rechts == 7){
                if(this.hoch == 4){if(a >= 0){this.hoch = 4;}}
                else if (this.hoch == 3){if (a >= 1){this.hoch = 4;}}
                else if (this.hoch == 2){if (a >= 2){this.hoch = 4;}}
                else if (this.hoch == 1){if (a >= 3){this.hoch = 4;}}
                else if (this.hoch == 0){if (a >= 4){this.hoch = 4;}}
                else {
                    this.hoch = hoch + a;
                }}
            else if (this.rechts == 8){
                if(this.hoch == 4){if(a >= 0){this.hoch = 4;}}
                else if (this.hoch == 3){if (a >= 1){this.hoch = 4;}}
                else if (this.hoch == 2){if (a >= 2){this.hoch = 4;}}
                else if (this.hoch == 1){if (a >= 3){this.hoch = 4;}}
                else if (this.hoch == 0){if (a >= 4){this.hoch = 4;}}
                else {
                    this.hoch = hoch + a;
                }}

            else {
                this.hoch = hoch + a;
            }
            if (this.hoch >= 7) {
                this.hoch = 7; }}

        if (b.equals(""s"")) {
            if (this.rechts == 0) {
                if (this.hoch == 7) { if (a >= 1) { this.hoch = 6; } }
                else if (this.hoch == 6) { if (a >= 0) { this.hoch = 6; } }
                else {
                    this.hoch = hoch - a;
                }}
            else if (this.rechts == 1) {
                if (this.hoch == 7) { if (a >= 1) { this.hoch = 6; } }
                else if (this.hoch == 6) { this.hoch = 6; }
                else if (this.hoch == 5) { this.hoch = 5; }
                else {
                    this.hoch = hoch - a;
                }}
            else if (this.rechts == 2) {
                if (this.hoch == 7) { if (a >= 2) { this.hoch = 5; } }
                else if (this.hoch == 6){if (a >= 1) { this.hoch = 5; } }
                else if (this.hoch == 5){if (a >= 0){this.hoch = 5;}}
                else {
                    this.hoch = hoch - a;
                }}
            else if (this.rechts == 3) {
                if (this.hoch == 7) { if (a >= 2) { this.hoch = 5; } }
                else if (this.hoch == 6) { if (a >= 1) { this.hoch = 5; } }
                else if (this.hoch == 5) { if (a >= 0) { this.hoch = 5; } }
                else {
                    this.hoch = hoch - a;
                }}
            else if (this.rechts == 4) {
                if (this.hoch == 7) { if (a >= 2) { this.hoch = 5; } }
                else if (this.hoch == 6) { if (a >= 1) { this.hoch = 5; } }
                else if (this.hoch == 5) { if (a >= 0) { this.hoch = 5; } }
                else {
                    this.hoch = hoch - a;
                }}
            else if (this.rechts == 5) {
                if (this.hoch == 7) { if (a >= 2) { this.hoch = 5; } }
                else if (this.hoch == 6) { if (a >= 1) { this.hoch = 5; } }
                else if (this.hoch == 5) { if (a >= 0) { this.hoch = 5; } }
                else {
                    this.hoch = hoch - a;
                }}
            else if (this.rechts == 6) {
                if (this.hoch == 7) { if (a >= 2) { this.hoch = 5; } }
                else if (this.hoch == 6) { if (a >= 1) { this.hoch = 5; } }
                else if (this.hoch == 5) { if (a >= 0) { this.hoch = 5; } }
                else {
                    this.hoch = hoch - a;
                }}
            else if (this.rechts == 7) {
                if (this.hoch == 7) { if (a >= 2) { this.hoch = 5; } }
                else if (this.hoch == 6) { if (a >= 1) { this.hoch = 5; } }
                else if (this.hoch == 5) { if (a >= 0) { this.hoch = 5; } }
                else {
                    this.hoch = hoch - a;
                }}
            else if (this.rechts == 8) {
                if (this.hoch == 7) { if (a >= 2) { this.hoch = 5; } }
                else if (this.hoch == 6) { if (a >= 1) { this.hoch = 5; } }
                else if (this.hoch == 5) { if (a >= 0) { this.hoch = 5; } }
                else {
                    this.hoch = hoch - a;
                }}
            else {
                this.hoch = hoch - a;
            }
            if (this.hoch <= 0) {
                this.hoch = 0;
            }
        }

        if (b.equals(""e"")) {
            if(this.rechts==0) {
                if(this.hoch== 1){if(a >= 8){this.rechts = 8;}}
                if(this.hoch== 2){if(a >= 8){this.rechts = 8;}}
                if(this.hoch== 3){if(a >= 8){this.rechts = 8;}}
                if(this.hoch== 4){if(a >= 8){this.rechts = 8;}}
                if(this.hoch== 6){if(a >= 2){this.rechts = 2;}}
                if(this.hoch== 7){if(a >= 2){this.rechts = 2;}}}

            else if(this.rechts==1) {
                if(this.hoch== 1){if(a >= 7){this.rechts = 8;}}
                else if(this.hoch== 2){if(a >= 7){this.rechts = 8;}}
                else if(this.hoch== 3){if(a >= 7){this.rechts = 8;}}
                else if(this.hoch== 4){if(a >= 7){this.rechts = 8;}}
                else if(this.hoch== 6){if(a >= 1){this.rechts = 2;}}
                else if(this.hoch== 7){if(a >= 1){this.rechts = 2;}}
                else {
                    this.rechts = rechts + a;}}

            else if(this.rechts==2) {
                if(this.hoch== 1){if(a >= 6){this.rechts = 8;}}
                else if(this.hoch== 2){if(a >= 6){this.rechts = 8;}}
                else if(this.hoch== 3){if(a >= 6){this.rechts = 8;}}
                else if(this.hoch== 4){if(a >= 6){this.rechts = 8;}}
                else {
                    this.rechts = rechts + a;}}

            else if(this.rechts==3) {
                if(this.hoch== 1){if(a >= 5){this.rechts = 8;}}
                else if(this.hoch== 2){if(a >= 5){this.rechts = 8;}}
                else if(this.hoch== 3){if(a >= 5){this.rechts = 8;}}
                else if(this.hoch== 4){if(a >= 5){this.rechts = 8;}}
                else {
                    this.rechts = rechts + a;}}

            else if(this.rechts==4) {
                if(this.hoch== 1){if(a >= 4){this.rechts = 8;}}
                else if(this.hoch== 2){if(a >= 4){this.rechts = 8;}}
                else if(this.hoch== 3){if(a >= 4){this.rechts = 8;}}
                else if(this.hoch== 4){if(a >= 4){this.rechts = 8;}}
                else {
                    this.rechts = rechts + a;}}

            else if(this.rechts==5) {
                if(this.hoch== 1){if(a >= 3){this.rechts = 8;}}
                else if(this.hoch== 2){if(a >= 3){this.rechts = 8;}}
                else if(this.hoch== 3){if(a >= 3){this.rechts = 8;}}
                else if(this.hoch== 4){if(a >= 3){this.rechts = 8;}}
                else {
                    this.rechts = rechts + a;}}

            else if(this.rechts==6) {
                if(this.hoch== 1){if(a >= 2){this.rechts = 8;}}
                else if(this.hoch== 2){if(a >= 2){this.rechts = 8;}}
                else if(this.hoch== 3){if(a >= 2){this.rechts = 8;}}
                else if(this.hoch== 4){if(a >= 2){this.rechts = 8;}}
                else {
                    this.rechts = rechts + a;}}

            else if(this.rechts==7) {
                if(this.hoch== 1){if(a >= 1){this.rechts = 8;}}
                else if(this.hoch== 2){if(a >= 1){this.rechts = 8;}}
                else if(this.hoch== 3){if(a >= 1){this.rechts = 8;}}
                else if(this.hoch== 4){if(a >= 1){this.rechts = 8;}}
                else {
                    this.rechts = rechts + a;}}

            else if(this.rechts==8) {
                if(this.hoch== 1){if(a >= 0){this.rechts = 8;}}
                else if(this.hoch== 2){if(a >= 0){this.rechts = 8;}}
                else if(this.hoch== 3){if(a >= 0){this.rechts = 8;}}
                else if(this.hoch== 4){if(a >= 0){this.rechts = 8;}}
                else {
                    this.rechts = rechts + a;}}

            else {
                this.rechts = rechts + a;}

            if (this.rechts >= 10) {
                this.rechts = 10; }}

        if (b.equals(""w"")) {
            if(this.rechts==10) {
                if(this.hoch== 1){if(a >= 1){this.rechts = 9;}}
                else if(this.hoch== 2){if(a >= 1){this.rechts = 9;}}
                else if(this.hoch== 3){if(a >= 1){this.rechts = 9;}}
                else if(this.hoch== 4){if(a >= 1){this.rechts = 9;}}
                else if(this.hoch== 6){if(a >= 7){this.rechts = 3;}}
                else if(this.hoch== 7){if(a >= 7){this.rechts = 3;}}
                else{
                    this.rechts = rechts - a;}}
            else if(this.rechts==9) {
                if(this.hoch== 1){if(a >= 0){this.rechts = 9;}}
                else if(this.hoch== 2){if(a >= 0){this.rechts = 9;}}
                else if(this.hoch== 3){if(a >= 0){this.rechts = 9;}}
                else if(this.hoch== 4){if(a >= 0){this.rechts = 9;}}
                else if(this.hoch== 6){if(a >= 6){this.rechts = 3;}}
                else if(this.hoch== 7){if(a >= 6){this.rechts = 3;}}
                else{
                    this.rechts = rechts - a;}}
            else if(this.rechts==8) {
                if(this.hoch== 6){if(a >= 5){this.rechts = 3;}}
                else if(this.hoch== 7){if(a >= 5){this.rechts = 3;}}
                else{
                    this.rechts = rechts - a;}}
            else if(this.rechts==7) {
                if(this.hoch== 6){if(a >= 4){this.rechts = 3;}}
                else if(this.hoch== 7){if(a >= 4){this.rechts = 3;}}
                else{
                    this.rechts = rechts - a;}}
            else if(this.rechts==6) {
                if(this.hoch== 6){if(a > 3){this.rechts = 3;}}
                else if(this.hoch== 7){if(a >= 3){this.rechts = 3;}}
                else{
                    this.rechts = rechts - a;}}
            else if(this.rechts==5) {
                if(this.hoch== 6){if(a > 2){this.rechts = 3;}}
                else if(this.hoch== 7){if(a >= 2){this.rechts = 3;}}
                else{
                    this.rechts = rechts - a;}}
            else if(this.rechts==4) {
                if(this.hoch== 6){if(a > 1){this.rechts = 3;}}
                else if(this.hoch== 7){if(a >= 1){this.rechts = 3;}}
                else{
                    this.rechts = rechts - a;}}
            else if(this.rechts==3) {
                if(this.hoch== 6){if(a >= 0){this.rechts = 3;}}
                else if(this.hoch== 7){if(a >= 0){this.rechts = 3;}}
                else{
                    this.rechts = rechts - a;}}

            else{
                this.rechts = rechts - a;}
        }
        if (this.rechts <= 0) {
            this.rechts = 0;
        }




        return ""("" + rechts + "","" + hoch + "")"";
    }
}




package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String goTo(String goCommandString);


}
",14839,343,47.21824104234528,75,0.0,0.9212827988338192,0.0,0.0,1.3498542274052479,0.0,0.08163265306122448,0.0,False,False,False,False,False,False,2,0.0058309037900874635,0.014577259475218658,0.008746355685131196,0.0029154518950437317,1.6793002915451896,0.026239067055393587,0.0,3.4,6,0.0,0
student146,student,,,"package thkoeln.st.st2praktikum.exercise;

import java.util.*;
import java.util.stream.Collectors;

public class Exercise0 implements Moveable {
    private final Map<WallType, List<String>> walls = new HashMap<>();

    private final int MAX_HEIGHT = 7;
    private final int MAX_WIDTH = 11;
    private int x = 5;
    private int y = 3;

    @Override
    public String moveTo(String moveCommandString) {
        List<String> tmp = new ArrayList<>(Arrays.asList(""(4,1)"", ""(4,2)"", ""(6,2)"", ""(6,3)"", ""(6,4)"", ""(6,5)"", ""(6,6)"", ""(6,7)""));
        walls.put(WallType.HORIZONTAL, tmp);
        tmp = new ArrayList<>(Arrays.asList(""(3,3)"", ""(4,3)"", ""(5,3)"", ""(6,3)"", ""(7,3)"", ""(8,3)"", ""(1,6)"", ""(2,6)"", ""(3,6)"", ""(4,6)"", ""(5,6)""));
        walls.put(WallType.VERTICAL, tmp);
        String direction = getSplit(moveCommandString, 0).replace(""["", """");
        int value = Integer.parseInt(getSplit(moveCommandString, 1).replace(""]"", """"));
        switch (direction) {
            case ""no"":
                doY(value, true);
                break;
            case ""ea"":
                doX(value, true);
                break;
            case ""so"":
                doY(value, false);
                break;
            case ""we"":
                doX(value, false);
                break;
        }
        System.out.println(moveCommandString);
        System.out.println(""("" + x + "","" + y + "")"");
        return ""("" + x + "","" + y + "")"";
    }

    private void doX(int value, boolean plus) {
        List<String> list;
        if (plus) {
            list = walls.get(WallType.HORIZONTAL).stream().filter(s -> {
                int a = getY(s);
                return a == y && x < getX(s) && (x + value) >= getX(s);
            }).collect(Collectors.toList());
            if (list.isEmpty())
                x += value;
            else
                x = list.stream().mapToInt(this::getX).min().getAsInt() - 1;
            if (x > MAX_WIDTH)
                x = MAX_WIDTH;
        } else {
            list = walls.get(WallType.HORIZONTAL).stream().filter(s -> {
                int a = getY(s);
                return a == y && x >= getX(s) && (x - value) < getX(s);
            }).collect(Collectors.toList());
            if (list.isEmpty())
                x -= value;
            else
                x = list.stream().mapToInt(this::getX).max().getAsInt();
            if (x < 0)
                x = 0;
        }
    }

    private void doY(int value, boolean plus) {
        List<String> list;
        if (plus) {
            list = walls.get(WallType.VERTICAL).stream().filter(s -> {
                int a = getX(s);
                return a == x && y < getY(s) && (y + value) >= getY(s);
            }).collect(Collectors.toList());
            if (list.isEmpty())
                y += value;
            else
                y = list.stream().mapToInt(this::getY).min().getAsInt() - 1;
            if (y > MAX_HEIGHT)
                y = MAX_HEIGHT;
        } else {
            list = walls.get(WallType.VERTICAL).stream().filter(s -> {
                int a = getX(s);
                return a == x && y >= getY(s) && (y - value) < getY(s);
            }).collect(Collectors.toList());
            if (list.isEmpty())
                y -= value;
            else
                y = list.stream().mapToInt(this::getY).max().getAsInt();
            if (y < 0)
                y = 0;
        }
    }

    private int getX(String s) {
        return Integer.parseInt(getSplit(s, 0).replace(""("", """"));
    }

    private int getY(String s) {
        return Integer.parseInt(getSplit(s, 1).replace("")"", """"));
    }

    private String getSplit(String s, int index) {
        return s.split("","")[index].trim();
    }

    private enum WallType {
        HORIZONTAL,
        VERTICAL
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String moveTo(String moveCommandString);
}
",3919,117,36.20952380952381,144,0.0,0.08547008547008547,0.0,0.008547008547008548,0.47863247863247865,0.0,0.10256410256410256,0.017094017094017096,False,True,False,False,False,False,2,0.05982905982905983,0.042735042735042736,0.07692307692307693,0.008547008547008548,0.8034188034188035,0.6410256410256411,0.017094017094017096,5.647058823529412,17,0.0,0
student147,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Moveable {
    public  String device=""3,0"";
    int device_x = Integer.parseInt(device.substring(0,1));
    int device_y = Integer.parseInt(device.substring(2));
    String[] wall1 ={""1,4"",""2,4"",""3,4"",""4,4"",""5,4"",""6,4"",""7,4"",""8,4""};
    String[] wall2 ={""3,0"",""3,1"",""3,2"",""3,3""};
    String[] wall3 ={""4,3"",""5,3"",""6,3"",""7,3""};
    String[] wall4 ={""7,0"",""7,1"",""7,2""};

    @Override
    public String moveTo(String moveCommandString) {
        int c=0;
        String check = moveCommandString.substring(1,3);
        int x = Integer.parseInt(moveCommandString.substring(4,moveCommandString.length()-1));
        for (int y =0; y < x; y++){

            switch (check){
                case ""no"":
                    if(device_y+1 < 8) {

                        if(test(check) == true) {
                            device = device_x + "","" + (device_y + 1);
                            device_y++;
                        }
                    }

                    break;

                case ""so"":
                    if(device_y-1 >= 0) {

                        if(test(check) == true) {
                            device = device_x + "","" + (device_y - 1);
                            device_y--;
                        }
                    }

                    break;

                case ""ea"":
                    if(device_x+1 < 12) {

                        if (test(check) == true) {
                            device = (device_x + 1) + "","" + device_y;
                            device_x++;
                        }
                    }

                    break;

                case ""we"":
                    if(device_x-1 >= 0) {

                        if(test(check) == true) {
                            device = (device_x - 1) + "","" + device_y;
                            device_x--;
                        }
                    }

                    break;
            }
        }
        return (""("" + device + "")"");
    }
    public boolean No(String [] wall){
        int c = 0;
        for (int i =0; i < wall.length; i++){
            if (wall[i].equals(device_x + "","" + (device_y+1))){
                c++;
            }
            if (wall[i].equals((device_x+1) + "","" + (device_y+1))){
                c++;
            }
        }
        if(c == 2){
            return false;
        }
        return true;
    }
    public boolean So(String [] wall){
        int c = 0;
        for (int i =0; i < wall.length; i++){
            if (wall[i].equals(device)){
                c++;
            }
            if (wall[i].equals((device_x+1) + "","" + device_y)){
                c++;
            }
        }
        if(c == 2){
            return false;
        }
        return true;
    }
    public boolean Ea(String [] wall){
        int c = 0;
        String a = (device_x+1) + "","" + (device_y+1);
        String b = (device_x+1) + "","" + device_y;
        for (int i =0; i < wall.length; i++){
            if (wall[i].equals(a)){
                c++;
            }
            if (wall[i].equals(b)){
                c++;
            }
        }
        if(c == 2){
            return false;
        }
        return true;
    }
    public boolean We(String [] wall){
        int c = 0;
        for (int i =0; i < wall.length; i++){
            if (wall[i].equals(device_x + "","" + (device_y+1))){
                c++;
            }
            if (wall[i].equals(device)){
                c++;
            }
        }
        if(c == 2){
            return false;
        }
        return true;
    }
    public boolean NoSoEaWe(String [] wall,String direction) {
        switch (direction) {
            case ""no"":
                if (No(wall) == false) return false;
                break;
            case ""so"":
                if (So(wall) == false) return false;
                break;
            case ""ea"":
                if (Ea(wall) == false) return false;
                break;
            case ""we"":
                if (We(wall) == false) return false;
                break;
        }
        return true;
    }
    public boolean test(String direction){

        if(NoSoEaWe(wall1,direction) == false)
            return false;
        if(NoSoEaWe(wall2,direction) == false)
            return false;
        if(NoSoEaWe(wall3,direction) == false)
            return false;
        if(NoSoEaWe(wall4,direction) == false)
            return false;
        return true;
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String moveTo(String moveCommandString);
}
",4636,164,30.421768707482993,94,0.0,0.17073170731707318,0.03048780487804878,0.012195121951219513,0.5670731707317073,0.0,0.10365853658536585,0.0,False,False,False,False,False,False,2,0.04878048780487805,0.042682926829268296,0.054878048780487805,0.006097560975609756,0.5975609756097561,0.17073170731707318,0.0,4.235294117647059,9,0.0,0
student148,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements GoAble {
    int x = 1;
    int y = 6;

    @Override
    public String goTo(String goCommandString) {
        String commandString = goCommandString.replace(""["", """");
        commandString = commandString.replace(""]"", """");
        String moveArray[] = commandString.split("","");
        String moveDirection = moveArray[0];
        int steps = Integer.parseInt(moveArray[1]);
        movement(moveDirection, steps);
        return ""("" + x + "","" + y + "")"";
    }

    public void movement(String moveDirection, int steps) {
        switch (moveDirection) {
            case ""no"":
                y = checkNorth(y, steps);
                break;
            case ""ea"":
                x = checkEast(x, steps);
                break;
            case ""so"":
                y = checkSouth(y, steps);
                break;
            case ""we"":
                x = checkWest(x, steps);
                break;
            default:
                throw new IllegalArgumentException(""Move not allowed!"");
        }
    }

    public int checkNorth(int yMove, int steps) {
        int[] illegalXs1 = new int[]{0, 1};
        int[] illegalYs1 = new int[]{6};
        int[] illegalXs2 = new int[]{1, 2, 3, 4, 5, 6, 7, 8};
        int[] illegalYs2 = new int[]{5};
        for (int i = 0; i < steps; i++) {
            if (yMove == 7) break;
            else if ((contains(illegalYs1, yMove + 1) && contains(illegalXs1, x)) || (contains(illegalYs2, yMove + 1) && contains(illegalXs2, x)))
                break;
            else yMove += 1;
        }
        return yMove;
    }

    public int checkEast(int xMove, int steps) {
        int[] illegalXs1 = new int[]{9};
        int[] illegalYs1 = new int[]{1, 2, 3, 4};
        int[] illegalXs2 = new int[]{3};
        int[] illegalYs2 = new int[]{6, 7};

        for (int i = 0; i < steps; i++) {
            if (xMove == 10) break;
            else if ((contains(illegalYs1, y) && contains(illegalXs1, xMove + 1)) || (contains(illegalYs2, y) && contains(illegalXs2, xMove + 1)))
                break;
            else xMove += 1;
        }
        return xMove;
    }

    public int checkSouth(int yMove, int steps) {
        int[] illegalXs1 = new int[]{0, 1};
        int[] illegalYs1 = new int[]{5};
        int[] illegalXs2 = new int[]{1, 2, 3, 4, 5, 6, 7, 8};
        int[] illegalYs2 = new int[]{4};
        for (int i = 0; i < steps; i++) {
            if (yMove == 0) break;
            else if ((contains(illegalYs1, yMove - 1) && contains(illegalXs1, x)) || (contains(illegalYs2, yMove - 1) && contains(illegalXs2, x)))
                break;
            else yMove -= 1;
        }
        return yMove;
    }

    public int checkWest(int xMove, int steps) {
        int[] illegalXs1 = new int[]{8};
        int[] illegalYs1 = new int[]{1, 2, 3, 4};
        int[] illegalXs2 = new int[]{2};
        int[] illegalYs2 = new int[]{6, 7};
        for (int i = 0; i < steps; i++) {
            if (xMove == 0) break;
            else if ((contains(illegalYs1, y) && contains(illegalXs1, xMove - 1)) || (contains(illegalYs2, y) && contains(illegalXs2, xMove - 1)))
                break;
            else xMove -= 1;
        }
        return xMove;
    }

    public boolean contains(int[] list, int move) {
        boolean isInList = false;
        for (int j : list) {
            if (j == move) {
                isInList = true;
                break;
            }
        }
        return isInList;
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String goTo(String goCommandString);
}
",3652,110,35.77777777777778,146,0.0,0.08181818181818182,0.045454545454545456,0.00909090909090909,0.9090909090909091,0.00909090909090909,0.1,0.0,True,False,False,False,False,False,2,0.07272727272727272,0.01818181818181818,0.19090909090909092,0.00909090909090909,0.7363636363636363,0.22727272727272727,0.0,6.470588235294118,13,0.0,0
student149,student,,,"package thkoeln.st.st2praktikum.exercise;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Barrier {

    private static final String PATTERN = ""(\\((?:\\d|\\,)+\\))\\-(\\((?:\\d|\\,)+\\))"";

    private Position start;
    private Position end;

    private List<Transition> blockedTransitions = new ArrayList<>();

    public Barrier(Position start, Position end) {
        this.start = start;
        this.end = end;

        initBlockedTransitions();
    }

    public Barrier(String barrier) {
        parseBarrier(barrier);
        initBlockedTransitions();
    }

    public List<Transition> getBlockedTransitions() {
        return blockedTransitions;
    }

    public Position getStart() {
        return start;
    }

    public Position getEnd() {
        return end;
    }

    @Override
    public String toString() {
        return start + ""-"" + end;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Barrier barrier = (Barrier) o;
        return Objects.equals(start, barrier.start) && Objects.equals(end, barrier.end);
    }

    @Override
    public int hashCode() {
        return Objects.hash(start, end);
    }

    private void initBlockedTransitions() {
        int deltaX = end.getX() - start.getX();
        int deltaY = end.getY() - start.getY();

        int x = end.getX() - deltaX;
        int y = end.getY() - deltaY;

        if (deltaX != 0) {
            int minX = Integer.min(x, end.getX());
            int maxX = Integer.max(x, end.getX());

            for (int i = minX; i <= maxX; i++) {
                blockedTransitions.add(new Transition(new Position(i, y), new Position(i, y - 1)));
            }
        }
        if (deltaY != 0) {
            int minY = Integer.min(y, end.getY());
            int maxY = Integer.max(y, end.getY());

            for (int i = minY; i <= maxY; i++) {
                blockedTransitions.add(new Transition(new Position(x, i), new Position(x - 1, i)));
            }
        }
    }

    private void parseBarrier(String barrier) {
        Pattern pattern = Pattern.compile(PATTERN);
        Matcher matcher = pattern.matcher(barrier);

        if (matcher.find()) {
            start = new Position(matcher.group(1));
            end = new Position(matcher.group(2));
        }
    }
}

package thkoeln.st.st2praktikum.exercise;

public enum Direction {

    NORTH(""no"", 0, 1),
    EAST(""ea"", 1, 0),
    SOUTH(""so"", 0, -1),
    WEST(""we"", -1, 0);

    private String code;
    private int xFactor = 0;
    private int yFactor = 0;

    Direction(String code, int xFactor, int yFactor) {
        this.code = code;
        this.xFactor = xFactor;
        this.yFactor = yFactor;
    }

    public static Direction getValue(String code) {
        switch (code) {
            case ""no"": return NORTH;
            case ""ea"": return EAST;
            case ""so"": return SOUTH;
            case ""we"": return WEST;
            default: return null;
        }
    }

    public String getCode() {
        return code;
    }

    public int getXFactor() {
        return xFactor;
    }

    public int getYFactor() {
        return yFactor;
    }
}

package thkoeln.st.st2praktikum.exercise;

import java.util.Arrays;
import java.util.stream.Collectors;

public class Exercise0 implements Moveable {

    private Position currentPosition = new Position(""(0,2)"");
    private Map map = new Map(12, 9,
            Arrays.asList(""(3,0)-(3,2)"", ""(5,0)-(5,3)"", ""(4,5)-(6,5)"", ""(7,5)-(7,8)"").stream().map(barrier -> new Barrier(barrier)).collect(Collectors.toList()));

    @Override
    public String moveTo(String moveCommandString) {
        move(new Movement(moveCommandString));

        return currentPosition.toString();
    }

    private void move(Movement movement) {
        if (movement.getMoves() > 0) {
            Position previewedStep = movement.previewStep(currentPosition);
            if (map.isMoveValid(currentPosition, previewedStep)) {
                currentPosition = movement.makeStep(currentPosition);
                move(movement);
            }
        }
    }
}

package thkoeln.st.st2praktikum.exercise;

import java.util.ArrayList;
import java.util.List;

public class Map {

    private int width;
    private int height;

    private List<Transition> blockedTransitions = new ArrayList<>();

    public Map(int width, int height, List<Barrier> barriers) {
        this.width = width;
        this.height = height;

        initBlockedTransition(barriers);
    }

    public boolean isMoveValid(Position current, Position next) {
        return isPositionOnMap(next) && !blockedTransitions.contains(new Transition(current, next));
    }

    public int getWidth() {
        return width;
    }

    public int getHeight() {
        return height;
    }

    public List<Transition> getBlockedTransitions() {
        return blockedTransitions;
    }

    private boolean isPositionOnMap(Position position) {
        return position.getX() >= 0 && position.getY() >= 0
                && position.getX() < width && position.getY() < height;
    }

    private void initBlockedTransition(List<Barrier> barriers) {
        barriers.forEach(barrier -> blockedTransitions.addAll(barrier.getBlockedTransitions()));
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String moveTo(String moveCommandString);
}

package thkoeln.st.st2praktikum.exercise;

import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Movement {

    private static final String PATTERN = ""\\[(\\w{2})\\,(\\d+)\\]"";

    private Direction direction;
    private int moves = 0;

    public Movement(String movement) {
        parseMovement(movement);
    }

    public Movement(Direction direction, int moves) {
        this.direction = direction;
        this.moves = moves;
    }

    public Position makeStep(Position position) {
        return makeStep(position, 1);
    }

    public Position makeStep(Position position, int desiredMoves) {
        Position previewSteps = previewSteps(position, desiredMoves);
        this.moves -= desiredMoves > this.moves ? this.moves : desiredMoves;
        return previewSteps;
    }

    public Position previewStep(Position position) {
        return previewSteps(position, 1);
    }

    public Position previewSteps(Position position, int desiredMoves) {
        int actualMoves = desiredMoves;
        if (desiredMoves > this.moves) {
            actualMoves = this.moves;
        }
        return new Position(position.getX() + (actualMoves * direction.getXFactor()), position.getY() + (actualMoves * direction.getYFactor()));
    }

    public Direction getDirection() {
        return direction;
    }

    public int getMoves() {
        return moves;
    }

    @Override
    public String toString() {
        return ""["" + direction.getCode() +
                "","" + moves +
                ""]"";
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Movement movement = (Movement) o;
        return moves == movement.moves && direction == movement.direction;
    }

    @Override
    public int hashCode() {
        return Objects.hash(direction, moves);
    }

    private void parseMovement(String movement) {
        Pattern pattern = Pattern.compile(PATTERN);
        Matcher matcher = pattern.matcher(movement);

        if (matcher.find()) {
            direction = Direction.getValue(matcher.group(1));
            moves = Integer.parseInt(matcher.group(2));
        }
    }
}

package thkoeln.st.st2praktikum.exercise;

import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Position {

    private static final String PATTERN = ""\\((\\d+)\\,(\\d+)\\)"";

    private int x;
    private int y;

    public Position(String position) {
        parsePosition(position);
    }

    public Position(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    @Override
    public String toString() {
        return ""("" +
                x +
                "","" +
                y +
                ')';
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Position position = (Position) o;
        return x == position.x && y == position.y;
    }

    @Override
    public int hashCode() {
        return Objects.hash(x, y);
    }

    private void parsePosition(String position) {
        Pattern pattern = Pattern.compile(PATTERN);
        Matcher matcher = pattern.matcher(position);

        if (matcher.find()) {
            x = Integer.parseInt(matcher.group(1));
            y = Integer.parseInt(matcher.group(2));
        }
    }
}

package thkoeln.st.st2praktikum.exercise;

import java.util.Objects;

public class Transition {

    private Position fromPosition;
    private Position toPosition;

    public Transition(Position fromPosition, Position toPosition) {
        this.fromPosition = fromPosition;
        this.toPosition = toPosition;
    }

    public Position getFromPosition() {
        return fromPosition;
    }

    public Position getToPosition() {
        return toPosition;
    }

    @Override
    public String toString() {
        return ""Transition{"" +
                fromPosition +
                "","" + toPosition +
                '}';
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Transition that = (Transition) o;
        return (Objects.equals(fromPosition, that.fromPosition) && Objects.equals(toPosition, that.toPosition))
                || (Objects.equals(fromPosition, that.toPosition) && Objects.equals(toPosition, that.fromPosition));
    }

    @Override
    public int hashCode() {
        return Objects.hash(fromPosition, toPosition);
    }
}
",10334,407,31.715654952076676,162,0.0,0.03931203931203931,0.007371007371007371,0.002457002457002457,0.14004914004914004,0.0,0.23095823095823095,0.0,False,True,False,False,False,False,8,0.10319410319410319,0.04914004914004914,0.051597051597051594,0.014742014742014743,0.40540540540540543,0.21621621621621623,0.03931203931203931,6.607843137254902,18,0.0,0
student15,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Coordinate {

    int x;
    int y;
    String blockedDir;

    public Coordinate(int x, int y, String blockedDir){
        this.x = x;
        this.y = y;
        this.blockedDir = blockedDir;
    }
}

package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Moveable {

    int max_x = 11;
    int max_y = 8;
    Coordinate currentPos = new Coordinate(8,3, """");
    Coordinate[] blockedFields =
                            {new Coordinate(4,1, ""we""), new Coordinate(4,2, ""we""), new Coordinate(4,3, ""we""),
                            new Coordinate(4,4, ""we""), new Coordinate(4,5, ""we""), new Coordinate(4,6, ""we""),
                                    new Coordinate(3,1, ""ea""), new Coordinate(3,2, ""ea""), new Coordinate(3,3, ""ea""),
                                    new Coordinate(3,4, ""ea""), new Coordinate(3,5, ""ea""), new Coordinate(3,6, ""ea""),
                            new Coordinate(8,1, ""no""), new Coordinate(7,1, ""no""), new Coordinate(6,1, ""no""),
                            new Coordinate(5,2, ""ea""), new Coordinate(5,3, ""ea""), new Coordinate(5,4, ""ea""),
                            new Coordinate(6,5, ""so""), new Coordinate(7,5, ""so""), new Coordinate(8,5, ""so""),
                            new Coordinate(6,2, ""so""), new Coordinate(6,2, ""we""), new Coordinate(7,2, ""so""), new Coordinate(8,2, ""so""),
                            new Coordinate(6,4, ""no""), new Coordinate(6,4, ""we""), new Coordinate(7,4, ""no""), new Coordinate(8,4, ""no""),
                            new Coordinate(6,3,""we"")};


    @Override
    public String moveTo(String moveCommandString) {

        char[] moveString = moveCommandString.toCharArray();
        String direction = """" + moveString[1] + moveString[2];
        int amount;
        String temp = """";
        boolean onWall = false;

        for(int i = 4; i<=moveString.length-2; i++){
            temp += moveString[i];
        }

        amount = Integer.parseInt(temp);

        System.out.println(direction);
        System.out.println(amount);

        switch(direction){
            case ""no"":
                onWall = false;

                for(int i = amount; i>0; i--){
                    if(currentPos.y+1<= max_y){
                        for(int j = 0; j<blockedFields.length; j++){

                            if(currentPos.x == blockedFields[j].x && currentPos.y == blockedFields[j].y && ""no"" == blockedFields[j].blockedDir){
                                onWall = true;
                            }
                        }
                        if(onWall == false){
                            currentPos.y += 1;
                            System.out.println(""no"");
                        }
                    }
                }
                break;
            case ""ea"":
                onWall = false;

                for(int i = amount; i>0; i--){
                    if(currentPos.x+1<= max_x){
                        for(int j = 0; j<blockedFields.length; j++){
                            if(currentPos.x == blockedFields[j].x && currentPos.y == blockedFields[j].y && ""ea"" == blockedFields[j].blockedDir){
                                onWall = true;
                            }
                        }
                        if(onWall == false){
                            currentPos.x += 1;
                            System.out.println(""ea"");
                        }
                    }
                }
                break;
            case ""so"":
                onWall = false;

                for(int i = amount; i>0; i--){
                    if(currentPos.y-1>=0){
                        for(int j = 0; j<blockedFields.length; j++){
                            if(currentPos.x == blockedFields[j].x && currentPos.y == blockedFields[j].y && ""so"" == blockedFields[j].blockedDir){
                                onWall = true;
                            }
                        }
                        if(onWall == false){
                            currentPos.y -= 1;
                            System.out.println(""so"");
                        }
                    }
                }
                break;
            case ""we"":
                onWall = false;

                for(int i = amount; i>0; i--){
                    if(currentPos.x-1>=0){
                        for(int j = 0; j<blockedFields.length; j++){
                            if(currentPos.x == blockedFields[j].x && currentPos.y == blockedFields[j].y && ""we"" == blockedFields[j].blockedDir){
                                onWall = true;
                            }
                        }
                        if(onWall == false){
                            currentPos.x -= 1;
                            System.out.println(""we"");
                        }
                    }
                }
                break;
        }
        String result = ""("" + currentPos.x + "","" + currentPos.y + "")"";

        return result;
    }

}


package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String moveTo(String moveCommandString);
}
",5134,137,43.833333333333336,144,0.0,0.08759124087591241,0.06569343065693431,0.0072992700729927005,0.6642335766423357,0.0,0.15328467153284672,0.043795620437956206,True,False,False,False,False,False,3,0.014598540145985401,0.051094890510948905,0.043795620437956206,0.014598540145985401,0.8175182481751825,0.058394160583941604,0.0,5.333333333333333,13,0.0,0
student153,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Walkable {

    int  starty=7;
    int startx=11;


    @Override
    public String walk(String walkCommandString) {





        String direction = walkCommandString.substring(1, 3);
        String substr2 = walkCommandString.substring(4, 5);
        int steps = Integer.parseInt(substr2);


        //Array erstellen

        int [][] ship = new int [8][12];

        //Array befüllen

        for(int y=0;y<8;y++){
            for (int x=0;x<12;x++){
                ship[y][x]=0;
            }
        }

        //Array spezifisch befüllen, der Rand des Shiffes

        for (int x=1;x<11;x++){
            ship[0][x]=2;
        }
        for (int x=1;x<11;x++){
            ship[7][x]=4;
        }
        for (int y=1;y<7;y++){
            ship[y][0]=1;
        }
        for (int y=1;y<7;y++){
            ship[y][11]=3;
        }
        ship[0][0]=5;
        ship[0][11]=6;
        ship[7][0]=8;
        ship[7][11]=7;

        // Wand ins Array füllen

        ship[2][5]=3;
        ship[3][5]=3;
        ship[4][5]=7;
        ship[5][4]=3;
        ship[5][5]=12;
        ship[2][6]=1;
        ship[3][6]=1;
        ship[4][6]=1;
        ship[5][11]=7;
        ship[6][11]=6;

        for(int x=6;x<11;x++){
            ship[5][x]=4;
        }
        for(int x=5;x<11;x++){
            ship[6][x]=2;
        }

        //


       //Move step by Step

    switch (direction){
        case ""we"":

        for ( int s=0;s<steps;s++){
           if (ship[starty][startx]== 1 || ship[starty][startx]==5 ||ship[starty][startx]==8||ship[starty][startx]==9||ship[starty][startx]==11||ship[starty][startx]==12){
               break;
           }
            startx=startx-1;

        }
        break;
        case ""ea"":

            for ( int s=0;s<steps;s++){
                if(ship[starty][startx]==3||ship[starty][startx]==6||ship[starty][startx]==7||ship[starty][startx]==9||ship[starty][startx]==10||ship[starty][startx]==11 ){
                    break;
                }
                startx=startx+1;

            }
            break;
        case ""no"":

            for ( int s=0;s<steps;s++){
                if(ship[starty][startx]==4||ship[starty][startx]==7||ship[starty][startx]==8||ship[starty][startx]==10||ship[starty][startx]==11||ship[starty][startx]==12 ){

                    break;
                }
                starty=starty+1;

            }
            break;
        case ""so"":

            for ( int s=0;s<steps;s++){
                if(ship[starty][startx]==2||ship[starty][startx]==5||ship[starty][startx]==6||ship[starty][startx]==9||ship[starty][startx]==10||ship[starty][startx]==12){
                    break;
                }
                starty=starty-1;

            }
            break;







    }












        return (""(""+startx+"",""+starty+"")"");
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",3013,147,30.48936170212766,173,0.04081632653061224,0.04081632653061224,0.08163265306122448,0.006802721088435374,0.9387755102040817,0.0,0.2653061224489796,0.0,False,False,False,False,False,False,2,0.013605442176870748,0.013605442176870748,0.027210884353741496,0.006802721088435374,0.9591836734693877,0.02040816326530612,0.0,4.444444444444445,9,19.0,47
student157,student,,,"package thkoeln.st.st2praktikum.exercise;

public enum Direction {
    NORTH, EAST, SOUTH, WEST
}

package thkoeln.st.st2praktikum.exercise;

import java.util.ArrayList;

public class Exercise0 implements Walkable {

    public Exercise0() {
        this.setIllegalMoves();
    }

    public ArrayList<Move> illegalMoves = new ArrayList<>();
    private int positionX = 0;
    private int positionY = 2;

    @Override
    public String walk(String walkCommandString) {
        WalkCommand walkCommand = new WalkCommand(walkCommandString);
        makeMoves(walkCommand);
        return ""("" + this.positionX + "","" + this.positionY + "")"";
    }

    private void makeMoves(WalkCommand walkCommand) {
        for (int i = 0; i < walkCommand.steps; i++) {
            Move currentMove = new Move(this.positionX, this.positionY, walkCommand.direction);
            if(illegalMoves.contains(currentMove)) {
                break;
            }

            switch (walkCommand.direction) {
                case EAST:
                    if(positionX == 11) {
                        break;
                    }
                    positionX++;
                    System.out.println(""Right"");
                    break;
                case WEST:
                    if(positionX == 0) {
                        break;
                    }
                    positionX--;
                    System.out.println(""Left"");
                    break;
                case NORTH:
                    if(positionY == 8) {
                        break;
                    }
                    positionY++;
                    break;
                case SOUTH:
                    if(positionY == 0) {
                        break;
                    }
                    positionY--;
                    System.out.println(""Down"");
                    break;
            }
        }
    }

    private void setIllegalMoves() {
        illegalMoves.add(new Move(4, 4, Direction.NORTH));
        illegalMoves.add(new Move(5, 4, Direction.NORTH));
        illegalMoves.add(new Move(6, 4, Direction.NORTH));

        illegalMoves.add(new Move(4, 5, Direction.SOUTH));
        illegalMoves.add(new Move(5, 5, Direction.SOUTH));
        illegalMoves.add(new Move(6, 5, Direction.SOUTH));


        illegalMoves.add(new Move(2, 0, Direction.EAST));
        illegalMoves.add(new Move(2, 1, Direction.EAST));
        illegalMoves.add(new Move(2, 2, Direction.EAST));

        illegalMoves.add(new Move(3, 0, Direction.WEST));
        illegalMoves.add(new Move(3, 1, Direction.WEST));
        illegalMoves.add(new Move(3, 3, Direction.WEST));


        illegalMoves.add(new Move(4, 0, Direction.EAST));
        illegalMoves.add(new Move(4, 1, Direction.EAST));
        illegalMoves.add(new Move(4, 2, Direction.EAST));
        illegalMoves.add(new Move(4, 3, Direction.EAST));

        illegalMoves.add(new Move(5, 0, Direction.WEST));
        illegalMoves.add(new Move(5, 1, Direction.WEST));
        illegalMoves.add(new Move(5, 2, Direction.WEST));
        illegalMoves.add(new Move(5, 3, Direction.WEST));


        illegalMoves.add(new Move(6, 5, Direction.EAST));
        illegalMoves.add(new Move(6, 6, Direction.EAST));
        illegalMoves.add(new Move(6, 7, Direction.EAST));
        illegalMoves.add(new Move(6, 8, Direction.EAST));

        illegalMoves.add(new Move(7, 5, Direction.WEST));
        illegalMoves.add(new Move(7, 6, Direction.WEST));
        illegalMoves.add(new Move(7, 7, Direction.WEST));
        illegalMoves.add(new Move(7, 8, Direction.WEST));
    }
}

package thkoeln.st.st2praktikum.exercise;

import java.util.Objects;

public class Move {

    public int positionX;
    public int positionY;

    public Direction direction;

    public Move(int positionX, int positionY, Direction direction) {
        this.positionY = positionY;
        this.positionX = positionX;
        this.direction = direction;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Move move = (Move) o;
        return positionX == move.positionX && positionY == move.positionY && direction == move.direction;
    }

    @Override
    public int hashCode() {
        return Objects.hash(positionX, positionY, direction);
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}

package thkoeln.st.st2praktikum.exercise;

public class WalkCommand {

    public Direction direction;
    public int steps;

    WalkCommand(String walkCommandString) {
        setDirection(walkCommandString);
        setSteps(walkCommandString);
    }

    private void setSteps(String walkCommandString) {
        char[] stepsArray = new char[walkCommandString.length()-5];
        walkCommandString.getChars(4, walkCommandString.length() -1, stepsArray, 0);
        String stepsString = new String(stepsArray);
        this.steps = Integer.parseInt(stepsString);
    }

    private void setDirection(String walkCommandString) {
        String directionString = getString(walkCommandString);
        setDirectionEnum(directionString);
    }

    private void setDirectionEnum(String directionString) {
        switch (directionString) {
            case ""no"":
                this.direction = Direction.NORTH;
                break;
            case ""ea"":
                this.direction = Direction.EAST;
                break;
            case ""so"":
                this.direction = Direction.SOUTH;
                break;
            case ""we"":
                this.direction = Direction.WEST;
                break;
        }
    }

    private String getString(String walkCommandString) {
        return String.valueOf(walkCommandString.charAt(1)) + walkCommandString.charAt(2);
    }

    public void print() {
        System.out.println(direction);
        System.out.println(steps);
    }
}
",5964,195,36.98076923076923,105,0.0,0.035897435897435895,0.005128205128205128,0.010256410256410256,0.39487179487179486,0.0,0.18461538461538463,0.03076923076923077,False,False,False,False,True,False,5,0.05641025641025641,0.041025641025641026,0.03076923076923077,0.015384615384615385,0.4358974358974359,0.2564102564102564,0.010256410256410256,7.8076923076923075,17,0.0,0
student158,student,,,"package thkoeln.st.st2praktikum.exercise;

import java.util.ArrayList;

public class Exercise0 implements Moveable {

    private ArrayList<Wall> walls = new ArrayList<Wall>();

    private Integer posX = 0;

    private Integer posY = 2;

/*
no = x +
so = x -
ea = y +
we = y -
*/

    @Override
    public String moveTo(String input) {
        if(walls.isEmpty()){
            setWalls();
        }
        String direction = input.substring(1,3);
        int steps = Integer.parseInt(input.substring(4,6).replace(""]"", """"));

        switch (direction){
            case ""ea"":
                for (int i = 0;i<steps;i++){
                    boolean marker=true;
                    for(int j=0;j<walls.size();j++){
                        if(posX==11){
                            marker = false;
                            continue;
                        }
                        if(marker){
                            marker = !walls.get(j).checkBlock(posX, posY, 1,0);
                        }
                    }
                    if (marker){
                        posX++;
                    } else {
                        continue;
                    }
                }
                break;
            case ""we"":
                for (int i = 0;i<steps;i++){
                    boolean marker=true;
                    for(int j=0;j<walls.size();j++){
                        if(posX==0){
                            marker = false;
                            continue;
                        }
                        if(marker){
                            marker = !walls.get(j).checkBlock(posX, posY, -1,0);
                        }
                    }
                    if (marker){
                        posX--;
                    } else {
                        continue;
                    }
                }
                break;
            case ""no"":
                for (int i = 0;i<steps;i++){
                    boolean marker=true;
                    for(int j=0;j<walls.size();j++){
                        if (posY == 8){
                            marker = false;
                            continue;
                        }
                        if(marker){
                            marker = !walls.get(j).checkBlock(posX, posY, 0,1);
                        }
                    }
                    if (marker){
                        posY++;
                    } else {
                        continue;
                    }
                }
                break;
            case ""so"":
                for (int i = 0;i<steps;i++){
                    boolean marker=true;
                    for(int j=0;j<walls.size();j++){
                        if(posY==0){
                            marker = false;
                            continue;
                        }
                        if(marker){
                            marker = !walls.get(j).checkBlock(posX, posY, 0,-1);
                        }
                    }
                    if (marker){
                        posY--;
                    } else {
                        continue;
                    }
                }
                break;
            default:
                throw new IllegalArgumentException(""???"");
        }
        String erg = ""("" + posX+ "","" + posY+"")"";
        return erg;
    }


    private void setWalls(){
        Wall one = new Wall(3,0,3,3);
        Wall two = new Wall(5,0,5,4);
        Wall three = new Wall(7,5,7,9);
        Wall four = new Wall(4,5,7,5);

        walls.add(one);
        walls.add(two);
        walls.add(three);
        walls.add(four);

        /*
        3,0-3,3
        5,0-5,4
        7,5-7-9
        4,5-7,5
        */
    }

}

package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String moveTo(String moveCommandString);
}

package thkoeln.st.st2praktikum.exercise;

public class Wall {

    int startx;

    int starty;

    int endx;

    int endy;

    private boolean direction;

    public Wall(int startx, int starty, int endx, int endy) {
        this.startx = startx;
        this.starty = starty;
        this.endx = endx;
        this.endy = endy;
        direction = startx == endx;
    }

    public boolean checkBlock(int posx, int posy, int stepx, int stepy){
        if (direction && stepy != 0){
            return false;
        } else if (!direction && stepx != 0){
            return false;
        }
        if (stepx!=0){
            return checkx(posx, stepx, posy);
        } else {
            return checky(posy, stepy, posx);
        }
    }

    private boolean checkx(int posx, int step, int posy){
        int newpos = posx+step;
        for (int i = startx; i<=endx;i++){
            for(int j = starty; j<=endy; j++){
                if(step>0) {
                    if(posy<starty){
                        if (newpos == i && posy == j) {
                            return true;
                        }
                    } else if (newpos == i && posy == j-1) {
                        return true;
                    }
                } else if(newpos == i-1 && posy == j - 1){
                    return true;
                }
            }
        }
        return false;
    }


    private boolean checky(int posy, int step, int posx){
        int newpos = posy+step;
        for (int i = starty; i<=endy;i++){
            for(int j= startx; j<= endx;j++){
                if(step>0) {
                    if (posx < startx){
                        if (newpos == i && posx == j) {
                            return true;
                        }

                    } else if (newpos == i && posx == j-1) {
                        return true;
                    }
                } else if (newpos == i-1 && posx == j - 1) {
                    return true;
                }
            }
        }
        return false;
    }

}
",5934,217,30.409574468085108,80,0.009216589861751152,0.11981566820276497,0.055299539170506916,0.004608294930875576,0.34101382488479265,0.004608294930875576,0.12442396313364056,0.0,True,False,True,False,True,False,3,0.027649769585253458,0.03686635944700461,0.059907834101382486,0.009216589861751152,0.6267281105990783,0.11059907834101383,0.004608294930875576,4.28,9,7.5,8
student16,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Moveable {

    Integer current_X = 0;
    Integer current_Y = 2;
    Integer MAX_X = 11;
    Integer MAX_Y = 8;
    @Override
    public String move(String moveCommandString) {
        var direction = moveCommandString.substring(1,3);
        var movement = Integer.valueOf(moveCommandString.substring(4,5));
        if(direction.equals(""no"")){
            if(current_Y <= 4 && current_X >= 4 && current_X <= 6){
                current_Y += movement;
                if(current_Y > 4) current_Y = 4;
            }
            else{
                current_Y += movement;
                if(current_Y > MAX_Y) current_Y = MAX_Y;
            }
        }
        else if(direction.equals(""so"")){
            if(current_Y >= 5 && current_X >= 4 && current_X <= 6){
                current_Y -= movement;
                if(current_Y < 5) current_Y = 5;
            }
            else{
                current_Y -= movement;
                if(current_Y < 0) current_Y = 0;
            }
        }
        else if(direction.equals(""ea"")){
            if(current_X <= 2 && current_Y >= 0 && current_Y <= 2){
                current_X += movement;
                if(current_X > 2) current_X = 2;
            }
            else if(current_X >= 3 && current_X <= 4 && current_Y >= 0 && current_Y <= 2){
                current_X += movement;
                if(current_X > 4) current_X = 4;
            }
            else if(current_X <= 4 && current_Y == 3){
                current_X += movement;
                if(current_X > 4) current_X = 4;
            }
            else if(current_X <= 6 && current_Y >= 5 && current_Y <= 8){
                current_X += movement;
                if(current_X > 6) current_X = 6;
            }
            else{
                current_X += movement;
                if(current_X > MAX_X) current_X = MAX_X;
            }
        }
        else if(direction.equals(""we"")){
            if(current_X >= 3 && current_X <= 4 && current_Y >= 0 && current_Y <= 2){
                current_X -= movement;
                if(current_X < 3) current_X = 3;
            }
            else if(current_X >= 5 && current_Y >= 0 && current_Y <= 3){
                current_X -= movement;
                if(current_X < 5) current_X = 5;
            }
            else if(current_X >= 7 && current_Y >= 5 && current_Y <= 8){
                current_X -= movement;
                if(current_X < 7) current_X = 7;
            }
            else{
                current_X -= movement;
                if(current_X < 0) current_X = 0;
            }
        }
        String returnString = String.format(""(%d,%d)"",current_X,current_Y);
        return returnString;
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String move(String moveCommandString);
}
",2885,82,35.93589743589744,90,0.0,0.3170731707317073,0.012195121951219513,0.0,0.7560975609756098,0.0,0.04878048780487805,0.0,False,False,True,False,False,False,2,0.024390243902439025,0.04878048780487805,0.036585365853658534,0.012195121951219513,1.0609756097560976,0.0975609756097561,0.0,8.0,12,0.0,0
student17,student,,,"package thkoeln.st.st2praktikum.exercise;

import thkoeln.st.st2praktikum.exercise.BitPaw.MoveCommand;
import thkoeln.st.st2praktikum.exercise.BitPaw.Point;
import thkoeln.st.st2praktikum.exercise.BitPaw.Room;

public class Exercise0 implements Moveable
{
    private final Room _room = new Room();

    @Override
    public String moveTo(String moveCommandString)
    {
        MoveCommand moveCommand = new MoveCommand(moveCommandString);
        Point currentPosition = _room.MoveRoboter(moveCommand);

        return currentPosition.toString();
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Moveable
{
    String moveTo(String moveCommandString);
}

package thkoeln.st.st2praktikum.exercise.BitPaw;

public enum Axis
{
    Horizontal,
    Vertical
}

package thkoeln.st.st2praktikum.exercise.BitPaw;

public class Barrier
{
    private Point _from;
    private Point _to;

    public Point From() {return _from;}
    public Point To() {return _to;}

    public Axis Orientation;

    public Barrier(int xA, int yA, int xB, int yB)
    {
        Set(xA, yA, xB, yB);
    }

    public Barrier(Point from, Point to)
    {
        Set(from, to);
    }

    public void Set(int xA, int yA, int xB, int yB)
    {
        Set(new Point(xA, yA), new Point(xB, yB));
    }

    public void Set(Point from, Point to)
    {
        boolean isXSame = from.X == to.X;
        boolean isYSame = from.Y == to.Y;
        boolean isLiniar = (isXSame || isYSame) && !(isXSame && isYSame);

        if(!isLiniar)
        {
            throw new IllegalArgumentException();
        }

        if(isXSame)
        {
            Orientation = Axis.Vertical;
        }

        if(isYSame)
        {
            Orientation = Axis.Horizontal;
        }

        _from = from;
        _to = to;
    }

    public int GetWallOriantationValue()
    {
        switch (Orientation)
        {

            case Horizontal:
                return From().Y;

            default:
            case Vertical:
                return From().X;
        }
    }

    public boolean Collide(final Point point)
    {
        return Collide(point, Axis.Horizontal) && Collide(point, Axis.Vertical);
    }

    @Override
    public String toString()
    {
        return  _from + ""-"" + _to + ""("" + Orientation + "")"";
    }

    public boolean Collide(final Point point, final Axis axis)
    {
        final int x = point.X;
        final int y = point.Y;

        switch (axis)
        {
            case Vertical:
            {
                final int xMax = Math.max(_from.X, _to.X);
                final int xMin = Math.min(_from.X, _to.X);

                return  x < xMax && x >= xMin;
            }

            default:
            case Horizontal:
            {
                final int yMax = Math.max(_from.Y, _to.Y);
                final int yMin = Math.min(_from.Y, _to.Y);

                return y < yMax && y >= yMin;
            }
        }
    }
}
package thkoeln.st.st2praktikum.exercise.BitPaw;

public class MoveCommand
{
    public MoveDirection Direction;
    public int MoveLength;
    public Axis Orientation;
    public boolean IsPositiveDirection;

    public MoveCommand(final MoveDirection direction,  final int moveLength)
    {
        Direction = direction;
        MoveLength = moveLength;
    }

    public MoveCommand(final String command)
    {
        int firstComma = command.indexOf(',');
        int lengh = command.length();
        boolean validLength = lengh >= 6;
        boolean leftBracket;
        boolean rightBacket;
        String tempString;

        if(!validLength)
        {
            Direction = MoveDirection.None;
            return;
        }

        leftBracket = '[' == command.charAt(0);
        rightBacket = ']' == command.charAt(lengh-1);

        tempString = command.substring(1,firstComma);

        switch (tempString)
        {
            case ""no"": // (north),
                Direction = MoveDirection.Up;
                Orientation = Axis.Vertical;
                IsPositiveDirection = true;
                break;

            case ""ea"": // (east),
                Direction = MoveDirection.Right;
                Orientation = Axis.Horizontal;
                IsPositiveDirection = true;
                break;

            case ""so"": // (south),
                Direction = MoveDirection.Down;
                Orientation = Axis.Vertical;
                IsPositiveDirection = false;
                break;

            case ""we"": // (west).
                Direction = MoveDirection.Left;
                Orientation = Axis.Horizontal;
                IsPositiveDirection = false;
                break;
        }

        // Parse movement length
        tempString =  command.substring(firstComma+1, lengh-1);

        MoveLength = Integer.parseInt(tempString);
    }

    public Point ConvertToPoint()
    {
        Point point = new Point();

        switch (Direction)
        {
            case Up:
                point.Set(0, MoveLength);
                break;

            case Down:
                point.Set(0, -MoveLength);
                break;

            case Left:
                point.Set(-MoveLength, 0);
                break;

            case Right:
                point.Set(MoveLength, 0);
                break;
        }

        return point;
    }

    @Override
    public boolean equals(Object o)
    {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        MoveCommand that = (MoveCommand) o;

        return equals(that);
    }

    public boolean equals(MoveCommand moveCommand)
    {
        return (MoveLength == moveCommand.MoveLength) && (Direction == moveCommand.Direction);
    }

    @Override
    public String toString()
    {
        String directionTag;

        switch (Direction)
        {
            case Up:
                directionTag = ""no"";
                break;

            case Down:
                directionTag = ""so"";
                break;

            case Left:
                directionTag = ""we"";
                break;

            case Right:
                directionTag = ""ea"";
                break;

            default:
                directionTag = ""ERROR"";
                break;
        }

        return ""["" +directionTag + "","" + MoveLength + ""]"";
    }
}

package thkoeln.st.st2praktikum.exercise.BitPaw;

public enum MoveDirection
{
    None,
    Up,
    Down,
    Left,
    Right
}

package thkoeln.st.st2praktikum.exercise.BitPaw;

import com.fasterxml.jackson.databind.node.POJONode;
import org.springframework.data.domain.Sort;

public class Point
{
    public int X;
    public int Y;

    public Point()
    {
        Set(0, 0);
    }

    public Point(int x, int y)
    {
        Set(x, y);
    }

    public void Set(int x, int y)
    {
        X = x;
        Y = y;
    }

    public void Add(Point point)
    {
        X += point.X;
        Y += point.Y;
    }

    public static boolean IsBNearer(Point reference, int x, int y, MoveDirection direction)
    {
        int xDiff;
        int yDiff;

        switch (direction)
        {
            case Up:
                xDiff = Math.abs(x - reference.Y);
                yDiff = Math.abs(y - reference.Y);
                return xDiff > yDiff;


            case Down:
                xDiff = Math.abs(x - reference.Y);
                yDiff = Math.abs(y - reference.Y);
                return xDiff > yDiff;

            case Left:
                xDiff = Math.abs(x - reference.X);
                yDiff = Math.abs(y - reference.X);
                return xDiff > yDiff;

            default:
            case Right:
                xDiff = Math.abs(x - reference.X);
                yDiff = Math.abs(y - reference.X);
                return xDiff > yDiff;
        }


    }

    public boolean IsBNearer(Point a, Point b)
    {
        int xDiffA = Math.abs(a.X - X);
        int yDiffA = Math.abs(a.Y - Y);
        int xDiffB = Math.abs(b.X - X);
        int yDiffB = Math.abs(b.Y - Y);

        int deltaX = Math.abs(xDiffA - xDiffB );
        int deltaY = Math.abs(yDiffA - yDiffB );

        if(deltaX > deltaY)
        {
            // Look at X
            return xDiffA < xDiffB;
        }
        else
        {
            // Loook at Y
            return yDiffA < yDiffB;
        }
    }

    @Override
    public String toString()
    {
        return ""("" + X + "","" + Y + ')';
    }
}

package thkoeln.st.st2praktikum.exercise.BitPaw;

public class Robot
{
    public Point CurrentPosition;

    public Robot(Point startPosition)
    {
        CurrentPosition = startPosition;
    }
}

package thkoeln.st.st2praktikum.exercise.BitPaw;

import org.springframework.data.domain.Sort;

import javax.persistence.ManyToOne;

public class Room
{
    private Barrier[] _barrierList;
    private final Robot _robot;
    private final Point _roomMaxIndex;

    private boolean _ignoreBarrier = true;

    public Room()
    {
        final Point startPosition = new Point(0,2);
        final int width = 12;
        final int height = 9;

        _roomMaxIndex = new Point(width,height);

        _robot = new Robot(startPosition);


if(_ignoreBarrier)
{
    _barrierList = new Barrier[4];
    _barrierList[0] = new Barrier(3,0,3,3);
    _barrierList[1] = new Barrier(5,0,5,4);
    _barrierList[2] = new Barrier(4,5,7,5);
    _barrierList[3] = new Barrier(7,5,7,9);
}


    }

    private boolean Between(int a, int b, int value)
    {
        int max = Math.max(a, b);
        int min = Math.min(a, b);

        return min < value && value < max;
    }

    private MoveCommand GetNextPossibleMove(final MoveCommand move)
    {
        int nearestWall;
        int maximalSteps = Integer.MAX_VALUE;

        // Get worldBorder
        switch (move.Direction)
        {
            case Up:
                nearestWall = _roomMaxIndex.Y;
                break;

            case Down:
            case Left:
                nearestWall = -1;
                break;

            default:
            case Right:
                nearestWall = _roomMaxIndex.X;
                break;
        }

        for (Barrier barrier : _barrierList) // Go thru every barrier
        {
            if (move.Orientation != barrier.Orientation)  // Get only the barriers with opposite axis
            {
                // Are we in collidable direction?
                boolean canCollide = barrier.Collide(_robot.CurrentPosition, move.Orientation);

                if (canCollide)
                {
                    int barrierValue = barrier.GetWallOriantationValue();

                    // We can collide with the wall

                    // Check for range

                    if(Point.IsBNearer(_robot.CurrentPosition,nearestWall, barrierValue, move.Direction))
                    {
                        nearestWall = barrierValue;
                    }

                    /*
                    // Is the wall nearer to the object
                    if (move.IsPositiveDirection) {
                        if (nearestWall > barrierValue && Point.IsBNearer(_robot.CurrentPosition,nearestWall, barrierValue, move.Direction)) {
                            // Wall is nearer
                            nearestWall = barrierValue;
                        }
                    } else {
                        if (nearestWall < barrierValue && Point.IsBNearer(_robot.CurrentPosition,nearestWall,barrierValue, move.Direction)) {
                            // Wall is nearer
                            nearestWall = barrierValue;
                        }
                    }
*/


                }
            }
        }







            // Get worldBorder
            switch (move.Direction)
            {
                case Down:
                {
                    int wantedPos = _robot.CurrentPosition.Y - move.MoveLength;
                    int wallPos = nearestWall;
                    int movelength = move.MoveLength;

                    if(wantedPos < 0) // If we overflow at the bottom, all remaining fields are the move
                    {
                        movelength = _robot.CurrentPosition.Y;
                    }

                    if(wantedPos > wallPos)
                    {
                        maximalSteps = movelength + (wantedPos - wallPos);
                    }
                    else
                    {
                        maximalSteps = movelength;
                    }
                    break;
                }

                case Left:
                    {
                        int wantedPos = _robot.CurrentPosition.X - move.MoveLength;
                        int wallPos = nearestWall;
                        int movelength = move.MoveLength;

                        if(wantedPos < 0) // If we overflow at the bottom, all remaining fields are the move
                        {
                            movelength = _robot.CurrentPosition.X;
                        }

                        if(wantedPos > wallPos || Between(wantedPos, _robot.CurrentPosition.X, nearestWall))
                        {
                            maximalSteps = movelength + (wantedPos - wallPos);
                        }
                        else
                        {
                            maximalSteps = movelength;
                        }
                    break;
                }

                case Up:
                {
                    int wantedPos = _robot.CurrentPosition.Y + move.MoveLength;
                    int wallPos = nearestWall-1;
                    int movelength = move.MoveLength;

                    if(wantedPos > _roomMaxIndex.Y-1)
                    {
                        movelength = wantedPos - (wantedPos - _roomMaxIndex.Y-1);
                    }

                    if(wantedPos > wallPos)
                    {
                        maximalSteps = move.MoveLength - (wantedPos - wallPos);
                    }
                    else
                    {
                        maximalSteps = move.MoveLength;
                    }
                    break;
                }

                case Right:
                {
                    int wantedPos = _robot.CurrentPosition.X + move.MoveLength;
                    int wallPos = nearestWall-1;
                    int movelength = move.MoveLength;

                    if(wantedPos > _roomMaxIndex.X-1)
                    {
                        movelength = wantedPos - (wantedPos - _roomMaxIndex.X-1);
                    }

                    if(wantedPos > wallPos)
                    {
                        maximalSteps = move.MoveLength - (wantedPos - wallPos);
                    }
                    else
                    {
                        maximalSteps = move.MoveLength;
                    }
                    break;
                }
            }


        return new MoveCommand(move.Direction, maximalSteps);
    }

    public Point MoveRoboter(MoveCommand moveCommand)
    {
        final MoveCommand alteredMoveCommand = GetNextPossibleMove(moveCommand);
        final boolean hasChanged = moveCommand.equals(alteredMoveCommand);
        final Point movement = alteredMoveCommand.ConvertToPoint();
        final Point oldPosition =  new Point(_robot.CurrentPosition.X, _robot.CurrentPosition.Y);
        Point newPosition;

        _robot.CurrentPosition.Add(movement);

        newPosition =  _robot.CurrentPosition;

        System.out.println(""===================="");
        System.out.print(""Wanted: "" + moveCommand.toString());
        System.out.println("" CanDo: "" + alteredMoveCommand.toString());
        System.out.print(""Pos Before: "" + oldPosition.toString());
        System.out.println("" After: "" + newPosition.toString());

        return _robot.CurrentPosition;
    }
}",15908,627,30.93522267206478,142,0.03189792663476874,0.08293460925039872,0.004784688995215311,0.012759170653907496,0.09569377990430622,0.001594896331738437,0.19776714513556617,0.007974481658692184,True,False,False,True,False,False,9,0.03508771929824561,0.023923444976076555,0.0861244019138756,0.009569377990430622,0.4880382775119617,0.09888357256778309,0.011164274322169059,7.01063829787234,19,26.483870967741936,118
student18,student,,,"package thkoeln.st.st2praktikum.exercise;

import lombok.AllArgsConstructor;

import java.util.HashSet;

public class Exercise0 implements GoAble {

    public Exercise0(){
        createObstacles();
    }

    Position position = new Position(7,7);
    HashSet<Double> horizontalObstacles = new HashSet<>();
    HashSet<Double> verticalObstacles = new HashSet<>();

    @Override
    public String goTo(String goCommandString) {
        String[] input = goCommandString.replace(""["","""").replace(""]"","""").split("","");
        String direction = input[0];
        int distance = Integer.parseInt(input[1]);

        move(direction, distance);

        return position.toString();
    }

    public void move(String direction, int distance) {
        while(distance>0) {
            if (direction.equals(""no"") && !(isObstacle(position.x, position.y+1, direction) || position.y==7))
                position.y++;
            else if (direction.equals(""ea"") && !(isObstacle(position.x+1, position.y, direction) || position.x==10))
                position.x++;
            else if (direction.equals(""so"") && !(isObstacle(position.x, position.y, direction) || position.y==0))
                position.y--;
            else if (direction.equals(""we"") && !(isObstacle(position.x, position.y, direction) || position.x==0))
                position.x--;
            else
                break;
            distance--;
        }
    }

    @AllArgsConstructor
    public class Position{
        public Integer x;
        public Integer y;

        @Override
        public String toString() {
            return ""("" + x.toString() + "","" + y.toString() + "")"";
        }
    }

    public Boolean isObstacle(int x, int y, String direction) {
        Double pos = Double.valueOf(Integer.toString(x).concat(""."").concat(Integer.toString(y)));
        if (direction.equals(""no"") || direction.equals(""so""))
            return horizontalObstacles.contains(pos);
        else
            return verticalObstacles.contains(pos);
    }

    public void createObstacles(){
        horizontalObstacles.add(2.6);
        horizontalObstacles.add(3.6);
        horizontalObstacles.add(4.6);
        horizontalObstacles.add(5.6);
        horizontalObstacles.add(6.6);

        horizontalObstacles.add(2.1);
        horizontalObstacles.add(3.1);
        horizontalObstacles.add(4.1);
        horizontalObstacles.add(5.1);
        horizontalObstacles.add(6.1);
        horizontalObstacles.add(7.1);
        horizontalObstacles.add(8.1);
        horizontalObstacles.add(9.1);

        verticalObstacles.add(2.5);
        verticalObstacles.add(2.4);
        verticalObstacles.add(2.3);
        verticalObstacles.add(2.2);
        verticalObstacles.add(2.1);

        verticalObstacles.add(10.1);
        verticalObstacles.add(10.2);
        verticalObstacles.add(10.3);
        verticalObstacles.add(10.4);
        verticalObstacles.add(10.5);
        verticalObstacles.add(10.6);
        verticalObstacles.add(10.7);
        verticalObstacles.add(10.8);
    }

}

package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String goTo(String goCommandString);
}
",3143,101,37.09756097560975,116,0.0,0.04950495049504951,0.0,0.0,0.7524752475247525,0.0,0.18811881188118812,0.0,False,False,True,False,False,False,2,0.0594059405940594,0.04950495049504951,0.039603960396039604,0.019801980198019802,0.297029702970297,0.5148514851485149,0.019801980198019802,4.5,9,0.0,0
student19,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Cell {
    private boolean borderNorth;
    private boolean borderEast;
    private boolean borderSouth;
    private boolean borderWest;

    public Cell() {
        this.borderNorth = false;
        this.borderEast = false;
        this.borderSouth = false;
        this.borderWest = false;
    }

    public boolean isBorderNorth() {
        return borderNorth;
    }

    public void setBorderNorth(boolean borderNorth) {
        this.borderNorth = borderNorth;
    }

    public boolean isBorderEast() {
        return borderEast;
    }

    public void setBorderEast(boolean borderEast) {
        this.borderEast = borderEast;
    }

    public boolean isBorderSouth() {
        return borderSouth;
    }

    public void setBorderSouth(boolean borderSouth) {
        this.borderSouth = borderSouth;
    }

    public boolean isBorderWest() {
        return borderWest;
    }

    public void setBorderWest(boolean borderWest) {
        this.borderWest = borderWest;
    }
}

package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements GoAble {

    private final Cell[][] cellGrid;
    private int cleaningDeviceX = 1;
    private int cleaningDeviceY = 6;
    private final int xDimension = 11;
    private final int yDimension = 8;

    public Exercise0() {
        cellGrid = new Cell[xDimension][yDimension];

        for (int i = 0; i < xDimension; i++) {
            for (int j = 0; j < yDimension; j++) {
                cellGrid[i][j] = new Cell();
            }
        }

        setBorder(0, 6, 1, 6);
        setBorder(3, 6, 3, 7);
        setBorder(1, 5, 8, 5);
        setBorder(9, 1, 9, 4);
    }

    private void setBorder(int startX, int startY, int endX, int endY) {
        if ((endX - startX) != 0) {

            for (int i = startX; i <= endX; i++) {
                cellGrid[i][startY].setBorderSouth(true);
                cellGrid[i][startY - 1].setBorderNorth(true);
            }

        } else if ((endY - startY) != 0) {

            for (int i = startY; i <= endY; i++) {
                cellGrid[startX][i].setBorderWest(true);
                cellGrid[startX - 1][i].setBorderEast(true);
            }

        }
    }

    @Override
    public String goTo(String goCommandString) {
        String[] commands = goCommandString.split("","");
        String direction = commands[0].substring(1);
        int count = Integer.parseInt(commands[1].substring(0, commands[1].length() - 1));

        switch (direction) {
            case ""no"":
                this.moveNorth(count);
                break;
            case ""ea"":
                this.moveEast(count);
                break;
            case ""so"":
                this.moveSouth(count);
                break;
            case ""we"":
                this.moveWest(count);
                break;
        }

        return ""("" + this.cleaningDeviceX + "","" + this.cleaningDeviceY + "")"";
    }

    private void moveNorth(int count) {
        for (int i = count; i > 0; i--) {
            if (!this.cellGrid[this.cleaningDeviceX][this.cleaningDeviceY].isBorderNorth() &&
                    this.cleaningDeviceY + 1 < this.yDimension) {
                this.cleaningDeviceY++;
            } else return;
        }
    }

    private void moveEast(int count) {
        for (int i = count; i > 0; i--) {
            if (!this.cellGrid[this.cleaningDeviceX][this.cleaningDeviceY].isBorderEast() &&
                    this.cleaningDeviceX + 1 < this.xDimension) {
                this.cleaningDeviceX++;
            } else return;
        }
    }

    private void moveSouth(int count) {
        for (int i = count; i > 0; i--) {
            if (!this.cellGrid[this.cleaningDeviceX][this.cleaningDeviceY].isBorderSouth() &&
                    this.cleaningDeviceY - 1 >= 0) {
                this.cleaningDeviceY--;
            } else return;
        }
    }

    private void moveWest(int count) {
        for (int i = count; i > 0; i--) {
            if (!this.cellGrid[this.cleaningDeviceX][this.cleaningDeviceY].isBorderWest() &&
                    this.cleaningDeviceX - 1 >= 0) {
                this.cleaningDeviceX--;
            } else return;
        }
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String goTo(String goCommandString);
}
",4346,157,32.98425196850393,93,0.0,0.03821656050955414,0.050955414012738856,0.006369426751592357,0.3057324840764331,0.0,0.1910828025477707,0.0,True,False,False,False,False,False,3,0.09554140127388536,0.05732484076433121,0.01910828025477707,0.012738853503184714,0.6114649681528662,0.1337579617834395,0.0,8.0,15,0.0,0
student2,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Moveable {
    private int x = 0;
    private int y = 2;

    @Override
    public String moveTo(String moveCommandString) {
        char[] searchNum = moveCommandString.toCharArray();
        StringBuilder stringBuilder = new StringBuilder();
        for(char i : searchNum){
            if(Character.isDigit(i)){
                stringBuilder.append(i);
            }
        }

        int move = 0;
        if(stringBuilder == null) throw new RuntimeException();
        else move = Integer.parseInt(stringBuilder.toString());

        if(moveCommandString.contains(""no"")){
            int y1 = y + move;

            if(y1 >= 9) y1 = 8;
            else if((x >= 4 && x <= 6) && y1 >= 5 && y < 5) y1 = 4;

            y = y1;
        }
        else if(moveCommandString.contains(""ea"")){
            int x1 = x + move;

            if(x1 >= 12) x1 = 11;
            else if(y >= 0 && y <= 2){
                if(x1 >= 3 && x < 3) x1 = 2;
                else if(x1 >= 5 && (x == 3 || x == 4)) x1 = 4;
            }
            else if(y == 3 && x1 >= 5) x1 = 4;
            else if((y >= 5 && y <= 8) && x1 >= 7 && x < 7) x1 = 6;

            x = x1;
        }
        else if(moveCommandString.contains(""so"")){
            int y2 = y - move;

            if(y2 < 0) y2 = 0;
            else if((x >=4 && x <= 6) && y2 < 5 && y >=5) y2 = 5;

            y = y2;
        }
        else if(moveCommandString.contains(""we"")){
            int x2 = x - move;

            if(x2 < 0) x2 = 0;
            else if(y >= 0 && y <= 2){
                if(x2 < 5 && x >= 5) x2 = 5;
                else if(x2 < 3 && (x == 3 || x == 4)) x2 = 3;
            }
            else if(y == 3 && x2 < 5) x2 = 5;
            else if((y >= 5 && y <= 8) && x2 < 7 && x >= 7) x2 = 7;

            x = x2;
        }

        return ""(""+x+"",""+y+"")"";
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String moveTo(String moveCommandString);
}
",2032,72,34.3859649122807,67,0.0,0.3055555555555556,0.013888888888888888,0.0,1.3333333333333333,0.013888888888888888,0.20833333333333334,0.0,False,False,False,False,False,True,2,0.027777777777777776,0.027777777777777776,0.09722222222222222,0.013888888888888888,1.0416666666666667,0.125,0.0,3.7,13,0.0,0
student20,student,,,"package thkoeln.st.st2praktikum.exercise;

import java.util.ArrayList;

public class Exercise0 implements Walkable {

    private  Wall [] wallsvertical = {new Wall(5, 6, 2), new Wall(5, 6, 3), new Wall(5, 6, 4), new Wall(5, 6, 5), new Wall(5, 6, 6), new Wall(5, 6, 7), new Wall(3, 4, 1), new Wall(3, 4, 2)};// Hier werden die Positionen der senkrechten Mauern gespeichert

    private  Wall []wallshorizontal = {new Wall(2,3,3), new Wall(2,3,4), new Wall(2,3,5), new Wall(2,3,6), new Wall(2,3,7), new Wall(2,3,8), new Wall(5,6,1), new Wall(5,6,2), new Wall(5,6,3), new Wall(5,6,4), new Wall(5,6,5) }; // Hier werden die Positionen der waagerechten Mauern gespeichert
    private int x_koordinate = 5;
    private int y_koordinate = 3;
    private int limit = 0;
    @Override
    public String walkTo(String walkCommandString) {
          // So wird die Mauer hinzugefügt und zum Vergleich gespeichert
        String pointOfTheCompas = """" + walkCommandString.charAt(1) + walkCommandString.charAt(2);
        String [] devidedString = walkCommandString.split("","");
        String []numberOfStepsAndSquareBracket  = devidedString[1].split(""]"");
        int numberOfSteps = Integer.parseInt(numberOfStepsAndSquareBracket [0]);
        System.out.println(numberOfSteps);
        boolean isWallhere = false;
        String actuallyPosition = """";//aktuelle Position der Turtle

        switch(pointOfTheCompas){
            case ""no"":{
                limit = y_koordinate + numberOfSteps;
                int y = 0;
                for( y = y_koordinate; y <= limit; y++){
                    for(Wall wall : wallshorizontal){
                        if(y == wall.befor && x_koordinate == wall.posWall){
                            isWallhere = true;
                            break;
                        }
                    }
                    actuallyPosition = ""(""+ x_koordinate +"",""+ y + "")"";
                    y_koordinate = y;
                    if(isWallhere || y >= 7){
                        isWallhere = false;
                        break; //Kommt eine Mauer in die Quere oder bin ich am obersten Rand? Dann bleibe ich stehen
                    }
                }

            }
            break;
            case ""we"":{
                limit = (x_koordinate - numberOfSteps);
                int x = 0;
                for(x = x_koordinate; x >= limit; x--) {
                    for (Wall wall : wallsvertical) {
                        if (x == wall.behind && y_koordinate == wall.posWall) {
                            isWallhere = true;
                            break;
                        }
                    }
                    actuallyPosition = ""("" + x + "","" + y_koordinate + "")"";
                    x_koordinate = x;
                    if (isWallhere || x <= 0) {
                        isWallhere = false;
                        break;
                    }
                }

            }
            break;
            case ""so"":{
                limit = (y_koordinate - numberOfSteps);
                int y = 0;
                for( y = y_koordinate; y >= limit; y--){
                    for(Wall wall : wallshorizontal){
                        if(y == wall.behind && x_koordinate == wall.posWall){
                            isWallhere = true;
                            break;
                        }
                    }
                    actuallyPosition = ""(""+ x_koordinate +"",""+ y + "")"";
                    y_koordinate = y;
                    if(isWallhere || y <= 0){
                        isWallhere = false;
                        break;
                    }
                }
            }
            break;
            case ""ea"":{
                limit = (x_koordinate + numberOfSteps);
                int x = 0;
                for( x = x_koordinate; x <= limit; x++){
                    for(Wall wall : wallsvertical){
                        if(x == wall.befor && y_koordinate == wall.posWall){
                            isWallhere = true;
                            break;
                        }
                    }
                    actuallyPosition = ""(""+ x +"",""+ y_koordinate + "")"";
                    x_koordinate = x;
                    if(isWallhere || x >= 11){
                        isWallhere = false;
                        break; //Kommt eine Mauer in die Quere oder bin ich am obersten Rand? Dann bleibe ich stehen
                    }
                }

            }
            break;
            default:
                throw new IllegalStateException(""Bitte geben sie eine Himmelsrichtung an"" + pointOfTheCompas);
        }


        return actuallyPosition ;
    }

}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);
}

package thkoeln.st.st2praktikum.exercise;

public class Wall {
    public int befor, behind, posWall = -1;
    public Wall(int before, int after, int wall){
        befor = before;
        behind = after;
        posWall = wall;
    }
}
",5048,129,43.14912280701754,293,0.046511627906976744,0.06201550387596899,0.10852713178294573,0.007751937984496124,0.6046511627906976,0.007751937984496124,0.10852713178294573,0.007751937984496124,True,False,False,False,False,False,3,0.015503875968992248,0.06201550387596899,0.07751937984496124,0.015503875968992248,0.7751937984496124,0.046511627906976744,0.007751937984496124,9.409090909090908,29,62.666666666666664,83
student21,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Moveable {

    // 9x12 da noch die äußeren Ränder selber Grenzen sind
    public int[][] room = {
            {0,0,0,0,0,0,0,0,0,0,0,3},
            {0,0,0,0,0,0,0,0,0,1,0,3},
            {0,0,0,0,0,0,0,0,0,1,0,3},
            {0,0,0,0,0,0,0,0,0,1,0,3},
            {0,0,0,0,0,0,0,0,0,1,0,3},
            {0,1,1,1,1,1,1,1,1,1,0,3},
            {2,2,2,3,0,0,0,0,0,0,0,3},
            {0,0,0,3,0,0,0,0,0,0,0,3},
            {3,3,3,3,3,3,3,3,3,3,3,3}
    };
    // initial Value serves as starting Position
    public int[] currPos = {6,1};

    @Override
    public String move(String moveCommandString) {
        // no +,0 | ea 0,+ | so -,0 | we 0,-
        // java arrays[y-axis][x-axis]

        String numb = moveCommandString.substring(moveCommandString.indexOf("","")+1,moveCommandString.indexOf(""]""));
        int steps = Integer.parseInt(numb);
        while(steps!=0){
            if(moveCommandString.contains(""no"")){
                if(currPos[0]+1 <= 8 && currPos[1]+1 <= 11){
                    if((room[currPos[0]+1][currPos[1]]
                       != room[currPos[0]+1][currPos[1]+1]
                       || room[currPos[0]+1][currPos[1]]==0
                       || room[currPos[0]+1][currPos[1]+1]==0)
                       && currPos[0]+1 < 8){
                        this.currPos[0] += 1;
                    }
                }
            }
            if(moveCommandString.contains(""so"")){
                if(currPos[1]+1 <= 11){
                    if((room[currPos[0]][currPos[1]]
                       != room[currPos[0]][currPos[1]+1]
                       || room[currPos[0]][currPos[1]]==0
                       || room[currPos[0]][currPos[1]+1]==0)
                       && currPos[0]-1 >= 0){
                        this.currPos[0] -= 1;
                    }
                }
            }
            if(moveCommandString.contains(""ea"")){
                if(currPos[0]+1 <= 8 && currPos[1]+1 <= 11){
                    if((room[currPos[0]][currPos[1]+1]
                       != room[currPos[0]+1][currPos[1]+1]
                       || room[currPos[0]][currPos[1]+1]==0
                       || room[currPos[0]+1][currPos[1]+1]==0)
                       && currPos[1]+1 < 11){
                        this.currPos[1] += 1;
                    }
                }
            }
            if(moveCommandString.contains(""we"")){
                if(currPos[0]+1 <= 8){
                    if((room[currPos[0]][currPos[1]]
                       != room[currPos[0]+1][currPos[1]]
                       || room[currPos[0]][currPos[1]]==0
                       || room[currPos[0]+1][currPos[1]]==0)
                       && currPos[1]-1 >= 0){
                        this.currPos[1] -= 1;
                    }
                }
            }
            steps--;
        }
        String retPos = ""(""+currPos[1]+"",""+currPos[0]+"")"";
        return retPos;
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String move(String moveCommandString);
}
",3106,83,39.25974025974026,115,0.04819277108433735,0.14457831325301204,0.0,0.0,2.674698795180723,0.0,0.07228915662650602,0.0,False,False,False,False,False,False,2,0.024096385542168676,0.024096385542168676,0.03614457831325301,0.012048192771084338,0.8192771084337349,0.0963855421686747,0.0,5.2,7,38.0,51
student23,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Border {
    Coordinate start;
    Coordinate end;
    String axis;

    public Border (Coordinate start, Coordinate end, String axis) {
        if (start.getX() < end.getX() || start.getY() < end.getY()) {
            this.start = start;
            this.end = end;
        } else {
            this.start = end;
            this.end = start;
        }

        this.axis = axis;
    }

    @Override
    public String toString() {
        return ""Start: "" + start + "" End: "" + end + "" Axis:"" + axis;
    }
}

package thkoeln.st.st2praktikum.exercise;

public class Coordinate {
    private int x;
    private int y;

    public Coordinate (int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return x;
    }

    public void setX(int x) {
        this.x = x;
    }

    public void incrementX (int amount) {
        this.x += amount;
    }

    public void decrementX (int amount) {
        this.x -= amount;
    }

    public int getY() {
        return y;
    }

    public void setY(int y) {
        this.y = y;
    }

    public void incrementY (int amount) {
        this.y += amount;
    }

    public void decrementY (int amount) {
        this.y -= amount;
    }


    @Override
    public String toString() {
        return ""("" + this.x + "","" + this.y + "")"";
    }
}

package thkoeln.st.st2praktikum.exercise;

import java.security.InvalidParameterException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Exercise0 implements Moveable {

    private static final boolean enableLogging = true;

    // Configure Defaults
    private final Coordinate startPosition = new Coordinate(0, 2);
    private final int gridHeight = 9;
    private final int gridWidth = 12;
    private final Border[] borders = {
            new Border(new Coordinate(3, 0), new Coordinate(3, 3), ""y""),
            new Border(new Coordinate(5, 0), new Coordinate(5, 4), ""y""),
            new Border(new Coordinate(7, 5), new Coordinate(7, 9), ""y""),
            new Border(new Coordinate(4, 5), new Coordinate(7, 5), ""x"")
    };

    // Robot Position
    private final Coordinate position;

    public Exercise0() {
        this.position = startPosition;
    }

    @Override
    public String moveTo(String moveCommandString) {
        Border relevantBorder;
        String direction = """";
        int amount = 0;

        // use Regex to parse command String to get direction (e.g. 'ea') and movement amount
        Pattern pattern = Pattern.compile(""\\[(.*)(?:,)(.*)]"");
        Matcher matcher = pattern.matcher(moveCommandString);
        while (matcher.find()) {
            direction = matcher.group(1);
            amount = Integer.parseInt(matcher.group(2));
        }

        if (enableLogging) {
            System.out.println(""Start Position: ("" + this.position.getX() + "","" + this.position.getY() + "")"");
            System.out.println(""move Command: "" + moveCommandString);
        }

        switch (direction) {
            case ""no"": {
                relevantBorder = this.getFirstRelevantBorder(""y"");
                this.position.incrementY(amount);
                this.clampPositionToBorder(relevantBorder, ""+y"");
            }
            break;
            case ""ea"": {
                relevantBorder = this.getFirstRelevantBorder(""x"");
                this.position.incrementX(amount);
                this.clampPositionToBorder(relevantBorder, ""+x"");
            }
            break;
            case ""so"": {
                relevantBorder = this.getFirstRelevantBorder(""y"");
                this.position.decrementY(amount);
                this.clampPositionToBorder(relevantBorder, ""-y"");
            }
            break;
            case ""we"": {
                relevantBorder = this.getFirstRelevantBorder(""x"");
                this.position.decrementX(amount);
                this.clampPositionToBorder(relevantBorder, ""-x"");
            }
            break;
            default:
                throw new InvalidParameterException();
        }

        this.clampPositionToGrid();

        if (enableLogging) {
            System.out.println(""End Position: ("" + this.position.getX() + "","" + this.position.getY() + "")"");
            System.out.println(""--------"");
        }

        return ""("" + this.position.getX() + "","" + this.position.getY() + "")"";
    }

    private void clampPositionToGrid() {
        if (this.position.getX() > this.gridWidth - 1) this.position.setX(this.gridWidth - 1);
        if (this.position.getY() > this.gridHeight - 1) this.position.setY(this.gridHeight - 1);
        if (this.position.getX() < 0) this.position.setX(0);
        if (this.position.getY() < 0) this.position.setY(0);
    }

    /**
     * Clamp the position to respect impenetrable borders
     *
     * @param border       the border that has to be respected
     * @param movementAxis the direction of the movement
     */
    private void clampPositionToBorder(Border border, String movementAxis) {
        if (enableLogging) {
            System.out.println(""Position before Clamp: "" + this.position);
            System.out.println(""Movement: "" + movementAxis);
            System.out.println(""Border: "" + border);
        }

        if (border != null) {
            switch (movementAxis) {
                case ""+x"": {
                    if (border.start.getX() <= this.position.getX()) this.position.setX(border.start.getX() - 1);
                    break;
                }
                case ""+y"": {
                    if (border.start.getY() <= this.position.getY()) this.position.setY(border.start.getY() - 1);
                    break;
                }
                case ""-x"": {
                    if (border.start.getX() >= this.position.getX()) this.position.setX(border.start.getX());
                    break;
                }
                case ""-y"": {
                    if (border.start.getY() <= this.position.getY()) this.position.setY(border.start.getY());
                    break;
                }
                default:
                    throw new InvalidParameterException();
            }
        }

        if (enableLogging) {
            System.out.println(""Position after Border Clamp: "" + this.position);
        }
    }

    /**
     * @return get the nearest Border that is relevant to the next movement
     */
    private Border getFirstRelevantBorder(String axis) {
        Border[] relevantBorders = getRelevantBorders(axis);
        return relevantBorders.length > 0 ? relevantBorders[0] : null;
    }

    /**
     * @return Array with all borders that lie on the given axis and that are reachable by a straight move along the axis
     */
    private Border[] getRelevantBorders(String movementAxis) {
        ArrayList<Border> relevantBorders = new ArrayList<>();

        switch (movementAxis) {
            case ""x"": {
                Border[] bordersByAxis = this.getRelevantBordersByAxis(""y"");
                for (Border border : bordersByAxis) {
                    if (border.start.getY() <= this.position.getY() && border.end.getY() >= this.position.getY() + 1)
                        relevantBorders.add(border);
                }
                break;
            }
            case ""y"": {
                Border[] bordersByAxis = this.getRelevantBordersByAxis(""x"");
                for (Border border : bordersByAxis) {
                    if (border.start.getX() <= this.position.getX() && border.end.getX() >= this.position.getX() + 1)
                        relevantBorders.add(border);
                }
                break;
            }
            default:
                throw new InvalidParameterException();
        }

        return relevantBorders.toArray(size -> new Border[size]);
    }

    /**
     * @param axis axis in the grid
     * @return Array with all Borders that lie on the given axis
     */
    private Border[] getRelevantBordersByAxis(String axis) {
        Border[] relevantBorders = Arrays.stream(this.borders).filter(n -> n.axis.equals(axis)).toArray(size -> new Border[size]);

        switch (axis) {
            case ""x"": {
                Arrays.sort(relevantBorders, Comparator.comparingInt(b -> b.start.getY()));
                break;
            }
            case ""y"": {
                Arrays.sort(relevantBorders, Comparator.comparingInt(b -> b.start.getX()));
                break;
            }
            default:
                throw new InvalidParameterException();
        }

        return relevantBorders;
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String moveTo(String moveCommandString);
}
",8799,279,36.255319148936174,130,0.025089605734767026,0.05734767025089606,0.010752688172043012,0.014336917562724014,0.15770609318996415,0.014336917562724014,0.15412186379928317,0.02867383512544803,True,False,False,False,True,False,4,0.06093189964157706,0.03942652329749104,0.035842293906810034,0.010752688172043012,0.41935483870967744,0.3046594982078853,0.021505376344086023,7.52,17,37.46666666666667,116
student25,student,,,"package thkoeln.st.st2praktikum.exercise;

import org.springframework.data.util.Pair;


import javax.persistence.criteria.CriteriaBuilder;
import java.util.ArrayList;
import java.util.Iterator;



public class Exercise0 implements GoAble {

    private final int wide = 12;
    private final int lenght = 8;
    private boolean first = true;
    private int currX = 11;
    private int currY = 7;
    private ArrayList<Pair<Pair<Integer,Integer>,Pair<Integer,Integer>>> borders = new ArrayList<Pair<Pair<Integer,Integer>,Pair<Integer,Integer>>>();
    private ArrayList<Pair<Pair<Integer,Integer>,Pair<Integer,Integer>>> allBorders = new ArrayList<Pair<Pair<Integer,Integer>,Pair<Integer,Integer>>>();







    @Override
    public String goTo(String goCommandString) {
        if(first){
            this.first = false;
            borders.add(Pair.of(Pair.of(6,2),Pair.of(6,5)));
            borders.add(Pair.of(Pair.of(5,5),Pair.of(6,5)));
            borders.add(Pair.of(Pair.of(5,5),Pair.of(5,6)));
            borders.add(Pair.of(Pair.of(5,6),Pair.of(12,6)));

            for(Pair<Pair<Integer,Integer>,Pair<Integer,Integer>> border: borders){
                Pair<Integer,Integer> tmp1 = border.getFirst();
                Pair<Integer,Integer> tmp2 = border.getSecond();
                if(tmp1.getFirst() == tmp2.getFirst()){
                    for(int i = tmp1.getSecond(); i < tmp2.getSecond(); i++) {
                        allBorders.add(Pair.of(Pair.of(tmp1.getFirst(),i),Pair.of(tmp2.getFirst(),i+1)));
                    }
                }
                if(tmp1.getSecond() == tmp2.getSecond()){
                    for(int i = tmp1.getFirst(); i < tmp2.getFirst(); i++){
                        allBorders.add(Pair.of(Pair.of(i,tmp1.getSecond()),Pair.of(i+1,tmp2.getSecond())));
                    }
                }

            }
            for (Pair<Pair<Integer,Integer>,Pair<Integer,Integer>> border : allBorders) {
            }
        }
        goCommandString = goCommandString.substring(1,goCommandString.length()-1);
        String[] parts = goCommandString.split("","");
        String direction = parts[0];
        String steps = parts[1];
        for(int i = 0; i < Integer.parseInt(steps); i++){
            int tmpX = this.currX;
            int tmpY = this.currY;
            Pair<Pair<Integer,Integer>,Pair<Integer,Integer>> tmpBorder;
            switch (direction){
                case ""no"":
                    if(tmpY+1 == lenght) break;
                    tmpBorder = Pair.of(Pair.of(currX,currY+1),Pair.of(currX+1,currY+1));
                    if(!allBorders.contains(tmpBorder)){
                        currY++;
                    } break;
                case ""ea"":
                    if(tmpX+1 == wide) break;
                    tmpBorder = Pair.of(Pair.of(currX+1,currY),Pair.of(currX+1,currY+1));
                    if(!allBorders.contains(tmpBorder)){
                        currX++;
                    } break;
                case ""so"":
                    if(tmpY-1 == -1) break;
                    tmpBorder = Pair.of(Pair.of(currX,currY),Pair.of(currX+1,currY));
                    if(!allBorders.contains(tmpBorder)){
                        currY--;
                    } break;
                case ""we"":
                    if(tmpX-1 == -1) break;
                    tmpBorder = Pair.of(Pair.of(currX,currY),Pair.of(currX,currY+1));
                    if(!allBorders.contains(tmpBorder)){
                        currX--;
                    } break;
            }
        }
        return ""(""+currX+"",""+currY+"")"";
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String goTo(String goCommandString);
}
",3716,98,45.225,153,0.0,0.11224489795918367,0.05102040816326531,0.01020408163265306,0.6224489795918368,0.0,0.1326530612244898,0.0,True,False,False,False,True,False,2,0.02040816326530612,0.07142857142857142,0.08163265306122448,0.01020408163265306,0.5816326530612245,0.5918367346938775,0.04081632653061224,6.266666666666667,15,0.0,0
student26,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Walkable {

    private int x = 5;
    private int y = 3;


    @Override
    public String walk(String walkCommandString) {

        int input_x = 0;
        int input_y = 0;

        //String entwirren

        int i = Integer.parseInt(walkCommandString.substring(4, walkCommandString.length()).replace(']', ' ').trim());
        switch(walkCommandString.substring(1,3)) {
            case ""no"": input_y = i;break;
            case ""ea"": input_x = i;break;
            case ""so"": input_y = i *-1;break;
            case ""we"": input_x = i *-1;break;
        }


        /*Horizontal Waende
        1-5 / 6
        1-5 / 5
        -----------
        3-8 / 2
        3-8 / 3
        -----------
        min x / 0
        max x / 7
        */

        int temp_x = x + input_x;
        int temp_y = y + input_y;

        if (input_x == 0){
            if(y <= 2 && temp_y >= 3 && temp_x >= 3 && temp_x <= 8){
                temp_y = 2;
            }
            else if(y >= 3 && temp_y <= 2 && temp_x >= 3 && temp_x <= 8){
                temp_y = 3;
            }


            else if(y <= 5 && temp_y >= 6 && temp_x >= 1 && temp_x <= 5){
                temp_y = 5;
            }
            else if(y >= 6 && temp_y <= 5 && temp_x >= 1 && temp_x <= 5){
                temp_y = 6;
            }


            else if (temp_y > 7){
                temp_y = 7;
            }
            else if (temp_y < 0){
                temp_y = 0;
            }
            y = temp_y;
        }


        /*Vertical Waende
        3 / 1-2
        4 / 1-2
        -----------
        5 / 2-7
        6 / 2-7
        -----------
        min 0 / x
        max 11 / x
        */

        else if (input_y == 0){
            if(y <= 2 && temp_y >= 1 && x <= 3 && temp_x >= 4){
                temp_x = 3;
            }
            else if(y <= 2 && temp_y >= 1 && x >= 4 && temp_x <= 3){
                temp_x = 4;
            }



            else if(temp_y <= 7 && temp_y >= 2 && x <= 5 && temp_x >= 6) {
                temp_x = 5;
            }
            else if(temp_y <= 7 && temp_y >= 2 && x >= 6 && temp_x <= 5){
                temp_x = 6;
            }

            else if (temp_x > 11){
                temp_x = 11;
            }
            else if (temp_x < 0){
                temp_x = 0;
            }
            x = temp_x;
        }
        return (""("" +temp_x + "","" + temp_y + "")"");

    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",2597,112,28.563218390804597,118,0.026785714285714284,0.125,0.0,0.008928571428571428,0.8303571428571429,0.0,0.16964285714285715,0.0,False,False,False,False,False,False,2,0.017857142857142856,0.017857142857142856,0.044642857142857144,0.008928571428571428,0.6071428571428571,0.05357142857142857,0.0,4.142857142857143,7,9.947368421052632,19
student27,student,,,"package thkoeln.st.st2praktikum.exercise;

import javax.validation.constraints.NotNull;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Exercise0 implements Walkable {

    private int x = 11;
    private int y = 7;

    //private ArrayList<String> firstBlockade;
    private List<String> firstBlockade = Arrays.asList(""(6,2)"", ""(6,3)"", ""(6,4)"", ""(6,5)"");
    private List<String> secondBlockade = Arrays.asList(""(6,5)"",""(5,5)"" );
    private List<String> thirdBlockade = Arrays.asList(""(4,5)"",""(5,5)"");
    private List<String> fourthBlockade = Arrays.asList(""(6,6)"", ""(7,6)"", ""(8,6)"", ""(9,6)"", ""(10,6)"",""(11,6)"",""(12,6)"");


    @Override
    public String walkTo(String walkCommandString) {
        //throw new UnsupportedOperationException();
        StringBuilder numberOfSteps = new StringBuilder();
        String resultString = ""(""+ x + "","" + y + "")"";



        //checks if the string-parameter contains a correct direction
        if(walkCommandString.contains(""no"") || walkCommandString.contains(""ea"") || walkCommandString.contains(""so"")
                || walkCommandString.contains(""we"")){



            //reads the digits in the String and converts it to an int
            for(char s : walkCommandString.toCharArray()){
                if(Character.isDigit(s))
                    numberOfSteps.append(s);

            }
            String stringSteps = numberOfSteps.toString();
            int intSteps = Integer.parseInt(stringSteps);


            if(walkCommandString.contains(""no"")){
                if(intSteps == 0){return resultString;}

                if(intSteps == 1){
                    y++;
                    resultString = ""("" + x + "","" + y + "")"";
                    if(!secondBlockade.contains(resultString) && !fourthBlockade.contains(resultString)){
                        return resultString;
                    }else{
                        resultString = ""("" + x + "","" + y + "")"";
                        return resultString;
                    }
                }

                y++;
                resultString = ""("" + x + "","" + y + "")"";
                for(int i=0; i<intSteps; i++){
                    if(!secondBlockade.contains(resultString) && !fourthBlockade.contains(resultString)){
                        y++;
                        resultString = ""("" + x + "","" + y + "")"";
                    } else {
                        resultString = ""("" + x + "","" + y + "")"";
                        break;
                    }
                }

                if(y > 7){
                    y=7;
                    resultString = ""("" + x + "","" + y + "")"";
                }

            } else if (walkCommandString.contains(""so"")){

                for(int i=0; i<intSteps; i++){
                    if(!secondBlockade.contains(resultString) && !fourthBlockade.contains(resultString)){
                        y--;
                        resultString = ""("" + x + "","" + y + "")"";
                    } else {
                        resultString = ""("" + x + "","" + y + "")"";
                        break;
                    }
                }

                if(y<0){
                    y=0;
                    resultString = ""("" + x + "","" + y + "")"";
                }


            } else if (walkCommandString.contains(""ea"")){
                if(intSteps ==0){return resultString;}

                if(intSteps == 1){
                    x++;
                    resultString = ""("" + x + "","" + y + "")"";
                    if(!firstBlockade.contains(resultString) && !thirdBlockade.contains(resultString)){
                        x--;
                        resultString = ""("" + x + "","" + y + "")"";
                        return resultString;
                    }else{

                        return resultString;
                    }
                }

                x++;
                resultString = ""("" + x + "","" + y + "")"";
                for(int i=0; i<intSteps-1; i++){
                    if(!firstBlockade.contains(resultString) && !thirdBlockade.contains(resultString)){
                        x++;
                        resultString = ""("" + x + "","" + y + "")"";
                    } else {
                        x--;
                        resultString = ""("" + x + "","" + y + "")"";
                        break;//
                    }
                }


                if(x > 11){
                    x=11;
                    resultString = ""("" + x + "","" + y + "")"";
                }

            } else if(walkCommandString.contains(""we"")){
                /*x-=intSteps;*/
                for(int i=0; i<intSteps; i++){
                    if(!firstBlockade.contains(resultString) && !thirdBlockade.contains(resultString)){
                        x--;
                        resultString = ""("" + x + "","" + y + "")"";
                    } else{
                        resultString = ""("" + x + "","" + y + "")"";
                        break;}
                }

                if(x<0){
                    x=0;
                    resultString = ""("" + x + "","" + y + "")"";
                }
            }


        }
        //resultString = ""("" + x + "","" + y + "")"";

        return resultString;
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);
}
",5352,156,42.59016393442623,120,0.04487179487179487,0.1346153846153846,0.03205128205128205,0.0,0.3717948717948718,0.00641025641025641,0.17307692307692307,0.0,False,True,False,False,False,True,2,0.01282051282051282,0.038461538461538464,0.02564102564102564,0.00641025641025641,0.717948717948718,0.1858974358974359,0.02564102564102564,5.0,12,36.0,59
student28,student,,,"package thkoeln.st.st2praktikum.exercise;

//public class Exercise0 implements Walkable {

//    @Override
//    public String walk(String walkCommandString) {
//        throw new UnsupportedOperationException();
//    }
//}
 
public class Exercise0 implements Walkable {
	
    int xPos = 0;
    int yPos = 2;
    
    int[] left = {0,0,0,9}; //x1,y1,x2,y2
    int[] right = {12,0,12,9};
    int[] up = {0,9,12,9};
    int[] down = {0,0,12,0};
    int[] wall1 = {3,0,3,3};
    int[] wall2 = {5,0,5,4};
    int[] wall3 = {4,5,7,5}; 
    int[] wall4 = {7,5,7,9};
    
    int[][] walls = {left,right,up,down,wall1,wall2,wall3,wall4};


    @Override
    public String walk(String walkCommandString) {			 // ""[so,2]""
    	
    	 walkCommandString = walkCommandString.substring(1); // ""so,2]""
         String[] temp = walkCommandString.split("","");       // ""so"" & ""2]""
         String direction = temp[0];                         // ""so""
         temp = temp[1].split(""]"");                          // ""2"" & """"
         int stepCount = Integer.parseInt(temp[0]);          //  2

         for(int i = 0; i <= stepCount; i++){
        	 
             if(direction == ""we""){
                 for(int[] each : walls) {
                	 if( (each[0] == each[2] ) && (each[0] == xPos) && (Math.abs(yPos-(each[1]+each[3])/2) <= (Math.abs(each[1]-(each[1]+each[3])/2)))) {  
                		 return ""("" + xPos + "","" + yPos + "")"";
                	 }
                	 else { xPos--;}
                 }
             }
             
             if(direction == ""ea""){
                 for(int[] each : walls) {
                	 if( (each[0] == each[2] ) && (each[0] == xPos + 1) && (Math.abs(yPos-(each[1]+each[3])/2) <= (Math.abs(each[1]-(each[1]+each[3])/2)))) {
                		 return ""("" + xPos + "","" + yPos + "")"";
                	 }
                	 else { xPos++;}
                 }
             }
             
             if(direction == ""no""){
                 for(int[] each : walls) {
                	 if( (each[1] == each[3] ) && (each[1] == yPos + 1) && (Math.abs(xPos-(each[0]+each[2])/2) <= (Math.abs(each[0]-(each[0]+each[2])/2)))) {
                		 return ""("" + xPos + "","" + yPos + "")"";
                	 }
                	 else { yPos++;}
                 }
             }
             
             if(direction == ""so""){
                 for(int[] each : walls) {
                	 if( (each[1] == each[3] ) && (each[1] == yPos) && (Math.abs(xPos-(each[0]+each[2])/2) <= (Math.abs(each[0]-(each[0]+each[2])/2)))) {
                		 return ""("" + xPos + "","" + yPos + "")"";
                	 }
                	 else { yPos--;}
                 }
             }
         }
         return ""("" + xPos + "","" + yPos + "")"";
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",2867,83,36.63157894736842,154,0.1566265060240964,0.0963855421686747,0.060240963855421686,0.0,1.2771084337349397,0.012048192771084338,0.07228915662650602,0.0,False,False,False,False,False,False,2,0.024096385542168676,0.13253012048192772,0.03614457831325301,0.012048192771084338,0.9397590361445783,0.14457831325301204,0.0,5.411764705882353,17,14.846153846153847,46
student3,student,,,"package thkoeln.st.st2praktikum.exercise;


public class Exercise0 implements Walkable {

    /*
    x= 8  => 0..7
    y= 11 => 0..10
     */
    private int  achseX = 9;

    private int achseY = 12;

    private int achseXminus1 = achseX-1;
    private int achseYminus1 = achseY-1;

    private int feld[][] = new int[achseY][achseX];

    //aktuelle Positions des Roboters
    private int position[] = {7,7};


    @Override
    public String walk(String moveCommandString) {

        felden();

        //Extrahieren der Richtung
        // String richtung = (moveCommandString.substring(1, 3));
        String richtung = (moveCommandString.substring((moveCommandString.indexOf('[') + 1), (moveCommandString.indexOf(','))));
        // Extrahieren der Bewegungseinheiten
        // bewegungseinheiten = Integer.parseInt(moveCommandString.substring(4, 5));
        int  bewegungseinheiten = Integer.parseInt(moveCommandString.substring((moveCommandString.indexOf(',') + 1), (moveCommandString.indexOf(']'))));


        //Kontrollkram, später weg
        System.out.println();
        System.out.println();
        System.out.println(""Position  Zeile: "" + position[0]);
        System.out.println(""Position  Spalte: "" + position[1]);
        System.out.println(""Position Richtung: "" + richtung);
        System.out.println(""Position Bewegungseinheiten: "" + bewegungseinheiten);


        switch (richtung){


            case ""no"": {

                /*
                bewegen nach norden

                -------
                1.1 prüfen, ob ich bereits oben bin
                1.2 bewegung ist inhalt von position[1] um eine zeile erhöht
                vergleich das mit dem grid, ob da mauer ist
                wenn ja nicht bewegen
                wenn nein bewegen
                ------

                 */

                do{

                    //check ob in oberster Zeile also position[1] == 7
                    //statt break auch einfach ien return machen, geht auch
                    if (position[1] == 7) break;

                    //System.out.println(""Wert position0: ""+position[0]+"" Wert postion1 +1:  ""+(position[1]+1));

                    int temp_feldwert = feld[position[0]][(position[1]+1)];

                    //System.out.println(""Wert temp_feld: ""+temp_feldwert);


                    int posplus2=position[1]+2;
                    if(posplus2>=7) posplus2=7;
                    int temp_feldwert2 = feld[position[0]][posplus2];

                    //System.out.println(""Wert temp_feld2: ""+temp_feldwert2);

                    int posplus3=position[1]+1;
                    if(posplus3>=7) posplus3=7;
                    int temp_feldwert3 = feld[position[0]+1][posplus3];

                    //System.out.println(""Wert temp_feld3: ""+temp_feldwert3);

                    if(temp_feldwert==0 ||((temp_feldwert==1 && temp_feldwert2==1)&&(temp_feldwert3==0))){
                        position[1]=position[1]+1;
                    }else break;


                    bewegungseinheiten--;
                } while(bewegungseinheiten>0);

            }break;


            //--------------------------------------------------------------------------------
            //--------------------------------------------------------------------------------
            //--------------------------------------------------------------------------------
            //--------------------------------------------------------------------------------


            case ""ea"":{

                do{

                    //statt break auch einfach ien return machen, geht auch
                    if (position[0] == 10) break;

                    //System.out.println(""Wert position0 +1:   ""+(position[0]+1)+"" Wert postion1: ""+(position[1]));

                    int temp_feldwert = feld[position[0]+1][(position[1])];

                    //System.out.println(""Wert temp_feld: ""+temp_feldwert);

                    int posplus2=position[0]+2;
                    if(posplus2>=10) posplus2=10;
                    int temp_feldwert2 = feld[posplus2][(position[1])];

                    //System.out.println(""Wert temp_feld2: ""+temp_feldwert2);

                    int posplus3=position[0]+1;
                    if(posplus3>=10) posplus3=10;
                    int temp_feldwert3 = feld[posplus3][position[1]+1];

                    //System.out.println(""Wert temp_feld3: ""+temp_feldwert3);

                    if(temp_feldwert==0 || (temp_feldwert==1 && temp_feldwert2==1 && temp_feldwert3==0) ){
                        position[0]=position[0]+1;
                    }else break;


                    bewegungseinheiten--;
                } while(bewegungseinheiten>0);



            }break;

            //--------------------------------------------------------------------------------
            //--------------------------------------------------------------------------------
            //--------------------------------------------------------------------------------
            //--------------------------------------------------------------------------------


            case ""we"":{

                do{

                    //statt break auch einfach ien return machen, geht auch
                    if (position[0] == 0) break;

                      //System.out.println(""Wert position0 -1:   ""+(position[0]-1)+"" Wert postion1: ""+(position[1]));

                    int temp_feldwert = feld[position[0]-1][(position[1])];

                    //System.out.println(""Wert temp_feld: ""+temp_feldwert);


                    int posplus2=position[0]-2;
                    if(posplus2<=0) posplus2=0;
                    int temp_feldwert2 = feld[posplus2][(position[1])];

                    //System.out.println(""Wert temp_feld2: ""+temp_feldwert2);

                    int posplus3=position[1]-1;
                    if(posplus3<=0) posplus3=0;
                    int temp_feldwert3 = feld[position[0]-1][posplus3];

                    //System.out.println(""Wert temp_feld3: ""+temp_feldwert3);


                    boolean temp1 =temp_feldwert==0;
                    boolean temp2 =(temp_feldwert==1 && temp_feldwert2==1);
                    boolean temp3 =temp_feldwert2==0;
                    boolean temp4=(temp_feldwert==1&&temp_feldwert3==1);
                    boolean temp6=(feld[position[0]][position[1]] == 1);
                    boolean temp5=(temp1 && temp3 && temp6);

                    if((temp1 || temp2) || temp4 || temp3){
                        if(temp3 && temp4 ) {
                            position[0]=position[0]-1;
                            break;
                        }else if (temp5) break;

                        position[0]=position[0]-1;
                    }else break;

                    bewegungseinheiten--;
                } while(bewegungseinheiten>0);

            }break;


            //--------------------------------------------------------------------------------
            //--------------------------------------------------------------------------------
            //--------------------------------------------------------------------------------
            //--------------------------------------------------------------------------------



            case ""so"":{

                do{

                    if (position[1] == 0) break;

                             System.out.println(""Wert position0: ""+position[0]+"" Wert postion1 -1:  ""+(position[1]-1));

                    int temp_feldwert = feld[position[0]][(position[1]-1)];

                    //System.out.println(""Wert temp_feld: ""+temp_feldwert);

                    int posplus2=position[1]-2;
                    if(posplus2<=0) posplus2=0;
                    int temp_feldwert2 = feld[position[0]][posplus2];

                    //System.out.println(""Wert temp_feld2: ""+temp_feldwert2);

                    int posplus3=position[0]-1;
                    if(posplus3<=0) posplus3=0;
                    int temp_feldwert3 = feld[posplus3][position[1]-1];

                    //System.out.println(""Wert temp_feld3: ""+temp_feldwert3);

                    int posplus4=position[1];
                    if(posplus4<=0) posplus4=0;
                    int temp_feldwert4 = feld[position[0]][posplus4];


                    //System.out.println(""Wert temp_feld4: ""+temp_feldwert4);


                    boolean temp1 =temp_feldwert==0;
                    boolean temp2 =(temp_feldwert==1 && temp_feldwert2==1);
                    boolean temp3 =temp_feldwert2==0;
                    boolean temp4=(temp_feldwert==1&&temp_feldwert3==1);
                    boolean temp5=(temp1 && temp3 && temp_feldwert3 == 0 && temp_feldwert4==1);

                    if((temp1 || temp2) || temp4 || temp3){
                        if(temp3 && temp4) {
                            position[1]=position[1]-1;
                            break;
                        }else if(temp5)
                            break;



                        position[1]=position[1]-1;
                    }else break;

                    /*if(temp_feldwert==0){
                        position[1]=position[1]-1;
                    }else break;

                     */
                    bewegungseinheiten--;
                } while(bewegungseinheiten>0);

            }break;


            default:{
                System.out.println(""Keine richtige Richtung zum richten, \ndamit ist das Richten der Richtung nicht möglich"");
            }break;

        }
        return (""(""+position[0]+"",""+position[1]+"")"");
    }



    public void felden(){

        for (int x = 0; x < achseY; x++) {
            for (int y = 0; y < achseX; y++) {
                feld[x][y]=0;

                //Wand Zeilen nur Norden Süden abfragen als Horizontal
                //  wand1 = ""(2,6)-(6,6)"";
                // wand2 = ""(2,1)-(9,1)"";

                //Wand Spalten Nur Osten Westen abfragen also Vertikal
                // wand3 = ""(2,1)-(2,5)"";
                //  wand4 = ""(10,1)-(10,7)"";

                //Wand1
                if((y==6)&&((x>=2)&&(x<=6))) feld[x][y]=1;
                //Wande2
                if((y==1)&&((x>=2)&&(x<=9))) feld[x][y]=1;


                //Wand3
                if((x==2)&&((y>=1)&&(y<=5))) feld[x][y]=1;
                //Wand4
                if((x==10)&&((y>=1)&&(y<=7))) feld[x][y]=1;
            }
        }
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",10561,307,52.316326530612244,152,0.16612377850162866,0.08469055374592833,0.006514657980456026,0.003257328990228013,1.0944625407166124,0.0,0.2899022801302932,0.0781758957654723,True,False,False,False,False,False,2,0.009771986970684038,0.019543973941368076,0.11400651465798045,0.003257328990228013,0.5863192182410424,0.05211726384364821,0.0,7.666666666666667,18,45.328125,93
student30,student,,,"package thkoeln.st.st2praktikum.exercise;

import javax.persistence.criteria.CriteriaBuilder;

public class Exercise0 implements GoAble {


    static int [][] spaceship = new int[12][9];
    int startx = 7;
    int starty = 7;

   public static void startpunktmarkieren(){
       spaceship[7][7] = 2;



   }


    public static void waendebauen(){
        //wand 1
        for(int x = 1; x < 8; x++){
                    spaceship[10][x] = 1;
        }

        //wand2
         for(int x = 2; x <=8; x++){
                    spaceship[x][1] = 3;
        }

        //wand3
         for(int x = 1; x <=6; x++){
                    spaceship[2][x] = 1;
        }
        //wand4
         for(int x = 2; x <=7; x++){
                    spaceship[x][6] = 3;
        }
         //rand
        for(int x = 0; x < 12; x++){
            spaceship[x][0] = 5;
        }
        for(int x = 0; x < 12; x++){
            spaceship[x][8] = 4;
        }
        for(int x = 0; x < 9; x++){
            spaceship[11][x] = 4;
        }
        for(int x = 0; x < 9; x++){
            spaceship[0][x] = 4;
        }


    }




    @Override
    public String go(String goCommandString) {

       waendebauen();
       char zs = goCommandString.charAt(4);
       int zahl = Integer.parseInt(String.valueOf(zs));

       String richtung=""""+goCommandString.toCharArray()[1]+goCommandString.toCharArray()[2]+"""";


       if(richtung.equals(""no"")){
           for (int i = 1; i <= zahl; i++) {
               if (starty < 7  && spaceship[startx][starty+1] != 3) {
                   starty ++;
               }
           }
       }
        if (richtung.equals(""so"")) {
            for (int i = 1; i <= zahl; i++) {
                if(starty >= 1  && startx < spaceship.length - 1 && spaceship[startx+1][starty] != 3 || starty >= 1  && spaceship[startx][starty] != 3 ) {
                        starty--;
                    }
                }
        }
            if (richtung.equals(""ea"")) {
                for(int i = 1; i <= zahl; i++ ) {
                if ( startx <= spaceship.length && startx >= 0 && starty <= spaceship[0].length && spaceship[startx][starty] != 1
                        && spaceship[startx+1][starty] != 4 && spaceship[startx+1][starty] != 1) {
                    startx ++;
                }
            }
        }
        if(richtung.equals(""we"")) {
            for (int i = 1; i <= zahl; i++) {
                if (spaceship[startx][starty] != 4 && spaceship[startx][starty] != 1 && startx < spaceship.length) {
                    startx --;
                }
            }
        }
       String endposition = ""(""+ String.valueOf(startx)+"","" + String.valueOf(starty)+ "")"";

        System.out.println(richtung);
        System.out.println(endposition);


        return endposition;
    }

    public static void main (String[] args) {

        System.out.println(spaceship.length);
        waendebauen();
        startpunktmarkieren();
        for ( int zeile = 0; zeile < spaceship.length; zeile++ )
        {
            System.out.print(""Zeile "" + zeile + "": "");
            for ( int spalte=0; spalte < spaceship[zeile].length; spalte++ )
                System.out.print( spaceship[zeile][spalte] + "" "");
            System.out.println();
        }


    }



}




package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String go(String goCommandString);

}
",3405,135,33.71134020618557,154,0.037037037037037035,0.05925925925925926,0.1037037037037037,0.0,0.5777777777777777,0.0,0.1925925925925926,0.044444444444444446,False,False,False,False,False,False,2,0.037037037037037035,0.022222222222222223,0.02962962962962963,0.007407407407407408,0.7777777777777778,0.14814814814814814,0.007407407407407408,5.416666666666667,11,5.0,6
student32,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements GoAble {
    private int xPos = 3;
    private int yPos = 0;
    final private Integer[][] hBorders = {{0,0,11},{3,4,7},{4,1,8},{7,0,11}};
    final private Integer[][] vBorders = {{0,0,7},{3,0,3},{7,0,2},{11,0,7}};




    @Override
    public String go(String goCommandString) {
        String[] commands = goCommandString.substring(1, goCommandString.length()-1).split("","");
        String direction = commands[0];
        int steps = Integer.parseInt(commands[1]);

        switch (direction){
            case ""no"":
                for (int i = 0; i < steps; i++) {
                    if(!moveNorth()) break;
                    System.out.println(""(""+xPos+"",""+yPos+"")⬆"");
                }
                break;
            case ""ea"":
                for (int i = 0; i < steps; i++) {
                    if(!moveEast()) break;
                    System.out.println(""(""+xPos+"",""+yPos+"")➡"");
                }
                break;
            case ""so"":
                for (int i = 0; i < steps; i++) {
                    if(!moveSouth()) break;
                    System.out.println(""(""+xPos+"",""+yPos+"")⬇"");
                }
                break;
            case ""we"":
                for (int i = 0; i < steps; i++) {
                    if(!moveWest()) break;
                    System.out.println(""(""+xPos+"",""+yPos+"")⬅"");
                }
                break;
            default: return null;
        }

        return ""(""+xPos+"",""+yPos+"")"";
    }

    private boolean moveNorth(){
        for (Integer[] hBorder : hBorders) {
            if (yPos + 1 == hBorder[0]) {
                if (hBorder[1] <= xPos && hBorder[2] >= xPos) {
                    return false;
                }
            }
        }
        yPos++;
        return true;
    }

    private boolean moveSouth(){
        for (Integer[] hBorder : hBorders) {
            if (yPos == hBorder[0]) {
                if (hBorder[1] <= xPos && hBorder[2] >= xPos + 1) {
                    return false;
                }
            }
        }
        yPos--;
        return true;
    }

    private boolean moveEast(){
        for (Integer[] vBorder : vBorders) {
            if (xPos + 1 == vBorder[0]) {
                if (vBorder[1] <= yPos && vBorder[2] >= yPos + 1) {
                    return false;
                }
            }
        }
        xPos++;
        return true;
    }

    private boolean moveWest(){
        for (Integer[] vBorder : vBorders) {
            if (xPos == vBorder[0]) {
                if (vBorder[1] <= yPos && vBorder[2] >= yPos + 1) {
                    return false;
                }
            }
        }
        xPos--;
        return true;
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String go(String goCommandString);
}
",2881,102,31.224719101123597,96,0.0,0.11764705882352941,0.0784313725490196,0.00980392156862745,0.5588235294117647,0.0,0.10784313725490197,0.0392156862745098,False,False,True,False,False,False,2,0.058823529411764705,0.0392156862745098,0.029411764705882353,0.00980392156862745,0.5588235294117647,0.11764705882352941,0.0,6.1,9,0.0,0
student33,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Moveable {
    int x = 4;
    int y = 0;
    String initialPosition = ""(4,0)"";



    @Override
    public String moveTo(String moveCommandString) {
        String movement = moveCommandString.substring(1,moveCommandString.length()-1);
        String[] moving = movement.split("","");
        String directionMove = moving[0];
        int stepToMove= Integer.parseInt(moving[1]);

        switch (directionMove){
            case ""no"":
                if(x==0 || x==4 || x>= 7) {
                    if((y+stepToMove)>7){
                        y = 7;
                    }

                    else y+=stepToMove;
                }

                if(x >=1 && x <= 3 || x>= 5 && x<=6 || y>=0 && y<=5){
                    if((y+stepToMove)>5){
                        y=5;
                    }

                    else y+=stepToMove;
                }

                if((y==6|| y==7) && x>=1 && x<=3 && (x==5|| x==6)){
                    if((y+stepToMove) >7){
                        y = 7;
                    }

                    else y+=stepToMove;
                }
                System.out.println(""x="" +x+ ""y="" +y);
                break;

            case ""so"":
                if(x==0 || x==4 || x >= 7 && x<=10) {
                    if((y-stepToMove)<0){
                        y = 0;
                    }

                    else y-=stepToMove;
                }

                if(x >=1 && x <= 3 || x>= 5 && x<=6 || y>=0 && y<=5){
                    if((y-stepToMove)<0){
                        y= 0;
                    }

                    else y-=stepToMove;
                }

                if((y==6|| y==7) && x>=1 && x<=3 || (x==5|| x==6)){
                    if((y-stepToMove) <6){
                        y = 6;
                    }

                    else y-=stepToMove;
                }
                System.out.println(""x="" +x+ ""y="" +y);
                break;
            case ""ea"":
                if(y>=0 && y<=5 && x == 0) {
                    x = 0;
                }

                if((y==6 || y==7) && x>=0 && x<= 10){
                    if((x+stepToMove) > 10){
                        x= 10;
                    }

                    else x+= stepToMove;
                }

                if(x>=7 && x<=10 && y>= 1 && y<= 5){
                    if((x+stepToMove) > 10){
                        x = 10;
                    }

                    else x+= stepToMove;
                }

                if(y== 0 && x >= 1 && x<=10){
                    if((x+stepToMove) > 10){
                        x = 10;
                    }

                    else x+= stepToMove;
                }

                if(y>=1 && y <= 5 && x >= 1 && x <= 6){
                    if((x+stepToMove) > 6){
                        x = 6;
                    }

                    else x+= stepToMove;
                }
                System.out.println(""x="" +x+ ""y="" +y);
                break;
            case ""we"":
                if(y>=0 && y<=5 && x== 0) {
                    x = 0;
                }

                if((y==6 || y==7) && x>=0 && x<= 10){
                    if((x-stepToMove) < 0){
                        x= 0;
                    }

                    else x-= stepToMove;
                }

                if(x>=7 && x<=10 && y>= 1 && y<= 5){
                    if((x-stepToMove) < 7){
                        x = 7;
                    }

                    else x-= stepToMove;
                }

                if(y== 0 && x >= 1 && x<=10){
                if((x-stepToMove) < 1){
                    x = 1;
                }

                else x-= stepToMove;
            }

            if(y>=1 && y <= 5 && x >= 1 && x <= 6){
                if((x-stepToMove) < 1){
                    x = 1;
                }

                else x-= stepToMove;
            }
            System.out.println(""x="" +x+ ""y="" +y);
            break;

        }
        return ""("" + this.x +"",""+ this.y +"")"";
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String moveTo(String moveCommandString);
}
",4188,157,33.040983606557376,86,0.0,0.1910828025477707,0.0,0.006369426751592357,0.7707006369426752,0.0,0.21656050955414013,0.025477707006369428,False,False,False,False,False,False,2,0.012738853503184714,0.01910828025477707,0.025477707006369428,0.006369426751592357,0.9681528662420382,0.050955414012738856,0.0,6.2,13,0.0,0
student34,student,,,"package thkoeln.st.st2praktikum.exercise;

import lombok.AllArgsConstructor;
import org.springframework.stereotype.Component;
import thkoeln.st.st2praktikum.droid.MaintenanceDroid;
import thkoeln.st.st2praktikum.map.LinearSystem;
import thkoeln.st.st2praktikum.map.Map;
import thkoeln.st.st2praktikum.parser.MovementSerializer;
import thkoeln.st.st2praktikum.parser.Parser;

@Component
@AllArgsConstructor
public class Exercise0 implements Moveable {

    private final Map map;
    private final MaintenanceDroid droid;
    private final MovementSerializer serializer;

    public Exercise0() {
        this.map = Map.defaultMap();
        this.droid = new MaintenanceDroid(map, MaintenanceDroid.defaultPosition(), new LinearSystem());
        serializer = new MovementSerializer();
    }

    @Override
    public String move(String moveCommandString) {
        var movement = Parser.getInstance().parse(moveCommandString);
        this.droid.move(movement);
        return serializer.serialize(this.droid.getPosition());
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String move(String moveCommandString);
}

package thkoeln.st.st2praktikum.droid;

import lombok.AllArgsConstructor;
import org.springframework.data.util.Pair;
import thkoeln.st.st2praktikum.map.BoundedStraight;
import thkoeln.st.st2praktikum.map.LinearSystem;
import thkoeln.st.st2praktikum.map.Map;
import thkoeln.st.st2praktikum.parser.Direction;

import java.util.function.BiFunction;
import java.util.stream.Stream;

@AllArgsConstructor
public class MaintenanceDroid {
    private final Map map;
    private double[] position;
    private LinearSystem linearSystem;

    public static double[] defaultPosition() {
        return new double[]{3.5, 0.5};
    }

    public void move(Pair<Direction, Integer> movement) {
        BiFunction<double[], Pair<Direction, Integer>, double[]> calculateTargetPosition =
                ((position, direction) -> {
                    switch (movement.getFirst()) {
                        case NORTH:
                            return new double[]{this.position[0], this.position[1] + movement.getSecond()};
                        case EAST:
                            return new double[]{this.position[0] + movement.getSecond(), this.position[1]};
                        case SOUTH:
                            return new double[]{this.position[0], this.position[1] - movement.getSecond()};
                        case WEST:
                            return new double[]{this.position[0] - movement.getSecond(), this.position[1]};
                        default:
                            throw new UnsupportedOperationException();
                    }
                });

        BiFunction<double[], double[], Integer> calculateDistance =
                (startPosition, targetPosition) ->
                        (int) Math.round(Math.sqrt(Stream.of(startPosition, targetPosition)
                            .map((it) -> it[0] + it[1])
                            .map(it -> Math.pow(it, 2))
                            .mapToDouble(Double::doubleValue)
                            .sum()));
                ;

        var targetPosition = calculateTargetPosition.apply(this.position, movement);
        var movementStraight = new BoundedStraight(this.position, targetPosition, this.linearSystem);
        movementStraight = this.map.maxMove(movementStraight);

        var startPosition = this.position;
        targetPosition = movementStraight.at(movementStraight.getEndLambda()).get();
        targetPosition = new double[] {((int) targetPosition[0]) + 0.5, ((int) targetPosition[1]) + 0.5};
        this.position = targetPosition;
    }

    public double[] getPosition() {
        return position;
    }
}

package thkoeln.st.st2praktikum.map;

import java.util.Optional;

public class BoundedStraight extends Straight {

    private final double beginLambda;
    private final double endLambda;

    public BoundedStraight(
            int[] directionVector,
            int[] offsetVector,
            LinearSystem linearSystem,
            double beginLambda,
            double endLambda) {
        super(directionVector, offsetVector, linearSystem);
        this.beginLambda = beginLambda;
        this.endLambda = endLambda;
    }

    public BoundedStraight(
            double[] directionVector,
            double[] offsetVector,
            LinearSystem linearSystem,
            double beginLambda,
            double endLambda) {
        super(directionVector, offsetVector, linearSystem);
        this.beginLambda = beginLambda;
        this.endLambda = endLambda;
    }

    public BoundedStraight(double[] startPoint, double[] endPoint, LinearSystem linearSystem) {
        super(
                new double[]{
                        endPoint[0] - startPoint[0],
                        endPoint[1] - startPoint[1]
                },
                startPoint,
                linearSystem
        );
        this.beginLambda = 0;
        this.endLambda = 1;
    }

    @Override
    public Optional<double[]> at(double lambda) {
        if (this.beginLambda <= lambda && lambda <= this.endLambda) {
            return super.at(lambda);
        }
        return Optional.empty();
    }

    public double getBeginLambda() {
        return beginLambda;
    }

    public double getEndLambda() {
        return endLambda;
    }
}

package thkoeln.st.st2praktikum.map;

import org.springframework.data.util.Pair;
import org.springframework.stereotype.Component;

import java.util.Arrays;
import java.util.function.BiFunction;
import java.util.function.Predicate;
import java.util.function.ToIntBiFunction;

@Component
public class LinearSystem {

    public static double EPSILON = 0.000001;

    /**
     * A naive implementation of Gauss' Algorithm.
     * Swap, when more speed is needed.
     *
     * @return solution to the LS
     */
    public Pair<double[], Integer> solve(double[][] matrix) {
        matrix = deepCopyMatrix(matrix);
        this.checkMatrix(matrix);
        var dimensions = dimensions(matrix);
        var numberOfVariables = dimensions.n - 1;

        BiFunction<double[], Integer, double[]> normalizeRow = (double[] row, Integer column) -> {
            double[] rowCopy = Arrays.copyOf(row, row.length);
            var factor = 1 / row[column];
            for (int i = column; i < row.length; i++) {
                rowCopy[i] *= factor;
            }
            return rowCopy;
        };

        BiFunction<double[], Double, double[]> multiplyRow = (double[] row, Double factor) -> {
            double[] rowCopy = Arrays.copyOf(row, row.length);
            for (int i = 0; i < rowCopy.length; i++) {
                rowCopy[i] *= factor;
            }
            return rowCopy;
        };

        BiFunction<double[], double[], double[]> addRow = (double[] addend1, double[] addend2) -> {
            double[] addendCopy = Arrays.copyOf(addend1, addend1.length);
            for (int i = 0; i < addendCopy.length; i++) {
                addendCopy[i] += addend2[i];
            }
            return addendCopy;
        };

        ToIntBiFunction<double[][], Dimension> rangOfGaussMatrix = (double[][] gaussMatrix, Dimension gaussDimension) -> {
            var independentRows = 0;
            for (double[] row : gaussMatrix) {
                for (double value : row) {
                    if (Math.abs(value) > EPSILON) {
                        independentRows++;
                        break;
                    }
                }
            }
            return independentRows;
        };

        Predicate<double[][]> isGaussMatrixInconsistent = (double[][] gaussMatrix) -> {
            for (var row : gaussMatrix) {
                var allZero = true;
                for (int i = 0; i < row.length - 1; i++) {
                    if (Math.abs(row[i]) > EPSILON) {
                        allZero = false;
                        break;
                    }
                }
                if (allZero) {
                    if (Math.abs(row[row.length - 1]) > EPSILON) {
                        return true;
                    }
                }
            }
            return false;
        };

        for (int i = 0; i < numberOfVariables - 1; i++) {
            if(matrix[i][i] == 0) {
                for(int j = i +1; j < numberOfVariables; j++) {
                    if(matrix[j][i] != 0) {
                        matrix[i] = addRow.apply(matrix[i], matrix[j]);
                        break;
                    }
                }
            }
            matrix[i] = normalizeRow.apply(matrix[i], i);
            for (int j = i + 1; j < numberOfVariables; j++) {
                var factor = matrix[j][i] * -1.0;
                matrix[j] = addRow.apply(matrix[j], multiplyRow.apply(matrix[i], factor));
            }
        }

        for (int i = numberOfVariables - 1; i >= 0; i--) {
            matrix[i] = normalizeRow.apply(matrix[i], i);
            for (int j = i - 1; j >= 0; j--) {
                var factor = matrix[j][i] * -1.0;
                matrix[j] = addRow.apply(matrix[j], multiplyRow.apply(matrix[i], factor));
            }
        }

        double[] result = new double[dimensions.n - 1];

        for (int i = 0; i < dimensions.n - 1; i++) {
            result[i] = matrix[i][dimensions.n - 1];
        }

        if (rangOfGaussMatrix.applyAsInt(matrix, dimensions) < dimensions.n - 1) {
            return Pair.of(result, Integer.MAX_VALUE);
        }

        if (isGaussMatrixInconsistent.test(matrix)) {
            return Pair.of(result, 0);
        }

        return Pair.of(result, 1);
    }

    private double[][] deepCopyMatrix(double[][] matrix) {
        double[][] copyMatrix = new double[dimensions(matrix).m][dimensions(matrix).n];
        for (int i = 0; i < dimensions(matrix).m; i++) {
            if (dimensions(matrix).n >= 0) System.arraycopy(matrix[i], 0, copyMatrix[i], 0, dimensions(matrix).n);
        }
        return copyMatrix;
    }

    private boolean checkMatrix(double[][] matrix) {
        if (matrix.length == 0 || matrix[0].length == 0) {
            throw new IllegalArgumentException(""No input matrix"");
        }
        if (this.isUnderSpecified(matrix)) {
            throw new IllegalArgumentException(""LS is underspecified"");
        }
        if (!this.allTheSameLength(matrix)) {
            throw new IllegalArgumentException(""Malformed matrix"");
        }
        return true;
    }

    private boolean isUnderSpecified(double[][] matrix) {
        var dimensions = this.dimensions(matrix);
        return dimensions.m < dimensions.n - 1;
    }

    private boolean allTheSameLength(double[][] matrix) {
        var dimensions = this.dimensions(matrix);
        for (double[] row : matrix) {
            if (row.length != dimensions.n) {
                return false;
            }
        }
        return true;
    }

    private Dimension dimensions(double[][] matrix) {
        return new Dimension(matrix.length, matrix[0].length);
    }

    private class Dimension {
        private final int m;
        private final int n;

        public Dimension(int m, int n) {
            this.m = m;
            this.n = n;
        }
    }
}

package thkoeln.st.st2praktikum.map;

import lombok.AllArgsConstructor;
import org.springframework.stereotype.Component;

import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.Optional;

@Component
@AllArgsConstructor
public class Map {

    private final List<Straight> boundaries;
    private final LinearSystem linearSystem;

    public static Map defaultMap() {
        var ls = new LinearSystem();
        var ex1 = new double[]{1, 0};
        var ex2 = new double[]{0, 1};
//        var boundaries = Arrays.asList(
//                new Straight(ex1, new double[]{0, 0}, ls),
//                new Straight(ex2, new double[]{0, 0}, ls),
//                new Straight(ex1, new double[]{0, 8}, ls),
//                new Straight(ex2, new double[]{12, 0}, ls),
//                // v1
//                new BoundedStraight(ex1, new double[]{0.5, 4.5}, ls, 0, 8),
//                new BoundedStraight(ex1, new double[]{0.5, 3.5}, ls, 0, 8),
//                new BoundedStraight(ex2, new double[]{0.5, 3.5}, ls, 0, 1),
//                new BoundedStraight(ex2, new double[]{8.5, 3.5}, ls, 0, 1),
//                //v2
//                new BoundedStraight(ex1, new double[]{2.5, 3.5}, ls, 0, 1),
//                new BoundedStraight(ex1, new double[]{2.5, -0.5}, ls, 0, 1),
//                new BoundedStraight(ex2, new double[]{2.5, -0.5}, ls, 0, 4),
//                new BoundedStraight(ex2, new double[]{3.5, -0.5}, ls, 0, 4),
//                //v3
//                new BoundedStraight(ex1, new double[]{3.5, 3.5}, ls, 0, 4),
//                new BoundedStraight(ex1, new double[]{3.5, 2.5}, ls, 0, 4),
//                new BoundedStraight(ex2, new double[]{3.5, 2.5}, ls, 0, 1),
//                new BoundedStraight(ex2, new double[]{7.5, 2.5}, ls, 0, 1),
//                //v4
//                new BoundedStraight(ex1, new double[]{6.5, 2.5}, ls, 0, 1),
//                new BoundedStraight(ex1, new double[]{6.5, -0.5}, ls, 0, 1),
//                new BoundedStraight(ex2, new double[]{6.5, -0.5}, ls, 0, 3),
//                new BoundedStraight(ex2, new double[]{7.5, -0.5}, ls, 0, 3)
//        );
        var boundaries = Arrays.asList(
                new Straight(ex1, new double[]{0, 0}, ls),
                new Straight(ex2, new double[]{0, 0}, ls),
                new Straight(ex1, new double[]{0, 8}, ls),
                new Straight(ex2, new double[]{12, 0}, ls),
                // v1
                new BoundedStraight(ex1, new double[]{0.75, 4.25}, ls, 0, 7.5),
                new BoundedStraight(ex1, new double[]{0.75, 3.75}, ls, 0, 7.5),
                new BoundedStraight(ex2, new double[]{0.75, 3.75}, ls, 0, 0.5),
                new BoundedStraight(ex2, new double[]{8.25, 3.75}, ls, 0, 0.5),
                //v2
                new BoundedStraight(ex1, new double[]{2.75, 3.25}, ls, 0, 0.5),
                new BoundedStraight(ex1, new double[]{2.75, -0.75}, ls, 0, 0.5),
                new BoundedStraight(ex2, new double[]{2.75, -0.25}, ls, 0, 3.5),
                new BoundedStraight(ex2, new double[]{3.25, -0.25}, ls, 0, 3.5),
                //v3
                new BoundedStraight(ex1, new double[]{3.75, 3.25}, ls, 0, 3.5),
                new BoundedStraight(ex1, new double[]{3.75, 2.75}, ls, 0, 3.5),
                new BoundedStraight(ex2, new double[]{3.75, 2.75}, ls, 0, 0.5),
                new BoundedStraight(ex2, new double[]{7.25, 2.75}, ls, 0, 0.5),
                //v4
                new BoundedStraight(ex1, new double[]{6.75, 2.25}, ls, 0, 0.5),
                new BoundedStraight(ex1, new double[]{6.75, -0.75}, ls, 0, 0.5),
                new BoundedStraight(ex2, new double[]{6.75, -0.25}, ls, 0, 2.5),
                new BoundedStraight(ex2, new double[]{7.25, -0.25}, ls, 0, 2.5)
        );

        return new Map(boundaries, ls);
    }

    public BoundedStraight maxMove(BoundedStraight move) {
        var startPosition = move.at(move.getBeginLambda()).get();
        var distance = new Comparator<double[]>() {
            @Override
            public int compare(double[] v1, double[] v2) {
                double dist1 = 0.0;
                double dist2 = 0.0;
                for(int i = 0; i < v1.length; i++) {
                    dist1 += Math.pow(v1[i] - startPosition[i], 2);
                    dist2 += Math.pow(v2[i] - startPosition[i], 2);
                }
                return Double.compare(dist1, dist2);
            }
        };
        var maximalPoint = this.boundaries.stream()
                .map(move::cut)
                .filter(Optional::isPresent)
                .map(it -> it.get())
                .min(distance)
                .orElseGet(() -> move.at(move.getEndLambda()).get());

        return new BoundedStraight(move.at(move.getBeginLambda()).get(), maximalPoint, this.linearSystem);
    }
}

package thkoeln.st.st2praktikum.map;

import org.springframework.data.util.Pair;

import java.util.Optional;

public class Straight {

    private final LinearSystem linearSystem;
    // f: x = l * directionVector + offsetVector
    protected final double[] directionVector;
    protected final double[] offsetVector;

    public Straight(int[] directionVector, int[] offsetVector, LinearSystem linearSystem) {
        this.linearSystem = linearSystem;

        if (directionVector.length != offsetVector.length) {
            throw new IllegalArgumentException();
        }
        this.directionVector = new double[directionVector.length];
        this.offsetVector = new double[offsetVector.length];

        for (int i = 0; i < directionVector.length; i++) {
            this.directionVector[i] = directionVector[i];
            this.offsetVector[i] = offsetVector[i];
        }
    }

    public Straight(double[] directionVector, double[] offsetVector, LinearSystem linearSystem) {
        this.linearSystem = linearSystem;

        if (directionVector.length != offsetVector.length) {
            throw new IllegalArgumentException();
        }
        this.directionVector = new double[directionVector.length];
        this.offsetVector = new double[offsetVector.length];

        System.arraycopy(directionVector, 0, this.directionVector, 0, directionVector.length);
        System.arraycopy(offsetVector, 0, this.offsetVector, 0, offsetVector.length);
    }

    /**
     * Returns the point of intersection for the two vectors.
     * If they don't cut each other or are the same an Optional.empty will be returned.
     *
     * @param otherStraight
     * @return intersection of the two vectors
     */
    public Optional<double[]> cut(Straight otherStraight) {
        if (this.directionVector.length != otherStraight.getDirectionVector().length) {
            throw new IllegalArgumentException();
        }
        double[][] lsMatrix = new double[directionVector.length][3];
        for (int i = 0; i < this.directionVector.length; i++) {
            lsMatrix[i][0] = this.directionVector[i];
            lsMatrix[i][1] = otherStraight.getDirectionVector()[i] * -1;
            lsMatrix[i][2] = otherStraight.getOffsetVector()[i] - this.offsetVector[i];
        }
        Pair<double[], Integer> result = this.linearSystem.solve(lsMatrix);

        if (result.getSecond() == 1) {
            double l1 = result.getFirst()[0];
            double l2 = result.getFirst()[1];
            if (this.at(l1).isPresent() && otherStraight.at(l2).isPresent()) {
                return Optional.of(this.at(l1).get());
            }
        }
        return Optional.empty();

    }

    public Optional<double[]> at(double lambda) {
        return Optional.of(new double[]{
                this.offsetVector[0] + lambda * this.directionVector[0],
                this.offsetVector[1] + lambda * this.directionVector[1]
        });
    }

    public double[] getDirectionVector() {
        return directionVector;
    }

    public double[] getOffsetVector() {
        return offsetVector;
    }
}

package thkoeln.st.st2praktikum.parser;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public enum Direction {
    NORTH(""no""),
    EAST(""ea""),
    SOUTH(""so""),
    WEST(""we"");

    private String abbreviation;

    public static Direction of(String direction) {
        switch(direction) {
            case ""no"": return NORTH;
            case ""ea"": return EAST;
            case ""so"": return SOUTH;
            case ""we"": return WEST;
            default: throw new IllegalArgumentException(""Direction unknown: "" + direction);
        }
    }

    public String getAbbreviation() {
        return abbreviation;
    }
}

package thkoeln.st.st2praktikum.parser;

public class MovementSerializer {

    public String serialize(double[] position) {
        return new StringBuilder()
                .append('(')
                .append((int) position[0])
                .append(',')
                .append((int) position[1])
                .append(')')
                .toString();
    }
}

package thkoeln.st.st2praktikum.parser;

import org.springframework.data.util.Pair;
import org.springframework.stereotype.Component;

import java.util.StringTokenizer;
import java.util.regex.Pattern;

@Component
public class Parser {

    private static Parser parser;

    private Pattern pattern;

    private Parser() {
        this.pattern = Pattern.compile(""^\\[((no)|(ea)|(so)|(we)),\\d*\\]\\z$"");
    }

    public static Parser getInstance() {
        if(Parser.parser == null) {
            Parser.parser = new Parser();
        }
        return Parser.parser;
    }

    public Pair<Direction, Integer> parse(String input) {
        if(!this.pattern.matcher(input).matches()) {
            throw new IllegalArgumentException();
        }
        var stringTokenizer = new StringTokenizer(input, ""[],"");
        var direction = Direction.of(stringTokenizer.nextToken());
        var distance = Integer.parseInt(stringTokenizer.nextToken());
        return Pair.of(direction, distance);
    }
}
",21264,605,40.587426326129666,122,0.06115702479338843,0.03966942148760331,0.03305785123966942,0.003305785123966942,0.7487603305785124,0.01487603305785124,0.15867768595041323,0.0,False,True,False,False,False,False,10,0.04297520661157025,0.03140495867768595,0.06776859504132231,0.01487603305785124,0.6380165289256199,0.18016528925619835,0.05785123966942149,7.372093023255814,17,36.5,82
student36,student,,,"package thkoeln.st.st2praktikum.exercise;

public enum Direction {
    NORTH,
    EAST,
    SOUTH,
    WEST;
}

package thkoeln.st.st2praktikum.exercise;

import java.util.Arrays;

public class Exercise0 implements Walkable {
    /*
    Maschine konstruieren
    Startposition angeben
    Feld angeben
    Wände bestimmen
     */

    private MiningMachine miningMachine = new MiningMachine(4,0, new MiningField(11,8, Arrays.asList(
            new Walls(1,6,4,6),
            new Walls(5,6,7,6),
            new Walls(1,0,1,6),
            new Walls(7,2,7,6)
    )));
    @Override
    public String walkTo(String walkCommandString) {
        return miningMachine.moveMiningMachine(walkCommandString);
    }


}

package thkoeln.st.st2praktikum.exercise;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

import java.util.List;

@Getter
@Setter
@AllArgsConstructor

public class MiningField {
    private Integer x_size;
    private Integer y_size;
    private List<Walls> walls;
}

package thkoeln.st.st2praktikum.exercise;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.util.Pair;


@Getter
@Setter
@AllArgsConstructor

public class MiningMachine {
    private Integer miningPosX;
    private Integer miningPosY;
    private MiningField myMiningField;

    // #################################################################################################################
    // ################################################### Bewegung  ###################################################
    // #################################################################################################################
    public String moveMiningMachine(String command) {
        Pair<Direction,Integer> move = analyse(command);
        Integer newPosition;

        // ################################################### Norden  #################################################
        if (move.getFirst() == Direction.NORTH) {
            // 1) Eine vorläufige Postion wird gesetzt (Entweder Ende des Feldes oder die miningPosY zuzüglich der Bewegung
            newPosition = Math.min(miningPosY + move.getSecond(), myMiningField.getY_size() - 1);

            /*
            2) Alle Wände checken:
            Wenn eine horizontale Wand und Wand im Norden und auf gleicher X-Koordinate wie die Maschine
            und die vorläufige Postion ist weiter weg, dann wird eine neue Position gesetzt
            (Y-Koordinate, da Norden)
            */

            for (Walls walls : myMiningField.getWalls()) {
                if (walls.getFirstY() == walls.getLastY() && walls.getFirstY() > miningPosY && walls.getFirstX() <= miningPosX && walls.getLastX() > miningPosX && walls.getFirstY() <= newPosition)
                    newPosition = walls.getFirstY()-1;
            }
            miningPosY = newPosition;
        }

        // ################################################### Süden  ##################################################
        //gleiche Vorgehensweise wie im Norden
        if (move.getFirst() == Direction.SOUTH) {
            newPosition = Math.max(miningPosY - move.getSecond(), 0);

            for (Walls walls : myMiningField.getWalls()) {
                if (walls.getFirstY() == walls.getLastY() && walls.getFirstY() <= miningPosY && walls.getFirstX() <= miningPosX && walls.getLastX() > miningPosX && walls.getFirstY() > newPosition)
                    newPosition = walls.getFirstY();
            }
            miningPosY = newPosition;
        }

        // ################################################### Westen  ##################################################
        if (move.getFirst() == Direction.WEST) {

            newPosition = Math.max(miningPosX - move.getSecond(), 0);

            /*
            2) Alle Wände checken:
            Wenn eine vertikale Wand und Wand im Westen und auf gleicher Y-Koordinate wie die Maschine
            und die vorläufige Postion ist weiter weg, dann wird eine neue Position gesetzt
            (X-Koordinate, da Westen)
            */

            for (Walls walls : myMiningField.getWalls()) {
                if (walls.getFirstX() == walls.getLastX() && walls.getFirstX() <= miningPosX && walls.getFirstY() <= miningPosY && walls.getLastY() > miningPosY && walls.getFirstX() > newPosition)
                    newPosition = walls.getFirstX();
            }
            miningPosX = newPosition;
        }

        // ################################################### Osten  ##################################################
        //gleiche Vorgehensweise wie im Westen
        if (move.getFirst() == Direction.EAST) {
            newPosition = Math.min(miningPosX + move.getSecond(), myMiningField.getX_size() - 1);


            for (Walls walls : myMiningField.getWalls()) {
                if (walls.getFirstX() == walls.getLastX() && walls.getFirstX() > miningPosX && walls.getFirstY() <= miningPosY && walls.getLastY() > miningPosY && walls.getFirstX() <= newPosition)
                    newPosition = walls.getFirstX()-1;
            }
            miningPosX = newPosition;
        }

        System.out.println(""Position: (""+miningPosX+"",""+miningPosY+"")"");
        return Position(miningPosX,miningPosY);
    }



    // ################################################## Analyse ######################################################
    static public Pair<Direction,Integer> analyse(String command){
        String direction = command.substring(command.indexOf(""["")+1,command.indexOf("",""));
        Integer steps = Integer.parseInt(command.substring(command.indexOf("","")+1,command.indexOf(""]"")));

        if (direction.equals(""no"")) return Pair.of(Direction.NORTH,steps);
        if (direction.equals(""so"")) return Pair.of(Direction.SOUTH,steps);
        if (direction.equals(""ea"")) return Pair.of(Direction.EAST,steps);
        if (direction.equals(""we"")) return Pair.of(Direction.WEST,steps);

        throw new IllegalArgumentException(""Illegal command: ""+command);
    }

    static public String Position(Integer posX, Integer posY){
        return ""("" + posX + "",""+ posY + "")"";
    }


}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);
}

package thkoeln.st.st2praktikum.exercise;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
public class Walls {
    private Integer firstX;
    private Integer firstY;
    private Integer lastX;
    private Integer lastY;
}",6611,186,44.93706293706294,196,0.07526881720430108,0.06451612903225806,0.021505376344086023,0.0,0.20967741935483872,0.005376344086021506,0.20430107526881722,0.005376344086021506,False,True,True,False,False,False,6,0.026881720430107527,0.05913978494623656,0.021505376344086023,0.021505376344086023,0.3064516129032258,0.3548387096774194,0.06451612903225806,7.166666666666667,17,68.34782608695652,113
student37,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Droid {
    private int x = 1;
    private int y = 7;

    Map map = new Map();


}

package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Walkable {
    int x = 1;
    int y = 7;

    int[][] mauernx = {{4,3}};
    int[][] mauerny = {{3, 3}, {3, 4}, {3, 5}, {3, 6}, {3, 7}, {3, 8}, {3, 9},{5,0},{5,1},{6,3},{6,2},{6,1},{6,0}};

    Mauer[] wall;
    public Exercise0 () {
        wall= new Mauer[14];
        wall[0]=new Mauer(3,3,true);
        wall[1]=new Mauer(3,4,true);
        wall[2]=new Mauer(3,5,true);
        wall[3]=new Mauer(3,6,true);
        wall[4]=new Mauer(3,7,true);
        wall[5]=new Mauer(3,8,true);
        wall[6]=new Mauer(3,3,false);
        wall[7]=new Mauer(4,3,false);
        wall[8]=new Mauer(5,0,true);
        wall[9]=new Mauer(5,1,true);
        wall[10]=new Mauer(6,0,true);
        wall[11]=new Mauer(6,1,true);
        wall[12]=new Mauer(6,2,true);
        wall[13]=new Mauer(6,3,true);
    }
// 3,3 3,9
    @Override
    public String walk(String walkCommandString) {
        walkCommandString= walkCommandString.substring(1,walkCommandString.length()-1);
        String[] com = walkCommandString.split("","");
        boolean pablo = false;
        for (int i=0; Integer.parseInt(com[1])>i; i++) {
            switch (com[0]){
                case ""no"":
                    for (Mauer ww: wall) {
                        if (x==ww.x && y+1== ww.y && !ww.isVertical) {
                            pablo=true;
                        }
                    }
                    if (!pablo) {
                        y++;
                    }

                    break;
                case ""ea"":
                    for (Mauer ww: wall) {
                        if (y==ww.y && x+1== ww.x && ww.isVertical) {
                            pablo=true;
                        }
                    }
                    if (!pablo) {
                        x++;
                    }

                    break;
                    case ""su"":
                case ""so"":
                    for (Mauer ww: wall) {
                        if (y==0 || x==ww.x && y== ww.y && !ww.isVertical) {
                        pablo=true;
                    }
                }
                    if (!pablo) {
                        y--;
                    }

                    break;


                case ""we"":
                    for (Mauer ww: wall) {
                        if (x==ww.x && y== ww.y && ww.isVertical) {
                            pablo=true;
                        }
                    }
                    if (!pablo) {
                        x--;
                    }

                    break;
            }
        }
        System.out.println(com[0]+""(""+x+"",""+y+"")"");

        return ""(""+x+"",""+y+"")"";

    }
}

package thkoeln.st.st2praktikum.exercise;

import lombok.Getter;
import lombok.Setter;

@Setter
@Getter
public class Map {
    private int x = 12;
    private int y = 9;

    int[][] map = new int[x][y];



}


package thkoeln.st.st2praktikum.exercise;

public class Mauer  {
    int x;
    int y;
    boolean isVertical;

    public Mauer(int x, int y, boolean isVertical) {
        this.x=x;
        this.y=y;
        this.isVertical=isVertical;
    }

}

package thkoeln.st.st2praktikum.exercise;



public interface Walkable {
    String walk(String walkCommandString);

}
",3432,143,29.9,115,0.006993006993006993,0.055944055944055944,0.03496503496503497,0.006993006993006993,0.7202797202797203,0.0,0.1958041958041958,0.006993006993006993,True,False,False,False,False,False,5,0.013986013986013986,0.0979020979020979,0.013986013986013986,0.027972027972027972,0.48951048951048953,0.03496503496503497,0.013986013986013986,4.3076923076923075,17,7.0,7
student38,student,,,"package thkoeln.st.st2praktikum.exercise;

class Cell{
    int x;
    int y;
    boolean wNO;
    boolean wEA;
    boolean wSO;
    boolean wWE;

    public Cell(int x, int y, boolean wNO, boolean wEA, boolean wSO, boolean wWE){
        this.x = x;
        this.y = y;
        this.wNO = wNO;
        this.wEA = wEA;
        this.wSO = wSO;
        this.wWE = wWE;
    }
}

public class Exercise0 implements Moveable {

    Cell[][] map;
    int currentX = 5;
    int currentY = 3;

    @Override
    public String move(String moveCommandString) {
        if(map == null)
            this.initMap();

        String[] command = moveCommandString.substring(moveCommandString.indexOf(""["")+1,moveCommandString.indexOf(""]"")).split(("",""));

        currentY = Math.abs(currentY-(map.length-1));

        int tempX = currentX;
        int tempY = currentY;
        switch (command[0]){
            case ""no"":
                for (int i = currentY; i < currentY + Integer.parseInt(command[1]); i++){
                    if(!map[tempY][tempX].wNO && tempY > 0)
                        tempY--;
                    else
                        break;
                }
                break;
            case ""ea"":
                for (int j = currentX; j < currentX + Integer.parseInt(command[1]); j++){
                    if(!map[tempY][tempX].wEA && tempX < map[tempY].length-1)
                        tempX++;
                    else
                        break;
                }
                break;
            case ""so"":
                for (int i = currentY; i > currentY - Integer.parseInt(command[1]); i--){
                    if(!map[tempY][tempX].wSO && tempY < map.length-1)
                        tempY++;
                    else
                        break;
                }
                break;
            case ""we"":
                for (int j = currentX; j > currentX - Integer.parseInt(command[1]); j--){
                    if(!map[tempY][tempX].wWE && tempX > 0)
                        tempX--;
                    else
                        break;
                }
                break;
        }
        currentX = tempX;
        currentY = Math.abs(tempY-(map.length-1));
        return ""("" +  currentX + "","" + currentY + "")"";
    }

    private void initMap(){
        //Creating the map of Cells
        map = new Cell[8][12];
        for (int i = 0; i < map.length; i++){
            for (int j = 0; j < map[i].length; j++){
                map[i][j] = new Cell(j,i,false,false,false,false);
            }
        }
        //Creating obstacles in map
        for (int i = 5; i < 7; i++){
            map[i][3].wEA = true;
            map[i][4].wWE = true;
        }
        for (int j = 3; j < 9; j++){
            map[4][j].wSO = true;
            map[5][j].wNO = true;
        }
        for (int i = 0; i < 6; i++){
            map[i][5].wEA = true;
            map[i][6].wWE = true;
        }
        for (int j = 1; j < 6; j++){
            map[1][j].wSO = true;
            map[2][j].wNO = true;
        }
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String move(String moveCommandString);
}
",3176,109,31.29591836734694,133,0.01834862385321101,0.045871559633027525,0.09174311926605505,0.009174311926605505,0.3486238532110092,0.0,0.10091743119266056,0.0,True,False,False,False,False,False,2,0.027522935779816515,0.08256880733944955,0.027522935779816515,0.01834862385321101,1.1009174311926606,0.10091743119266056,0.0,3.8666666666666667,8,25.0,25
student39,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements GoAble {
    int x_position = 1;
    int y_position = 7;
    int[][] map = new int[12][9];

    public Exercise0(){
        map[3][8] = 1;
        map[3][7] = 1;
        map[3][6] = 1;
        map[3][5] = 1;
        map[3][4] = 1;
        map[3][3] = 3;
        map[4][3] = 2;
        map[5][0] = 1;
        map[5][1] = 1;
        map[6][0] = 1;
        map[6][1] = 1;
        map[6][2] = 1;
        map[6][3] = 1;
    }
    @Override
    public String goTo(String goCommandString) {
        int steps = 0;
        int new_y = y_position;
        int new_x = x_position;
        if(goCommandString.length()==6)
            steps = Character.getNumericValue(goCommandString.charAt(4));
        else if(goCommandString.length()==7)
            steps = Character.getNumericValue(goCommandString.charAt(4)) * 10 + Character.getNumericValue(goCommandString.charAt(5));
        else
            throw new IllegalArgumentException(""Wrong command."");

        if(goCommandString.charAt(1)=='s'){
            new_y = y_position-steps;
            for(int i = 0; i <= steps;i++){
                if(y_position-i < 0){
                    new_y = 0;
                    break;
                }
                else if(map[x_position][y_position-i] == 2 || map[x_position][y_position-i] == 3) {
                    new_y = y_position - i;
                    break;
                }
            }
        }
        else if(goCommandString.charAt(1) == 'n'){
            new_y = y_position+steps;
            for(int i = 0; i <= steps;i++){

                if(y_position+i > 8){
                    new_y = 8;
                    break;
                }
                else if(map[x_position][y_position+i] == 2 || map[x_position][y_position+i] == 3) {
                    new_y = y_position + i - 1;
                    break;
                }
            }
        }
        else if(goCommandString.charAt(1)=='e'){
            new_x = x_position+steps;
            for(int i = 0; i <= steps;i++){
                if(x_position+i > 11){
                    new_x = 11;
                    break;
                }
                else if(map[x_position+i][y_position] == 1 || map[x_position+i][y_position] == 3) {
                    new_x = x_position + i - 1;
                    break;
                }

            }
        }
        else if(goCommandString.charAt(1) == 'w'){
            new_x = x_position-steps;
            for(int i = 0; i <= steps;i++){
                if(x_position-i < 0){
                    new_x = 0;
                    break;
                }
                else if(map[x_position-i][y_position] == 1 || map[x_position-i][y_position] == 3) {
                    new_x = x_position - i;
                    break;
                }
            }
        }
        else
            throw new IllegalArgumentException(""Wrong direction."");

        x_position = new_x;
        y_position = new_y;
        return ""(""+x_position+"",""+y_position+"")"";
    }
}


package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String goTo(String goCommandString);
}
",3174,103,32.670212765957444,133,0.0,0.13592233009708737,0.038834951456310676,0.0,0.8155339805825242,0.019417475728155338,0.07766990291262135,0.0,False,False,False,False,False,False,2,0.019417475728155338,0.02912621359223301,0.02912621359223301,0.009708737864077669,1.0,0.11650485436893204,0.0,5.571428571428571,10,0.0,0
student40,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements GoAble {

    private class Cell{
        Cell(int x, int y, int walltype){
            x_ = x;
            y_ = y;
            wt = walltype;
        }

        int x_;
        int y_;
        int wt;
    }

    private int x = 11;
    private int y = 7;
    private int max_x = 11;
    private int max_y = 7;
    private int min_x = 0;
    private int min_y = 0;

    // 0 = wall North
    // 1 = wall West
    // 2 = wall East
    // 3 = wall South
    private Cell[] walls = {
            new Cell(11, 6, 3),
            new Cell(10, 6, 3),
            new Cell( 9, 6, 3),
            new Cell( 8, 6, 3),
            new Cell( 7, 6, 3),
            new Cell( 6, 6, 3),
            new Cell( 5, 6, 3),

            new Cell(11, 5, 0),
            new Cell(10, 5, 0),
            new Cell( 9, 5, 0),
            new Cell( 8, 5, 0),
            new Cell( 7, 5, 0),
            new Cell( 6, 5, 0),
            new Cell( 5, 5, 0),

            new Cell(4, 5, 2),
            new Cell(5, 5, 1),
            new Cell(5, 5, 3),
            new Cell(5, 4, 0),

            new Cell(5, 4, 2),
            new Cell(5, 3, 2),
            new Cell(5, 2, 2),

            new Cell(6, 4, 1),
            new Cell(6, 3, 1),
            new Cell(6, 2, 1)

    };

    @Override
    public String goTo(String goCommandString) {
        // 0 = move North
        // 1 = move West
        // 2 = move East
        // 3 = move South
        int move = 99;
        int move_amount = 0;
        int temp_max_x = max_x;
        int temp_min_x = min_x;
        int temp_max_y = max_y;
        int temp_min_y = min_y;

        goCommandString = goCommandString.replace(""["", """");
        goCommandString = goCommandString.replace(""]"", """");

        String[] exploded = goCommandString.split("","");

        move_amount = Integer.parseInt(exploded[1]);
        // the direction is either no (north), ea (east), so (south), or we (west).
        switch(exploded[0]){
            case ""no"":{
                move = 0;
                break;
            }
            case ""ea"":{
                move = 2;
                break;
            }
            case ""so"":{
                move = 3;
                break;
            }
            case ""we"":{
                move = 1;
                break;
            }
        }


        for (int i = 0; i < walls.length; i++) {
            Cell wall = walls[i];

            if( wall.wt != move ) // skip all walls that do not matter on the current move
                continue;

            switch(move){
                case 0:{
                    if( x == wall.x_ ){
                        if( y <= wall.y_ ) {
                            if (wall.y_ < temp_max_y)
                                temp_max_y = wall.y_;
                        }
                    }
                    break;
                }
                case 1:{
                    if( y == wall.y_ ) {
                        if (x >= wall.x_) {
                            if (wall.x_ > temp_min_x)
                                temp_min_x = wall.x_;
                        }
                    }
                    break;
                }
                case 2:{
                    if( y == wall.y_ ) {
                        if (x <= wall.x_) {
                            if (wall.x_ < temp_max_x)
                                temp_max_x = wall.x_;
                        }
                    }
                    break;
                }
                case 3:{
                    if( x == wall.x_ ){
                        if( y >= wall.y_ ) {
                            if (wall.y_ > temp_min_y) {
                                temp_min_y = wall.y_;
                            }
                        }
                    }
                    break;
                }
            }
        }

        switch(move){
            case 0:{
                y += move_amount;
                break;
            }
            case 1:{
                x -= move_amount;
                break;
            }
            case 2:{
                x += move_amount;
                break;
            }
            case 3:{
                y -= move_amount;
                break;
            }
        }

        x = clamp(temp_min_x, temp_max_x, x);
        y = clamp(temp_min_y, temp_max_y, y);
        return ""("" + x + "","" + y + "")"";
    }
    private int clamp(int min, int max, int val){
        if( val > max )
            return max;

        if( val < min )
            return min;

        return val;
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String goTo(String goCommandString);
}
",4735,185,28.26086956521739,90,0.05405405405405406,0.08108108108108109,0.005405405405405406,0.016216216216216217,0.6108108108108108,0.0,0.12432432432432433,0.0,False,False,False,False,False,False,2,0.016216216216216217,0.05405405405405406,0.043243243243243246,0.010810810810810811,0.4594594594594595,0.032432432432432434,0.0,5.625,15,23.3,72
student45,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements GoAble {

    final int WIDTH = 12;
    final int HEIGHT = 9;

    private Field[][] area = new Field[HEIGHT][WIDTH];
    private int start_x = 8;
    private int start_y = 5;


    public Exercise0() {
        init();
        printField();
    }

    @Override
    public String goTo(String goCommandString) {
        String str = goCommandString
                .replace(""["", """")
                .replace(""]"", """");
        String[] command = str.split("","");

        return goTo(command[0], Integer.parseInt(command[1]));
    }

    public String goTo(String direction, int steps) {
        int amount = 0;

        switch (direction){
            case ""no"":
                while (amount < steps && hasNoBorder(start_x, start_y - amount, direction))
                    amount++;
                start_y -= amount;
                break;

            case ""ea"":
                while (amount < steps && hasNoBorder(start_x + amount, start_y, direction))
                    amount++;
                start_x += amount;
                break;

            case ""so"":
                while (amount < steps && hasNoBorder(start_x, start_y + amount, direction))
                    amount++;
                start_y += amount;
                break;

            case ""we"":
                while (amount < steps && hasNoBorder(start_x - amount, start_y, direction))
                    amount++;
                start_x -= amount;
                break;

            default:
                return ""invalid command."";
        }

        return String.format(""(%d,%d)"", start_x, HEIGHT-1 - start_y);
    }

    private boolean hasNoBorder(int x, int y, String border) {
        switch (border){
            case ""no"":
                return !area[y][x].north;
            case ""ea"":
                return !area[y][x].east;
            case ""so"":
                return !area[y][x].south;
            default:
                return !area[y][x].west;
        }
    }

    class Field {
        private boolean north, east, south, west;

        public void set(String border){
            switch (border){
                case ""no"":
                    north = true;
                    break;
                case ""ea"":
                    east = true;
                    break;
                case ""so"":
                    south = true;
                    break;
                case ""we"":
                    west = true;
            }
        }
    }

    private void init() {
        // init area
        for (int y = 0; y < HEIGHT; y++) {
            for (int x = 0; x < WIDTH; x++) {
                area[y][x] = new Field();
            }
        }

        // set top frame border
        for (int x = 0; x < WIDTH; x++) {
            area[0][x].set(""no"");
        }

        // set right frame border
        for (int y = 0; y < HEIGHT; y++) {
            area[y][WIDTH - 1].set(""ea"");
        }

        // set bottom frame border
        for (int x = 0; x < WIDTH; x++) {
            area[HEIGHT - 1][x].set(""so"");
        }

        // set left frame border
        for (int y = 0; y < HEIGHT; y++) {
            area[y][0].set(""we"");
        }

        // #1 wall
        for (int y = 2; y < 8; y++) {
            area[y][3].set(""ea"");
            area[y][4].set(""we"");
        }

        // #2 wall
        for (int y = 4; y < 7; y++) {
            area[y][5].set(""ea"");
            area[y][6].set(""we"");
        }

        // #3 wall
        for (int y = 3; y < 7; y += 3) {
            area[y][6].set(""so"");
            area[y][7].set(""so"");
            area[y][8].set(""so"");

            area[y + 1][6].set(""no"");
            area[y + 1][7].set(""no"");
            area[y + 1][8].set(""no"");
        }
    }

    private void printField(){
        String tmp = """";

        for (int y = 0; y < HEIGHT; y++) {
            for (int x = 0; x < WIDTH; x++) {
                if (area[y][x].north)
                    tmp += ""n"";
                else
                    tmp += ""_"";

                if (area[y][x].east)
                    tmp += ""e"";
                else
                    tmp += ""_"";

                if (area[y][x].west)
                    tmp += ""w"";
                else
                    tmp += ""_"";

                if (area[y][x].south)
                    tmp += ""s"";
                else
                    tmp += ""_"";

                System.out.printf(""%s "", tmp);
                tmp = """";
            }
            System.out.println();
        }
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String goTo(String goCommandString);
}
",4698,185,29.887417218543046,91,0.043243243243243246,0.021621621621621623,0.06486486486486487,0.016216216216216217,0.2594594594594595,0.0,0.1783783783783784,0.021621621621621623,True,False,False,False,False,False,2,0.03783783783783784,0.04864864864864865,0.021621621621621623,0.010810810810810811,0.8378378378378378,0.15135135135135136,0.0,5.0,9,14.5,23
student47,student,,,"package thkoeln.st.st2praktikum.exercise;


    public class Dot {
        int X;
        int Y;


        public Dot(int X, int Y) {
            this.X = X;
            this.Y = Y;
        }
    }



package thkoeln.st.st2praktikum.exercise;


import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;



public class Exercise0 implements Walkable {

Dot startpunkt = new Dot (5,3);


/*
    IntStream verticalEDGE1 = IntStream.range(2,8); // @ X = 6
    IntStream verticalEDGE2 = IntStream.range(1,3); // @ X = 4
    IntStream horizontalEDGE1 =  IntStream.range(3,9); //@ Y = 3
    IntStream horizontalEDGE2 =  IntStream.range(1,6); //@ Y = 6

 */
         /* borders
         (Y >= 0 && Y <=8 ) @X=0 /outer left border
                            @X=12/outer right border
          (X>=0 && X <= 12) @Y=0 /bottom border
                            @Y=8 /top border
          */


    @Override
    public String walk(String walkCommandString) {

        System.out.println(""punkt:""+startpunkt.X+"",""+startpunkt.Y);

        String input = removeFirstandLast(walkCommandString);
        System.out.println(""incoming STRING: ""+input);

        String[] inputArray = input.split("","");
        System.out.println(""command: ""+Arrays.toString(inputArray));

        String input1 = inputArray[0];
        System.out.println(""direction: ""+input1);

        int input2 = Integer.parseInt(inputArray[1]);
        System.out.println( ""Strecke: ""+input2);





        switch(input1) {
            case (""we""):for(int i = 0; i<input2;i++){

                /*if(startpunkt.X == 4 && startpunkt.Y >= 1 && startpunkt.Y <= 3){
                    System.out.println(""vertical barrier reached"");
                    break;
                }
                
                 */
                if(startpunkt.X == 6 && startpunkt.Y >= 2 && startpunkt.Y <= 8){
                    System.out.println(""vertical barrier reached"");
                    break;
                }

                if(startpunkt.X==0 && startpunkt.Y >= 0 && startpunkt.Y <=8 ){
                    System.out.println(""outer left border reached"");
                    break;
                }
                startpunkt.X--;
            }
                break;

            case (""so""):for(int i = 0; i<input2;i++) {

                if(startpunkt.Y == 3 && startpunkt.X >= 3 && startpunkt.X <= 9){
                    System.out.println(""horizontal barrier reached"");
                    break;
                }
                if(startpunkt.Y == 6 && startpunkt.X >= 1 && startpunkt.X <= 6){
                    System.out.println(""horizontal barrier reached"");
                    break;
                }

                if(startpunkt.Y==0 && startpunkt.X >= 0 && startpunkt.X <=12 ){
                    System.out.println(""bottom border reached"");
                    break;
                }

                startpunkt.Y--;
            }
                break;

            case (""ea""):for(int i = 0; i<input2;i++) {

                if(startpunkt.X+1 == 4 && startpunkt.Y >= 1 && startpunkt.Y <= 3){
                    System.out.println(""vertikal barrier reached"");
                    break;
                }
                if(startpunkt.X+1 == 6 && startpunkt.Y >= 2 && startpunkt.Y <= 8){
                    System.out.println(""vertikal barrier reached"");
                    break;
                }

                if(startpunkt.X+1==0 && startpunkt.Y >= 0 && startpunkt.Y <=8 ){
                    System.out.println(""outer right border reached"");
                    break;
                }
                startpunkt.X++;
            }
                break;

            case (""no""):for(int i = 0; i<input2;i++) {

                if(startpunkt.Y+1 == 3 && startpunkt.X >= 3 && startpunkt.X <= 9){
                    System.out.println(""horizontal barrier reached"");
                    break;
                }
                if(startpunkt.Y+1 == 6 && startpunkt.X >= 1 && startpunkt.X <= 6){
                    System.out.println(""horizontal barrier reached"");
                    break;
                }

                if(startpunkt.Y+1==8 && startpunkt.X >= 0 && startpunkt.X <=12 ){
                    System.out.println(""top border reached"");
                    break;
                }

                startpunkt.Y++;
            }


                break;
        }

        System.out.println(""neuer punkt: ""+""(""+startpunkt.X +"",""+ startpunkt.Y+"")"");
        return ""(""+startpunkt.X +"",""+ startpunkt.Y+"")"";
    }
    public static String
    removeFirstandLast(String str)
    {

        // Creating a StringBuilder object
        StringBuilder sb = new StringBuilder(str);

        // Removing the last character
        // of a string
        sb.deleteCharAt(str.length() - 1);

        // Removing the first character
        // of a string
        sb.deleteCharAt(0);

        // Converting StringBuilder into a string
        // and return the modified string
        return sb.toString();
    }
    public static String

    addFirstandLast(String str)
    {

        // Creating a StringBuilder object
        StringBuilder sb = new StringBuilder(str);

        sb.insert(0,""("").append("")"");

        // Converting StringBuilder into a string
        // and return the modified string
        return sb.toString();
    }


}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",5474,195,37.97841726618705,84,0.08717948717948718,0.07179487179487179,0.020512820512820513,0.005128205128205128,0.48205128205128206,0.0,0.23076923076923078,0.09230769230769231,False,False,False,False,False,True,3,0.020512820512820513,0.015384615384615385,0.03076923076923077,0.010256410256410256,0.35384615384615387,0.14358974358974358,0.015384615384615385,4.7272727272727275,17,27.17241379310345,66
student50,student,,,"package thkoeln.st.st2praktikum.exercise;


public class Exercise0 implements GoAble {
    // 경계선 까지는 허용이나, 경계선이나 map 자체를 넘어 가는 게 불가능.
    // 대각선으로 움직이지 않는다. 왼 오 위 아래 로만 움직인다.

    int x = 7;
    int y = 7;

    String position;

    @Override
    public String go(String goCommandString) {

        if(goCommandString.contains(""no"")){
            String intStr =  goCommandString.replaceAll(""[^0-9]"","""");
            int zahl = Integer.parseInt(intStr);

            if( y == 0) {
                y = y + zahl;
                if( y > 8) {
                    y = 7;
                }

                if( x >= 2 && x <= 9){
                    y = 0;
                }
            }
            else if( y >= 1 && y <= 5){
                y = y + zahl;
                if( y > 8) {
                    y = 7;
                }

                if( x >= 2 && x <= 6){
                    if( y > 6){
                        y = 6;
                    }
                }
            }

          /*  if( y > 8) {
                y = 7;
            }
*/

        }
        else if(goCommandString.contains(""so"")){
            String intStr =  goCommandString.replaceAll(""[^0-9]"","""");
            int zahl = Integer.parseInt(intStr);

            if( y >= 6 ){
                y = y - zahl;
                if( x >= 2 && x <= 6){
                    if( y < 6){
                        y = 6;
                    }
                }
                if( x >= 7 && x <= 9){
                    if( y < 0) {
                        y = 1;
                    }
                }
                if( y < 0) {
                    y = 0;
                }
            }

            else if( y >= 1 && y <= 5){
                y = y - zahl;
                if( y < 0) {
                    y = 0;
                }
                if( x >= 2 && x <= 9){
                    if( y <= 0){
                        y = 1;
                    }
                }
            }
            //y = y - zahl;
            /*if( y < 0) {
                y = 0;
            }
*/
        }
        else if(goCommandString.contains(""we"")){
            String intStr =  goCommandString.replaceAll(""[^0-9]"","""");
            int zahl = Integer.parseInt(intStr);


            if( x <= 1){
                x = x - zahl;
                if( x < 0){
                    x = 0;
                }
            }
            else if( x >= 2 && x <= 9){
                x = x - zahl;
                if( y >= 1 && y <= 5){
                    if(x < 2) {
                        x = 2;
                    }
                }
            }
            else{
                x = 10;
            }

          /*  x = x - zahl;

            if( x < 0 ){
                x = 0;
            }
*/


        }
        else if(goCommandString.contains(""ea"")){
            String intStr =  goCommandString.replaceAll(""[^0-9]"","""");
            int zahl = Integer.parseInt(intStr);

            if( x < 2) {
                x = x + zahl;
                if( y >= 1 && y <= 5) {
                    if(x > 2){
                        x = 1;
                    }
                }
            }
            else if( x >= 2 && x <= 9){
                x = x + zahl;
                if( y >= 1 && y <= 7){
                    if( x > 10){
                        x = 9;
                    }
                }

            }
            else{
                x = 10;
            }

            //x = x + zahl;

         /*  if( y >= 1 && y <= 5) {
                if(x > 2){
                    x = 1;
                }
            }

            if( x > 10){
                x = 10;
            }
*/
        }

        // wall
    /*    if( 2 <= x && x <= 6) {
            if (y > 6) {
                y = 5;
            }
        }*/

        position = ""("" +x+"",""+y+"")"";

        return position;
    }

}

package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String go(String goCommandString);
}
",3974,176,26.013698630136986,69,0.056818181818181816,0.22727272727272727,0.0,0.0,0.5056818181818182,0.0,0.1534090909090909,0.0,False,False,False,False,False,False,2,0.011363636363636364,0.017045454545454544,0.045454545454545456,0.005681818181818182,0.4943181818181818,0.06818181818181818,0.0,4.0,8,9.966666666666667,40
student52,student,,,"package thkoeln.st.st2praktikum.exercise;

import lombok.AllArgsConstructor;

import java.util.ArrayList;

public class Exercise0 implements Moveable {
    Cords cords = new Cords(1,7);
    ArrayList<Barrier> barriers = createBarriers();

    @Override
    public String move(String moveCommandString) {
        var s = moveCommandString.replace(""["","""").replace(""]"","""").split("","");
        var dir = Direction.valueOf(s[0]);
        var steps = Integer.parseInt(s[1]);

        for (int i = 0; i < steps; i++) { moveStep(dir); }

        var debug = moveCommandString + "" -> "" + cords.toString();
        System.out.println(debug);
        return cords.toString();
    }

    private void moveStep(Direction dir){
        for (Barrier b : barriers){ if (b.blocks(dir)) return; }

        if (dir == Direction.no) cords.y++;
        if (dir == Direction.ea) cords.x++;
        if (dir == Direction.so) cords.y--;
        if (dir == Direction.we) cords.x--;
    }

    enum Direction {
        no, ea, so, we
    }

    @AllArgsConstructor()
    public class Cords {
        public Integer x; public Integer y;
        @Override
        public String toString() {
            return ""("" + x.toString() + "","" + y.toString() + "")"";
        }
    }

    @AllArgsConstructor
    public class Barrier{
        public Cords start;
        public Cords end;

        public Boolean blocks(Direction dir){
            var b = false;
            if (dir == Direction.no && start.y == cords.y + 1 && cords.x >= start.x && cords.x < end.x)
                b = true;
            if (dir == Direction.ea && start.x == cords.x + 1 && cords.y >= start.y && cords.y < end.y)
                b = true;
            if (dir == Direction.so && start.y.equals(cords.y) && cords.x >= start.x && cords.x < end.x)
                b = true;
            if (dir == Direction.we && start.x.equals(cords.x) && cords.y >= start.y && cords.y < end.y)
                b = true;
            return b;
        }
    }


    private Barrier horLine(Integer st, Integer end, Integer y){
        return new Barrier(new Cords(st,y), new Cords(end,y));
    }
    private Barrier verLine(Integer st, Integer end, Integer x){
        return new Barrier(new Cords(x,st), new Cords(x,end));
    }

    private ArrayList<Barrier> createBarriers(){
        var l = new ArrayList<Barrier>();

        l.add(verLine(0,9,0));
        l.add(verLine(0,9,12));
        l.add(horLine(0,12,0));
        l.add(horLine(0,12,9));

        l.add(verLine(3,9,3));
        l.add(verLine(0,2,5));
        l.add(verLine(0,4,6));

        l.add(horLine(3,5,3));

        return l;
    }

}

package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String move(String moveCommandString);
}
",2744,96,35.78378378378378,104,0.0,0.09375,0.020833333333333332,0.0,0.3854166666666667,0.0,0.21875,0.010416666666666666,False,False,True,False,True,False,2,0.08333333333333333,0.0625,0.0625,0.03125,0.6875,0.3229166666666667,0.020833333333333332,3.3529411764705883,17,0.0,0
student54,student,,,"package thkoeln.st.st2praktikum.exercise;


import org.junit.jupiter.params.shadow.com.univocity.parsers.conversions.Conversion;
import org.xmlunit.util.Convert;

import java.util.ArrayList;
import java.util.List;

public class Exercise0 implements GoAble {

    class Position
    {
        int x;
        int y;

        public Position(int x, int y)
        {
            this.x = x;
            this.y = y;
        }
    }

    class Wall
    {
        Position start;
        Position end;

        // h - horizontally
        // v - vertically
        char orientation;

        public Wall(Position start, Position end, char orientation)
        {
            this.start = start;
            this.end = end;
            this.orientation = orientation;
        }
    }

    class Cell
    {
        boolean south;
        boolean west;

        public Cell()
        {
            south = false;
            west = false;
        }
    }

    public class Grid
    {
        int width;
        int height;
        List<Wall> walls;
        Cell [][] grid;

        public Grid(int width, int height, List<Wall> walls)
        {
            this.width = width;
            this.height = height;
            this.walls = walls;
            grid = new Cell[width][height];
        }

        public void fill_with_cells()
        {
            for (int x = 0; x < width; x++)
            {
                for(int y = 0; y < height; y++)
                {
                    grid[x][y] = new Cell();
                }
            }
        }

        public void buildWalls()
        {
            for(int i=0; i<walls.size(); i++)
            {
                if(walls.get(i).orientation == 'v')
                {
                    for (int y = walls.get(i).start.y; y < walls.get(i).end.y; y++)
                    {
                        grid[walls.get(i).start.x][y].west = true;
                    }
                }
                else
                {
                    for (int x = walls.get(i).start.x; x < walls.get(i).end.x; x++)
                    {
                        grid[x][walls.get(i).start.y].south = true;
                    }
                }
            }
        }
    }





    int grid_width = 12;
    int grid_height = 9;

    List<Wall> walls;

    public Position current_position = new Position(1,7);
    public Grid grid;

    public Exercise0()
    {
        walls = new ArrayList<>();
        walls.add(new Wall(new Position(5,0), new Position(5,2), 'v'));
        walls.add(new Wall(new Position(6,0), new Position(6,4), 'v'));
        walls.add(new Wall(new Position(3,3), new Position(3,9), 'v'));
        walls.add(new Wall(new Position(3,3), new Position(5,3), 'h'));

        grid = new Grid(grid_width, grid_height, walls);
        grid.fill_with_cells();
        grid.buildWalls();

    }

    String build_return_string(Position position)
    {
        return ""("" + position.x + "","" + position.y + "")"";
    }


    @Override
    public String go(String goCommandString) {

        String direction = goCommandString.substring(1,3);
        int steps = Integer.parseInt(goCommandString.substring(4,goCommandString.length()-1));


        for(int i = 0; i < steps; i++)
        {
            switch ((direction))
            {
                case ""no"":
                {
                    if(current_position.y + 1 <= grid_height)
                    {
                        if(!grid.grid[current_position.x][current_position.y+1].south)
                        {
                            current_position.y += 1;
                        }
                        else
                        {
                            return build_return_string(current_position);
                        }
                    }
                    else
                    {
                        return build_return_string(current_position);
                    }
                }
                break;
                case ""ea"":
                {
                    if(current_position.x + 1 <= grid_width)
                    {
                        if(!grid.grid[current_position.x+1][current_position.y].west)
                        {
                            current_position.x += 1;
                        }
                        else
                        {
                            return build_return_string(current_position);
                        }
                    }
                    else
                    {
                        return build_return_string(current_position);
                    }
                }
                break;
                case ""so"":
                {
                    if(current_position.y - 1 >= 0)
                    {
                        if(!grid.grid[current_position.x][current_position.y].south)
                        {
                            current_position.y -= 1;
                        }
                        else
                        {
                            return build_return_string(current_position);
                        }
                    }
                    else
                    {
                        return build_return_string(current_position);
                    }
                }
                break;
                case ""we"":
                {
                    if(current_position.x - 1 >= 0)
                    {
                        if(!grid.grid[current_position.x][current_position.y].west)
                        {
                            current_position.x -= 1;
                        }
                        else
                        {
                            return build_return_string(current_position);
                        }
                    }
                    else
                    {
                        return build_return_string(current_position);
                    }
                }
                break;
            }
        }
        return build_return_string(current_position);
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String go(String goCommandString);
}
",6171,230,30.15736040609137,94,0.008695652173913044,0.0391304347826087,0.02608695652173913,0.004347826086956522,0.1956521739130435,0.0,0.12173913043478261,0.0,True,True,False,False,False,False,2,0.021739130434782608,0.06956521739130435,0.008695652173913044,0.021739130434782608,0.46956521739130436,0.11739130434782609,0.017391304347826087,6.0,16,15.0,16
student55,student,,,"/*Atidy-uprobotisusedtotidyuparoom-collectgarbage,sortstuff,etc.
Inmilestone0,youhavethetasktosteersuchatidy-uprobotacrossaroomwithobstacles.
Theroomissquare-shaped.Inthefollowingimage,youseeahowtheroomismodelledasa
systemofcells.*/

package thkoeln.st.st2praktikum.exercise;


        public class Exercise0 implements GoAble{

        Integer x=5;
        Integer y=3;

@Override
public String goTo(String goCommandString){


        int steps=Integer.parseInt(String.valueOf(goCommandString.charAt(4)));


        if(goCommandString.charAt(1)=='n'){


        if(x>=3&&x<=8){
            if(y<3){
                if(y+steps>=2){
                y=2;
                return""(""+x+"",""+y+"")"";
                }
            }
        }

        if(x>0&&x<=5){
            if(y<6){
                if(y+steps>=5){
                    y=5;
                    return""(""+x+"",""+y+"")"";
                }
            }
        }

            if (x == 4 && y == 0) {
                y = 0;
                return""(""+x+"",""+y+"")"";
            }

        if(y+steps>=7){
            y=7;
            return""(""+x+"",""+y+"")"";
        }



        y+=steps;
        return""(""+x+"",""+y+"")"";

        }





        if(goCommandString.charAt(1)=='e'){

            if(y==1||y==2){
                if(x<4){
                    if(x+steps>3){
                        x=3;
                        return""(""+x+"",""+y+"")"";
                    }
                }
            }

            if(y>=2&&y<=7){
                if(x<6){
                    if(x+steps>5){
                        x=5;
                        return""(""+x+"",""+y+"")"";
                    }
                }
            }

            if(x>11){
                x=11;
                return""(""+x+"",""+y+"")"";
            }
            if(x>0&&x<5){
                if(y==6){
                    x=0;
                    return""(""+x+"",""+y+"")"";
                }
            }

        x+=steps;
        return""(""+x+"",""+y+"")"";

        }






        if(goCommandString.charAt(1)=='s'){

            if(x>=1&&x<=5){
                if(y>=6){
                    if(y-steps<=5){
                        y=6;
                        return""(""+x+"",""+y+"")"";
                    }
                }
            }

            if(x>=3&&y<=8){
                if(y>=3){
                    if(y-steps<3){
                        y=3;
                        return""(""+x+"",""+y+"")"";
                    }
                }
             }

            if(y-steps<0){
                y=0;
                return""(""+x+"",""+y+"")"";
            }

        y-=steps;
        return""(""+x+"",""+y+"")"";
        }




        if(goCommandString.charAt(1)=='w'){

            if(y>=2&&y<=7){
                if(x>5){
                    if(x-steps<=6){
                        y=6;
                        return""(""+x+"",""+y+"")"";
                    }
                }
            }

        if(y==1||y==2){
            if(x>3){
                if(x-steps<=4){
                    x=4;
                    return""(""+x+"",""+y+"")"";
                }
            }
        }

        if(x-steps<=0){
            x=0;
            return""(""+x+"",""+y+"")"";
        }
                x-=steps;
                return""(""+x+"",""+y+"")"";
            }

            return""(""+x+"",""+y+"")"";
            }
        }


package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String goTo(String goCommandString);
}

package thkoeln.st.st2praktikum.exercise;

public class Obstacle {
     public Obstacle(){

    }

};
//A room is divided into cells by an x- and y-coordinate system, each starting
//at 0.
package thkoeln.st.st2praktikum.exercise;

public class Room {
    public Room(){

    }
}",3712,191,25.897058823529413,78,0.015706806282722512,0.18324607329842932,0.0,0.0,0.3717277486910995,0.0,0.2198952879581152,0.0,False,False,True,False,False,False,4,0.010471204188481676,0.010471204188481676,0.005235602094240838,0.015706806282722512,0.5863874345549738,0.03664921465968586,0.0,2.3333333333333335,5,51.666666666666664,76
student56,student,,,"package thkoeln.st.st2praktikum.exercise;

import javax.persistence.criteria.CriteriaBuilder;

public class Exercise0 implements Moveable {

    Integer horizontal = 5;
    Integer vertikal   = 3;

    @Override
    public String move(String moveCommandString) {
/*
        String barrier1 = ""(1,6)-(5,6)"";
        String barrier2 = ""(3,3)-(8,3)"";
        String barrier3 = ""(4,1)-(4,2)"";
        String barrier4 = ""(6,2)-(6,7)"";

 */





        int steps = Integer.parseInt(String.valueOf(moveCommandString.charAt(4)));


        if ( moveCommandString.charAt(1) == 'n') {


            if (horizontal >= 3 && horizontal <= 8) {
                if (vertikal < 3) {
                    if (vertikal + steps >= 2) {
                        vertikal = 2;
                        return ""(""+horizontal+"",""+vertikal+"")"";
                    }
                }
            }

            if ( horizontal >= 1 && horizontal <= 5) {
                if ( vertikal < 7 ){
                    if ( vertikal + steps >= 7){
                        vertikal = 6;
                        return ""(""+horizontal+"",""+vertikal+"")"";
                    }
                }
            }

            if (vertikal + steps > 7) {
                vertikal = 7;
                return ""(""+horizontal+"",""+vertikal+"")"";
            }



                vertikal += steps;
                return ""(""+horizontal+"",""+vertikal+"")"";

        }





        if ( moveCommandString.charAt(1) == 'e'){

            if ( vertikal == 1 || vertikal == 2 ) {
                if (horizontal < 4) {
                    if (horizontal + steps > 3) {
                        horizontal = 3;
                        return ""(""+horizontal+"",""+vertikal+"")"";
                    }
                }
            }

            if (vertikal >= 2 && vertikal <= 7) {
                if (horizontal < 6) {
                    if (horizontal + steps > 5) {
                        horizontal = 5;
                        return ""(""+horizontal+"",""+vertikal+"")"";
                    }
                }
            }

            if ( horizontal > 11 ){
                horizontal = 11;
                return ""(""+horizontal+"",""+vertikal+"")"";
            }

                horizontal += steps;
                return ""(""+horizontal+"",""+vertikal+"")"";

        }






        if ( moveCommandString.charAt(1) == 's'){

            if ( horizontal >=1 && horizontal <= 5 ){
                if ( vertikal > 5){
                    if ( vertikal - steps < 6){
                        vertikal = 6;
                        return ""(""+horizontal+"",""+vertikal+"")"";
                    }
                }
            }

            if ( horizontal >= 3 && horizontal <= 8){
                if (vertikal > 2 ){
                    if ( vertikal - steps < 3){
                        vertikal = 3;
                        return ""(""+horizontal+"",""+vertikal+"")"";
                    }
                }
            }

            if ( vertikal - steps < 0 ){
                vertikal = 0;
                return ""(""+horizontal+"",""+vertikal+"")"";
            }

                vertikal -= steps;
                return ""(""+horizontal+"",""+vertikal+"")"";
        }




        if ( moveCommandString.charAt(1) == 'w'){

            if (vertikal >= 2 && vertikal <= 7){
                if ( horizontal > 5 ){
                    if ( horizontal - steps < 6){
                        vertikal = 6;
                        return ""(""+horizontal+"",""+vertikal+"")"";
                    }
                }
            }

            if ( vertikal == 1 || vertikal == 2  ){
                if ( horizontal > 3){
                    if ( horizontal - steps < 4) {
                        horizontal = 4;
                        return ""(""+horizontal+"",""+vertikal+"")"";
                    }
                }
            }

            if ( horizontal - steps <= 0 ){
                horizontal = 0;
                return ""(""+horizontal+"",""+vertikal+"")"";
            }
                horizontal -= steps;
                return ""(""+horizontal+"",""+vertikal+"")"";
        }

        return ""(""+horizontal+"",""+vertikal+"")"";
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String move(String moveCommandString);
}
",4276,167,35.11965811965812,82,0.005988023952095809,0.19161676646706588,0.0,0.0,0.47904191616766467,0.0,0.2275449101796407,0.0,False,False,True,False,False,False,2,0.011976047904191617,0.011976047904191617,0.005988023952095809,0.005988023952095809,0.6047904191616766,0.041916167664670656,0.005988023952095809,7.666666666666667,10,25.6,32
student59,student,,,"package thkoeln.st.st2praktikum.exercise;
import java.util.ArrayList;
public class Exercise0 implements GoAble {

    private static final String INITIAL = ""(4,0)"";
    private static final String[] BORDERS = {""(7,1)-(7,6)"",""(5,6)-(7,6)"",""(1,6)-(3,6)"",""(1,0)-(1,6)""}; //, ""(0,0)-(0,8)"",""(0,8)-(11,8)"",""(11,0)-(11,8)"",""(0,0)-(11,0)""

    private boolean first = true;
    private String varNewPostion;
    ArrayList<String> orderedBorders = new ArrayList<String>();

    @Override
    public String go(String goCommandString) {

        if(this.first) {
            this.varNewPostion = INITIAL;
            this.first = false;

            for (String border: BORDERS) {
                //(0,1)
                String[] border_item = border.split(""-"");
                String border_item_start_raw = border_item[0].substring(1, border_item[0].length() - 1);
                String[] border_item_start = border_item_start_raw.split("","");
                String border_item_end_raw = border_item[1].substring(1, border_item[1].length() - 1);
                String[] border_item_end = border_item_end_raw.split("","");
                if(Integer.parseInt(border_item_start[0]) == Integer.parseInt(border_item_end[0])){
                    for (int i = Integer.parseInt(border_item_start[1]); i < Integer.parseInt(border_item_end[1])+1; i++) {
                        String border_item_item = ""(""+border_item_start[0]+"",""+i+"")"";
                        this.orderedBorders.add(border_item_item);
                    }
                }
                if(Integer.parseInt(border_item_start[1]) == Integer.parseInt(border_item_end[1])){
                    for (int i = Integer.parseInt(border_item_start[0]); i < Integer.parseInt(border_item_end[0])+1; i++) {
                        String border_item_item = ""(""+i+"",""+border_item_start[1]+"")"";
                        this.orderedBorders.add(border_item_item);
                    }
                }
                this.orderedBorders.add(""|-|"");
            }
//            System.out.println(this.orderedBorders);
        }

        //Convert new_postion String into Array [0]-> x direction
        //                                      [1]-> y direction
        String new_postion_raw = this.varNewPostion.substring(1, this.varNewPostion.length() - 1);
        String[] new_position = new_postion_raw.split("","");

        this.varNewPostion = ""(""+new_position[0]+"",""+new_position[1]+"")"";

        //Convert String into Array [0]-> movement direction
        //                          [1]-> movement power
        String movement_raw = goCommandString.substring(1, goCommandString.length() - 1);
        String[] movement = movement_raw.split("","");
        int power = Integer.parseInt(movement[1]);

        this.varNewPostion = this.move(movement[0], power, new_position);

        return this.varNewPostion;
    }

    /**
     *
     * @param direction no, ea, so, we
     * @param power anzahl der felder die sich bewegt werden soll
     * @param position aktuelle position
     * @return neue position
     */
    private String move(String direction, int power, String[] position) {

        for(int i=0;i<power;i++){
            System.out.println(""----------------"");
            System.out.print(""Akutelle Position: "");
            System.out.println(""(""+position[0]+"",""+position[1]+"")"");
            System.out.print(""direction: "");
            System.out.println(direction);
            System.out.print(""power: "");
            System.out.println(power);
            //Check Border in Direction
            // -> Border yes no
            if(borderCheck(direction, position)) {
                return ""(""+position[0]+"",""+position[1]+"")"";
            }else{
                switch (direction) {
                    case ""no"":
                        position[1] = Integer.parseInt(position[1])+1+"""";
                        break;
                    case ""ea"":
                        position[0] = Integer.parseInt(position[0])+1+"""";
                        break;
                    case ""so"":
                        position[1] = Integer.parseInt(position[1])-1+"""";
                        break;
                    case ""we"":
                        position[0] = Integer.parseInt(position[0])-1+"""";
                        break;
                }
            }
        }
        return ""(""+position[0]+"",""+position[1]+"")"";
    }

    /**
     *
     * @param direction no, ea, so, we
     * @param position aktuelle position bevor man movt
     * @return boolean ob border im weg ist oder nicht
     */
    private boolean borderCheck(String direction, String[] position) {

        boolean result = false;
        String maybeBorderStart;
        String maybeBorderEnd;

        switch (direction) {
            case ""no"":
                if(Integer.parseInt(position[1])+1 == 8){
                    result = true;
                }
                break;
            case ""ea"":
                if(Integer.parseInt(position[0])+1 == 11){
                    result = true;
                }
                break;
            case ""so"":
                if(Integer.parseInt(position[1])-1 == -1){
                    result = true;
                }
                break;
            case ""we"":
                if(Integer.parseInt(position[0])-1 == -1){
                    result = true;
                }
                break;
        }

        if(result){
            return result;
        }


        switch (direction) {
            case ""no"":
                maybeBorderStart = ""(""+position[0]+"",""+(Integer.parseInt(position[1])+1)+"")"";
                maybeBorderEnd = ""(""+(Integer.parseInt(position[0])+1)+"",""+(Integer.parseInt(position[1])+1)+"")"";
                System.out.println(maybeBorderStart);
                System.out.println(maybeBorderEnd);
                result = borderSearch(maybeBorderStart, maybeBorderEnd);
                break;
            case ""ea"":
                maybeBorderStart = ""(""+(Integer.parseInt(position[0])+1)+"",""+Integer.parseInt(position[1])+"")"";
                maybeBorderEnd = ""(""+(Integer.parseInt(position[0])+1)+"",""+(Integer.parseInt(position[1])+1)+"")"";
                result = borderSearch(maybeBorderStart, maybeBorderEnd);
                System.out.println(maybeBorderStart);
                System.out.println(maybeBorderEnd);
                break;
            case ""so"":
                maybeBorderStart = ""(""+position[0]+"",""+Integer.parseInt(position[1])+"")"";
                maybeBorderEnd = ""(""+(Integer.parseInt(position[0])+1)+"",""+Integer.parseInt(position[1])+"")"";
                result = borderSearch(maybeBorderStart, maybeBorderEnd);
                System.out.println(maybeBorderStart);
                System.out.println(maybeBorderEnd);
                break;
            case ""we"":
                maybeBorderStart = ""(""+position[0]+"",""+Integer.parseInt(position[1])+"")"";
                maybeBorderEnd = ""(""+Integer.parseInt(position[0])+"",""+(Integer.parseInt(position[1])+1)+"")"";
                result = borderSearch(maybeBorderStart, maybeBorderEnd);
                System.out.println(maybeBorderStart);
                System.out.println(maybeBorderEnd);
                break;
        }
        return result;
    }

    /**
     *
     * @param start Start-Koordinate der Maybe-Border
     * @param ende End-Koordinate der Maybe-Border
     * @return  true oder false , ob border oder nicht
     */
    private boolean borderSearch(String start, String ende){

        if(this.orderedBorders.contains(start)){
            int startIndex = this.orderedBorders.indexOf(start);
            System.out.println(this.orderedBorders.get(startIndex));
            System.out.println(this.orderedBorders.get(startIndex+1));
            if(!this.orderedBorders.get(startIndex + 1).equals(""|-|"")){
                System.out.println(this.orderedBorders.get(startIndex+1).equals(ende));
                return this.orderedBorders.get(startIndex+1).equals(ende);
            }
        }
        return false;
    }

}

package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String go(String goCommandString);
}
",8182,201,44.837078651685395,166,0.05970149253731343,0.05472636815920398,0.01990049751243781,0.014925373134328358,0.6716417910447762,0.0,0.10945273631840796,0.0945273631840796,True,False,False,False,True,False,2,0.024875621890547265,0.024875621890547265,0.07960199004975124,0.004975124378109453,0.6766169154228856,0.39800995024875624,0.004975124378109453,9.666666666666666,17,29.04,61
student62,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Walkable {
int x= 8;
int y=3;
Wall[] borders;
    public Exercise0(){
        borders = new Wall[15];
        borders[0] = new Wall(4,1,true);
        borders[1] = new Wall(4,2 ,true);
        borders[2] = new Wall(4,3 ,true);
        borders[3] = new Wall(4,4 ,true);
        borders[4] = new Wall(4,5 ,true);
        borders[5] = new Wall(4,6 ,true);
        borders[6] = new Wall(6,2 ,true);
        borders[7] = new Wall(6,3,true);
        borders[8] = new Wall(6,4,true);
        borders[9] = new Wall(6,2,false);
        borders[10] = new Wall(6,5,false);
        borders[11] = new Wall(7,2,false);
        borders[12] = new Wall(7,5,false);
        borders[13] = new Wall(8,2,false);
        borders[14] = new Wall(8,5,false);
    }
    @Override
    public String walk(String walkCommandString) {
        walkCommandString = walkCommandString.substring(1, walkCommandString.length() - 1);
        String[] commands = walkCommandString.split("","");
        boolean stop=false;
        for(int i=0;i<Integer.parseInt(commands[1]);i++){
            switch (commands[0]){
                case ""no"":
                    for (Wall w:borders) {
                        if(w.x==x&&w.y==y+1&&!w.vertical){
                            stop=true;
                        }
                    }
                    if(!stop) y+=1;
                    break;
                case ""ea"":
                    for (Wall w:borders) {
                        if(w.x==x+1&&w.y==y&&w.vertical){
                            stop=true;
                        }
                    }
                    if(!stop) x+=1;
                    break;
                case ""so"":
                    for (Wall w:borders) {
                        if(w.x==x&&w.y==y&&!w.vertical){
                            stop=true;
                        }
                    }
                    if(!stop) y-=1;
                    break;
                case ""we"":
                    for (Wall w:borders) {
                        if(w.x==x&&w.y==y&&w.vertical){
                            stop=true;
                        }
                    }
                    if(!stop) x-=1;
                    break;
            }
        }
        return ""(""+x+"",""+y+"")"";
    }
}

package thkoeln.st.st2praktikum.exercise;

public abstract interface Walkable {
    String walk(String walkCommandString);
}

package thkoeln.st.st2praktikum.exercise;

public class Wall {
    int x;
    int y;
    boolean vertical;

    public Wall(int parx ,int pary,boolean v){
        x=parx;
        y=pary;
        vertical=v;
    }
}
",2668,88,31.463414634146343,91,0.0,0.09090909090909091,0.056818181818181816,0.011363636363636364,0.7954545454545454,0.0,0.06818181818181818,0.0,True,False,False,False,False,False,3,0.022727272727272728,0.06818181818181818,0.022727272727272728,0.022727272727272728,0.7386363636363636,0.045454545454545456,0.0,4.714285714285714,17,0.0,0
student63,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Walkable {

    int x = 1;
    int y = 7;

    @Override
    public String walkTo(String walkCommandString) {
        String s = walkCommandString;
        s = s.replaceAll(""\\D+"","""");
        int n = Integer.parseInt(s);
        for (int i=0; i<n; i++) {
            if (walkCommandString.charAt(1)=='n') {
                if (x==3 || x==4 && y==2) {
                    i=n;
                } else if (y<8) {
                    y++;
                }
            } else if (walkCommandString.charAt(1)=='s') {
                if (x==3 || x==4 && y==3) {
                    i=n;
                } else if (y>0) {
                    y--;
                }
            } else if (walkCommandString.charAt(1)=='e') {
                if ((x==2 && y>=3 && y<=8) || (x==4 && y==0 || y==1) || (x==5 && y>=0 && y<=3)) {
                    i=n;
                } else if (x<11) {
                    x++;
                }
            } else if (walkCommandString.charAt(1)=='w') {
                if ((x==3 && y>=3 && y<=8) || (x==5 && y==0 || y==1) || (x==6 && y>=0 && y<=3)) {
                    i=n;
                } else if (x>0) {
                    x--;
                }
            }
        }
        return ""("" + x + "","" + y + "")"";

        /*int x = 1;
        int y = 7;
        int steps = walkCommandString.charAt(4);
        if(walkCommandString.charAt(1)=='n') {
            y+=steps;
            if (y>8) {
                y=8;
            }
        } else if(walkCommandString.charAt(1)=='s') {
            y-=steps;
            if (y<0) {
                y=0;
            }
        } else if(walkCommandString.charAt(1)=='e') {
            x+=steps;
            if (x>11) {
                x=11;
            }
        } else if(walkCommandString.charAt(1)=='w') {
            x-=steps;
            if (x<0) {
                x=0;
            }
        }
        return ""("" + x + "","" + y + "")"";*/
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);
}
",2119,74,30.073529411764707,97,0.013513513513513514,0.2702702702702703,0.013513513513513514,0.0,0.7567567567567568,0.0,0.08108108108108109,0.0,False,False,False,False,False,False,2,0.02702702702702703,0.02702702702702703,0.02702702702702703,0.013513513513513514,0.6486486486486487,0.08108108108108109,0.0,3.6666666666666665,17,14.68,45
student64,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Boundary {

    private Point startPoint;
    private Point endPoint;

    public Boundary(Point startPoint, Point endPoint) {
        this.startPoint = startPoint;
        this.endPoint = endPoint;
    }

    public boolean isVertical()
    {
        return this.startPoint.getX() == this.endPoint.getX();
    }

    public boolean isPointColliding(Point somePoint)
    {
        if(!this.isVertical())
        {
            if(this.endPoint.getY() != somePoint.getY())
            {
                return false;
            }

            System.out.println(String.format(""PUNKT %d %d"", somePoint.getX(), somePoint.getY()));
            return somePoint.getX() >= this.startPoint.getX() &&
                    somePoint.getX() < this.endPoint.getX();
        }

        if(this.isVertical())
        {
            if(this.endPoint.getX() != somePoint.getX())
            {
                return false;
            }

            return somePoint.getY() >= this.startPoint.getY() &&
                    somePoint.getY() < this.endPoint.getY();
        }

        return false;
//
//        int dxc = somePoint.getX() - startPoint.getX();
//        int dyc = somePoint.getY() - startPoint.getY();
//
//        int dxl = endPoint.getX() - startPoint.getX();
//        int dyl = endPoint.getY() - startPoint.getY();
//
//        int crosses = dxc * dyl - dyc * dxl;
//
//        return 0 == crosses;
    }

    public Point getStartPoint() {
        return startPoint;
    }

    public Point getEndPoint() {
        return endPoint;
    }
}


package thkoeln.st.st2praktikum.exercise;

public class CleaningDevice {
    private Point currentPosition;
    private String lastDirection;

    public CleaningDevice(Point initialPosition) {
        this.currentPosition = initialPosition;
        this.lastDirection = """";
    }

    public void moveByOneIn(String direction)
    {
        switch (direction)
        {
            case ""ea"":
                this.currentPosition.addToX(1);
                break;
            case ""we"":
                this.currentPosition.addToX(-1);
                break;
            case ""no"":
                this.currentPosition.addToY(1);
                break;
            case ""so"":
                this.currentPosition.addToY(-1);
                break;
        }

        this.lastDirection = direction;
    }

    public Point getCurrentPosition()
    {
        return currentPosition;
    }
}

package thkoeln.st.st2praktikum.exercise;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Exercise0 implements Walkable {

    private CleaningDevice cleaningDevice;

    private Boundary[] boundaries;

    public Exercise0() {
        this.cleaningDevice = new CleaningDevice(
                new Point(4, 0)
        );

        this.boundaries = new Boundary[8];


        // Linke Flanke
        this.boundaries[0] = new Boundary(
                new Point(1, 0),
                new Point(1, 6)
        );
        this.boundaries[1] = new Boundary(
                new Point(1, 6),
                new Point(4, 6)
        );

        // Rechts Flanke
        this.boundaries[2] = new Boundary(
                new Point(7, 1),
                new Point(7, 6)
        );
        this.boundaries[3] = new Boundary(
                new Point(5, 6),
                new Point(7, 6)
        );

        // Raum
        this.boundaries[4] = new Boundary(
                new Point(0, 0),
                new Point(12, 0)
        );
        this.boundaries[5] = new Boundary(
                new Point(0, 8),
                new Point(12, 8)
        );
        this.boundaries[6] = new Boundary(
                new Point(0, 0),
                new Point(0, 8)
        );
        this.boundaries[7] = new Boundary(
                new Point(12, 0),
                new Point(12, 8)
        );
    }

    @Override
    public String walk(String walkCommandString) {

        System.out.println(walkCommandString);

        this.decodeWalkCommandString(walkCommandString);

        return String.format(""(%d,%d)"", this.cleaningDevice.getCurrentPosition().getX(), this.cleaningDevice.getCurrentPosition().getY());
    }

    private void decodeWalkCommandString(String walkCommandString)
    {
        String walkCommandStringRegex = ""\\[(no|ea|so|we),([0-9]+)\\]"";
        Pattern pattern = Pattern.compile(walkCommandStringRegex);

        Matcher matcher = pattern.matcher(walkCommandString);

        if (!matcher.matches())
        {
            return;
        }

        String direction = matcher.group(1);
        int steps = Integer.parseInt(matcher.group(2));

        for (int stepper = 0; stepper < steps; stepper++)
        {
            System.out.println(String.format(""(%d,%d)"", this.cleaningDevice.getCurrentPosition().getX(), this.cleaningDevice.getCurrentPosition().getY()));
            if(this.willDeviceCollideInDirection(direction))
            {
                break;
            }

            this.cleaningDevice.moveByOneIn(direction);
        }
    }

    private boolean willDeviceCollideInDirection(String direction)
    {
        Point currentDevicePos = this.cleaningDevice.getCurrentPosition();

        for (Boundary boundary: this.boundaries)
        {
            Point collidingPoint = new Point(currentDevicePos.getX(), currentDevicePos.getY());

            switch (direction)
            {
                case ""ea"": // rechts
                    if(!boundary.isVertical())
                    {
                        continue;
                    }
                    collidingPoint.setX(collidingPoint.getX() + 1);
                    break;
                case ""we"": // links
                    if(!boundary.isVertical())
                    {
                        continue;
                    }
                    break;
                case ""no"":
                    if(boundary.isVertical())
                    {
                        continue;
                    }
                    collidingPoint.setY(collidingPoint.getY() + 1);
                    break;
                case ""so"":
                    if(boundary.isVertical())
                    {
                        continue;
                    }
                    break;
            }

            if(boundary.isPointColliding(collidingPoint))
            {
                System.out.println(String.format(""Colliding Boundary %d %d"", boundary.getStartPoint().getX(), boundary.getStartPoint().getY()));
                return true;
            }
        }

        return false;
    }
}

package thkoeln.st.st2praktikum.exercise;

public class Point {

    private int x;
    private int y;


    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public void addToX(int x) {
        this.x += x;
    }

    public void addToY(int y) {
        this.y += y;
    }

    public int getX() {
        return x;
    }

    public void setX(int x) {
        this.x = x;
    }

    public int getY() {
        return y;
    }

    public void setY(int y) {
        this.y = y;
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",7270,290,29.957081545064376,155,0.05172413793103448,0.03793103448275862,0.020689655172413793,0.006896551724137931,0.22758620689655173,0.0,0.18620689655172415,0.013793103448275862,False,False,False,True,False,False,5,0.05517241379310345,0.027586206896551724,0.02413793103448276,0.013793103448275862,0.23103448275862068,0.21724137931034482,0.006896551724137931,10.625,22,18.8,47
student65,student,,,"package thkoeln.st.st2praktikum.exercise;

import java.util.Vector;

public class Exercise0 implements GoAble {
    Handle handle = new Handle();
    public Exercise0() {}

    @Override
    public String goTo(String goCommandString) {
        return handle.goTo(goCommandString);
    }
}

package thkoeln.st.st2praktikum.exercise;

import java.util.Vector;

public class Field {
    public Vector<Obstacle> getObstacles() {
        return obstacles;
    }

    public void setObstacles(Vector<Obstacle> obstacles) {
        this.obstacles = obstacles;
    }

    private Vector<Obstacle> obstacles;
    Field(){
        obstacles = new Vector<Obstacle>();
        obstacles.add(new Obstacle(new Vector2d(0,0),new Vector2d(0,9)));
        obstacles.add(new Obstacle(new Vector2d(0,9),new Vector2d(12,9)));
        obstacles.add(new Obstacle(new Vector2d(12,0),new Vector2d(12,9)));
        obstacles.add(new Obstacle(new Vector2d(0,0),new Vector2d(12,0)));

        obstacles.add(new Obstacle(new Vector2d(3,0),new Vector2d(3,3)));
        obstacles.add(new Obstacle(new Vector2d(5,0),new Vector2d(5,4)));
        obstacles.add(new Obstacle(new Vector2d(4,5),new Vector2d(7,5)));
        obstacles.add(new Obstacle(new Vector2d(7,5),new Vector2d(7,9)));
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String goTo(String goCommandString);
}

package thkoeln.st.st2praktikum.exercise;

public class Handle {
    private Field field = new Field();
    private MiningMachine miningMachine = new MiningMachine();

    public String goTo(String goCommandString) {
        int index = goCommandString.lastIndexOf(',');
        int numberOfSteps = Integer.valueOf(String.valueOf(goCommandString.charAt(index + 1)));
        if (numberOfSteps > 0) {
            if (goCommandString.contains(""no"")) {
                miningMachine.moveNorth(field, numberOfSteps);
            }
            if (goCommandString.contains(""ea"")) {
                miningMachine.moveEast(field, numberOfSteps);
            }
            if (goCommandString.contains(""so"")) {
                miningMachine.moveSouth(field, numberOfSteps);
            }
            if (goCommandString.contains(""we"")) {
                miningMachine.moveWest(field, numberOfSteps);
            }
        }
        return ""(""+miningMachine.getxPos()+"",""+miningMachine.getyPos()+"")"";
    }
}

package thkoeln.st.st2praktikum.exercise;

import java.util.Vector;

public class MiningMachine implements Moveable{
    private int xPos;
    private int yPos;

    public int getxPos() {
        return xPos;
    }

    public void setxPos(int xPos) {
        this.xPos = xPos;
    }

    public int getyPos() {
        return yPos;
    }

    public void setyPos(int yPos) {
        this.yPos = yPos;
    }
    public MiningMachine()
    {
        xPos=0;
        yPos=2;
    }
    public void moveNorth(Field field, int numberOfSteps)
    {
        Vector<Obstacle> obstacles = field.getObstacles();
        for(int i=0;i<numberOfSteps;i++)
        {
            boolean moveBlocked = false;
            for(int obstIndex=0;obstIndex<obstacles.size();obstIndex++)
            {
                Obstacle obstacle = obstacles.elementAt(obstIndex);
                if(obstacle.startP.y == obstacle.endP.y && obstacle.startP.x <= xPos && obstacle.endP.x > xPos && obstacle.startP.y == yPos + 1)
                {
                    moveBlocked = true;
                }
            }
            if(!moveBlocked)
            {
                yPos++;
            }
        }
    }
    public void moveEast(Field field, int numberOfSteps)
    {
        Vector<Obstacle> obstacles = field.getObstacles();
        for(int i=0;i<numberOfSteps;i++)
        {
            boolean moveBlocked = false;
            for(int obstIndex=0;obstIndex<obstacles.size();obstIndex++)
            {
                Obstacle obstacle = obstacles.elementAt(obstIndex);
                if(obstacle.startP.x == obstacle.endP.x && obstacle.startP.y <= yPos && obstacle.endP.y > yPos && obstacle.startP.x - 1 == xPos)
                {
                    moveBlocked = true;
                }
            }
            if(!moveBlocked)
            {
                xPos++;
            }
        }
    }
    public void moveSouth(Field field, int numberOfSteps)
    {
        Vector<Obstacle> obstacles = field.getObstacles();
        for(int i=0;i<numberOfSteps;i++)
        {
            boolean moveBlocked = false;
            for(int obstIndex=0;obstIndex<obstacles.size();obstIndex++)
            {
                Obstacle obstacle = obstacles.elementAt(obstIndex);
                if(obstacle.startP.y == obstacle.endP.y && obstacle.startP.x <= xPos && obstacle.endP.x > xPos && obstacle.startP.y == yPos)
                {
                    moveBlocked = true;
                }
            }
            if(!moveBlocked)
            {
                yPos--;
            }
        }
    }
    public void moveWest(Field field, int numberOfSteps)
    {
        Vector<Obstacle> obstacles = field.getObstacles();
        for(int i=0;i<numberOfSteps;i++)
        {
            boolean moveBlocked = false;
            for(int obstIndex=0;obstIndex<obstacles.size();obstIndex++)
            {
                Obstacle obstacle = obstacles.elementAt(obstIndex);
                if(obstacle.startP.x == obstacle.endP.x && obstacle.startP.y <= yPos && obstacle.endP.y > yPos && obstacle.startP.x == xPos)
                {
                    moveBlocked = true;
                }
            }
            if(!moveBlocked)
            {
                xPos--;
            }
        }
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    public void moveNorth(Field field, int numberOfSteps);
    public void moveEast(Field field, int numberOfSteps);
    public void moveSouth(Field field, int numberOfSteps);
    public void moveWest(Field field, int numberOfSteps);
}

package thkoeln.st.st2praktikum.exercise;

public class Obstacle {
    public Vector2d startP;
    public Vector2d endP;
    public Obstacle(Vector2d startP, Vector2d endP)
    {
        this.startP=startP;
        this.endP=endP;
    }
}

package thkoeln.st.st2praktikum.exercise;

public class Vector2d {
    int x,y;
    public Vector2d(int x, int y)
    {
        this.x=x;
        this.y=y;
    }
}
",6366,216,32.53968253968254,144,0.0,0.06018518518518518,0.037037037037037035,0.0,0.37962962962962965,0.0,0.125,0.0,True,False,False,False,False,False,8,0.0787037037037037,0.046296296296296294,0.06481481481481481,0.027777777777777776,0.4583333333333333,0.16203703703703703,0.013888888888888888,6.0588235294117645,15,0.0,0
student66,student,,,"package thkoeln.st.st2praktikum.exercise;

import lombok.Getter;

@Getter
public class Command {
    private String direction;
    private int steps;

    public Command(String commandString){
        String[] commandStringArray = commandString.split("","");
        direction = commandStringArray[0].substring(1);
        steps = Integer.parseInt(commandStringArray[1].substring(0, commandStringArray[1].length()-1));
    }
}

package thkoeln.st.st2praktikum.exercise;

import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@EqualsAndHashCode
public class Coordinate {
    private int x;
    private int y;

    public Coordinate(int x, int y){
        this.x = x;
        this.y = y;
    }

    @Override
    public String toString(){
        return ""("" + x + "","" + y + "")"";
    }
}

package thkoeln.st.st2praktikum.exercise;


public class Exercise0 implements GoAble {

    private Room room;
    private Robot robot;

    public Exercise0(){
        room = new Room(12,9);
        room.addWall(new Wall(new Coordinate(4,1), new Coordinate(4,7)));
        room.addWall(new Wall(new Coordinate(6,2), new Coordinate(6,5)));
        room.addWall(new Wall(new Coordinate(6,2), new Coordinate(9,2)));
        room.addWall(new Wall(new Coordinate(6,5), new Coordinate(9,5)));
        robot = new Robot(new Coordinate(8,3));
    }


    @Override
    public String go(String goCommandString) {
        Command command = new Command(goCommandString);
        for(int i=0; i<command.getSteps(); i++) {
            Coordinate newCoordinate = new Coordinate(robot.getPosition().getX(), robot.getPosition().getY());
            switch (command.getDirection()) {
                case (""no""):
                    newCoordinate.setY(robot.getPosition().getY() + 1);
                    break;
                case (""so""):
                    newCoordinate.setY(newCoordinate.getY() - 1);
                    break;
                case (""ea""):
                    newCoordinate.setX(robot.getPosition().getX() + 1);
                    break;
                case (""we""):
                    newCoordinate.setX(robot.getPosition().getX() - 1);
                    break;
            }
            if (!robotHitsWall(command.getDirection(), newCoordinate) && robotStaysInRoom(newCoordinate)) {
                robot.move(command.getDirection());
            } else {
                break;
            }
        }
        return robot.getPosition().toString();
    }

    private boolean robotHitsWall(String direction, Coordinate newRobotPosition){
        switch (direction) {
            case(""no""):
                for(Wall wall : room.getHorizontallyWalls()){
                    if(wall.getWholeWall().contains(newRobotPosition) && !wall.getTo().equals(newRobotPosition)){
                        return true;
                    }
                }
                break;
            case(""so""):
                for(Wall wall : room.getHorizontallyWalls()){
                    if(wall.getWholeWall().contains(robot.getPosition()) && !wall.getTo().equals(robot.getPosition())){
                        return true;
                    }
                }
                break;
            case(""ea""):
                for(Wall wall : room.getVerticallyWalls()){
                    if(wall.getWholeWall().contains(newRobotPosition) && !wall.getTo().equals(newRobotPosition)){
                        return true;
                    }
                }
                break;
            case(""we""):
                for(Wall wall : room.getVerticallyWalls()){
                    if(wall.getWholeWall().contains(robot.getPosition()) && !wall.getTo().equals(robot.getPosition())){
                        return true;
                    }
                }
                break;
        }
        return false;
    }

    private boolean robotStaysInRoom(Coordinate newCoordinate){
        return newCoordinate.getX() >= 0 && newCoordinate.getX() < room.getLength() &&
                newCoordinate.getY() >= 0 && newCoordinate.getY() < room.getWidth();
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String go(String goCommandString);
}

package thkoeln.st.st2praktikum.exercise;

import lombok.Getter;

@Getter
public class Robot {
    private Coordinate position;

    public Robot(Coordinate position){
        this.position = position;
    }

    public void move(String direction){
        switch (direction){
            case ""no"":
                position.setY(position.getY()+1);
                break;
            case ""so"":
                position.setY(position.getY()-1);
                break;
            case ""we"":
                position.setX(position.getX()-1);
                break;
            case ""ea"":
                position.setX(position.getX()+1);
                break;
        }
    }
}

package thkoeln.st.st2praktikum.exercise;

import lombok.Getter;

import java.util.HashSet;
import java.util.Set;

@Getter
public class Room {
    private int length;
    private int width;
    private Set<Wall> verticallyWalls = new HashSet<>();
    private Set<Wall> horizontallyWalls = new HashSet<>();

    public Room(int length, int width){
        this.length = length;
        this.width = width;
    }

    public void addWall(Wall wall){
        if(wallIsInsideRoom(wall)){
            if(wall.getFrom().getX() == wall.getTo().getX()){
                verticallyWalls.add(wall);
            }else
                if(wall.getFrom().getY() == wall.getTo().getY()){
                    horizontallyWalls.add(wall);
                }
        }
    }

    private boolean wallIsInsideRoom(Wall wall){
        return wall.getTo().getX() >= 0 && wall.getFrom().getX() >= 0 && wall.getTo().getY() >= 0 && wall.getFrom().getY() >= 0 &&
                wall.getTo().getX() <= length && wall.getFrom().getX() <= length && wall.getTo().getY() <= width && wall.getFrom().getY() <= width;
    }
}

package thkoeln.st.st2praktikum.exercise;

import lombok.Getter;

import java.util.HashSet;
import java.util.Set;

@Getter
public class Wall {
    private Coordinate from;
    private Coordinate to;
    private Set<Coordinate> wholeWall = new HashSet<>();

    public Wall(Coordinate from, Coordinate to) {
        this.from = from;
        this.to = to;
        createWall();
    }

    private void createWall(){
        if(from.getX() > to.getX()){
            for(int i=0; i<=from.getX()-to.getX(); i++){
                wholeWall.add(new Coordinate(to.getX()+i, from.getY()));
            }
        }else
            if(from.getX() < to.getX()){
                for(int i=0; i<=to.getX()-from.getX(); i++){
                    wholeWall.add(new Coordinate(from.getX()+i, from.getY()));
                }
            }else
                if(from.getY() >= to.getY()){
                    for(int i=0; i<from.getY()-to.getY(); i++){
                        wholeWall.add(new Coordinate(to.getX(), to.getY()+i));
                    }
                }else
                    if(from.getY() < to.getY()) {
                        for (int i = 0; i <= to.getY() - from.getY(); i++) {
                            wholeWall.add(new Coordinate(from.getX(), from.getY()+i));
                        }
                    }
    }

    @Override
    public String toString(){
        return from.toString().concat(""-"".concat(to.toString()));
    }
}
",7429,245,34.70531400966183,147,0.0,0.04897959183673469,0.036734693877551024,0.012244897959183673,0.22448979591836735,0.0,0.1469387755102041,0.0,False,False,False,False,False,False,7,0.04081632653061224,0.05714285714285714,0.012244897959183673,0.024489795918367346,0.2163265306122449,0.5346938775510204,0.044897959183673466,6.8,18,0.0,0
student68,student,,,"package thkoeln.st.st2praktikum.exercise;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class Barrier {
    private Integer xStart;
    private Integer yStart;
    private Integer xEnd;
    private Integer yEnd;

    public Barrier (Integer xStart,Integer yStart, Integer xEnd, Integer yEnd){
        this.xStart=xStart;
        this.yStart=yStart;
        this.xEnd=xEnd;
        this.yEnd=yEnd;
    }

}

package thkoeln.st.st2praktikum.exercise;

public enum Direction {
    NORTH,EAST,SOUTH,WEST;
}

package thkoeln.st.st2praktikum.exercise;


import org.springframework.data.util.Pair;

import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Exercise0 implements Walkable {

    //    private Robot robot = new Robot(7,7,new Map(11,8, new ArrayList<Barrier>(Arrays.asList(
    //                new Barrier(2,6,7,6),    // Horizontal
    //                new Barrier(2,1,10,1),   // Horizontal
    //                new Barrier(2,1,2,6),    // Vertikal
    //                new Barrier(10,1,10,8)   // Vertikal
    //            ))));

    // ================================= INITIALISIERUNG DES ROBOTER + MAP + BARRIEREN =================================
    private Robot robot = new Robot(7,7,new Map(11,8, Arrays.asList(
            new Barrier(2,6,7,6),    // Horizontal
            new Barrier(2,1,10,1),   // Horizontal
            new Barrier(2,1,2,6),    // Vertikal
            new Barrier(10,1,10,8)   // Vertikal
        )));


    @Override
    public String walk(String walkCommandString) {
        return robot.moveRobot(walkCommandString);
    }

}

package thkoeln.st.st2praktikum.exercise;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

import java.util.ArrayList;
import java.util.List;

@Getter
@Setter
@AllArgsConstructor
public class Map {
    private Integer xSize;
    private Integer ySize;
    private List<Barrier> barriers;


//    public Map (Integer xSize,Integer ySize, List<Barrier> barriers) {
//        this.xSize = xSize;
//        this.ySize = ySize;
//        this.barriers = barriers;
//    }

}

package thkoeln.st.st2praktikum.exercise;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.util.Pair;

import java.util.ArrayList;
import java.util.List;


@Getter
@Setter
@AllArgsConstructor
public class Robot {
    private Integer robotPosX;
    private Integer robotPosY;
    private Map myMap;


    // #################################################################################################################
    // ################################################### MOVE ROBOT ##################################################
    // #################################################################################################################
    public String moveRobot(String command) {
        Pair<Direction,Integer> move = parseCommand(command);                           // Kommando analysieren in Form von einem Pair  bsp. Pair(NORTH,2)
        Integer stopPoint;
        // =============================================================================================================
        // ========================================== MOVE TO NORTH ====================================================
        // =============================================================================================================
        if (move.getFirst() == Direction.NORTH) {
            // Setzen des vorläufigen StopPoint
            stopPoint = Math.min(robotPosY + move.getSecond(), myMap.getYSize() - 1);  // StopPoint ist MapGrenze ODER robotPosY + Bewegung

            // Alle Barrieren checken
            for (Barrier barrier : myMap.getBarriers()) {
                if (barrier.getYStart() == barrier.getYEnd()                            // Wenn horizontale Barriere
                        && barrier.getYStart() > robotPosY                              // & Barriere liegt im nördlichen Bereich
                        && barrier.getXStart() <= robotPosX                             // & Barriere liegt auf gleicher X-Koordinate wie der Roboter
                        && barrier.getXEnd() > robotPosX                                // & Barriere liegt auf gleicher X-Koordinate wie der Roboter
                        && barrier.getYStart() <= stopPoint)                            // & Barriere Schränkt Bewegung ein bzw. ist vorläufiger/vorheriger StopPoint ist weiter entfernt
                    stopPoint = barrier.getYStart()-1;                                  // => Setzt neuen StopPoint
                }

            robotPosY = stopPoint;                                                       // Setzen der neuen Y-Position des Roboters
        }

        // =============================================================================================================
        // ========================================== MOVE TO SOUTH ====================================================
        // =============================================================================================================
        if (move.getFirst() == Direction.SOUTH) {
            // Setzen des vorläufigen StopPoint
            stopPoint = Math.max(robotPosY - move.getSecond(), 0);                      // StopPoint ist MapGrenze ODER robotPosY - Bewegung

            // Alle Barrieren checken
            for (Barrier barrier : myMap.getBarriers()) {
                if (barrier.getYStart() == barrier.getYEnd()                            // Wenn horizontale Barriere
                        && barrier.getYStart() <= robotPosY                              // & Barriere liegt im südlichen Bereich
                        && barrier.getXStart() <= robotPosX                             // & Barriere liegt auf gleicher X-Koordinate wie der Roboter
                        && barrier.getXEnd() > robotPosX                                // & Barriere liegt auf gleicher X-Koordinate wie der Roboter
                        && barrier.getYStart() > stopPoint)                             // & Barriere Schränkt Bewegung ein bzw. vorläufiger/vorheriger StopPoint ist weiter entfernt
                    stopPoint = barrier.getYStart();                                    // => Setzt neuen StopPoint
                }

            robotPosY = stopPoint;                                                       // Setzen der neuen Y-Position des Roboters
        }

        // =============================================================================================================
        // =========================================== MOVE TO WEST ====================================================
        // =============================================================================================================
        if (move.getFirst() == Direction.WEST) {
            // Setzen des vorläufigen StopPoint
            stopPoint = Math.max(robotPosX - move.getSecond(), 0);                      // StopPoint ist MapGrenze ODER robotPosX - Bewegung

            // Alle Barrieren checken
            for (Barrier barrier : myMap.getBarriers()) {
                if (barrier.getXStart() == barrier.getXEnd()                            // Wenn vertikale Barriere
                        && barrier.getXStart() <= robotPosX                              // & Barriere liegt im östlichen Bereich
                        && barrier.getYStart() <= robotPosY                             // & Barriere liegt auf gleicher Y-Koordinate wie der Roboter
                        && barrier.getYEnd() > robotPosY                                // & Barriere liegt auf gleicher Y-Koordinate wie der Roboter
                        && barrier.getXStart() > stopPoint)                             // & Barriere Schränkt Bewegung ein bzw. vorläufiger/vorheriger StopPoint ist weiter entfernt
                    stopPoint = barrier.getXStart();                                    // => Setzt neuen StopPoint
                }

            robotPosX = stopPoint;                                                      // Setzen der neuen X-Position des Roboters
        }

        // =============================================================================================================
        // =========================================== MOVE TO EAST ====================================================
        // =============================================================================================================
        if (move.getFirst() == Direction.EAST) {
            // Setzen des vorläufigen StopPoint
            stopPoint = Math.min(robotPosX + move.getSecond(), myMap.getXSize() - 1);  // StopPoint ist MapGrenze ODER robotPosX - Bewegung

            // Alle Barrieren checken
            for (Barrier barrier : myMap.getBarriers()) {
                if (barrier.getXStart() == barrier.getXEnd()                            // Wenn vertikale Barriere
                        && barrier.getXStart() > robotPosX                              // & Barriere liegt im östlichen Bereich
                        && barrier.getYStart() <= robotPosY                             // & Barriere liegt auf gleicher Y-Koordinate wie der Roboter
                        && barrier.getYEnd() > robotPosY                                // & Barriere liegt auf gleicher Y-Koordinate wie der Roboter
                        && barrier.getXStart() <= stopPoint)                             // & Barriere Schränkt Bewegung ein bzw. vorläufiger/vorheriger StopPoint ist weiter entfernt
                    stopPoint = barrier.getXStart()-1;                                  // => Setzt neuen StopPoint
                }
            robotPosX = stopPoint;                                                      // Setzen der neuen X-Position des Roboters
        }

        System.out.println(""Position: (""+robotPosX+"",""+robotPosY+"")"");
        return ParsePosition(robotPosX,robotPosY);
    }



    // #################################################################################################################
    // ################################################## PARSE COMMAND ################################################
    // #################################################################################################################
    static public Pair<Direction,Integer> parseCommand (String command){
        String direction = command.substring(command.indexOf(""["")+1,command.indexOf("",""));
        Integer cells = Integer.parseInt(command.substring(command.indexOf("","")+1,command.indexOf(""]"")));
        //System.out.println(""Direction: ""  + direction + ""     cells: "" + cells);

        if (direction.equals(""no""))
            return Pair.of(Direction.NORTH,cells);

        if (direction.equals(""so""))
            return Pair.of(Direction.SOUTH,cells);

        if (direction.equals(""ea""))
            return Pair.of(Direction.EAST,cells);

        if (direction.equals(""we""))
            return Pair.of(Direction.WEST,cells);

        throw new IllegalArgumentException(""Illegal command: ""+command);
    }



    // #################################################################################################################
    // ################################################## PARSE POSITION ###############################################
    // #################################################################################################################
    static public String ParsePosition (Integer posX, Integer posY){
        return ""("" + posX + "",""+ posY + "")"";
    }




}

package thkoeln.st.st2praktikum.exercise;

public class Test {

    public static void main(String[] args) {
        stringMe(""[no,4]"");
    }

    public static void stringMe(String command) {
        //String direction = command.substring(command.indexOf(""["")+1,command.indexOf("","")-1);
        //Integer cells = Integer.parseInt(command.substring(command.indexOf("","")+1,command.indexOf(""]"")-1));
        //System.out.println(""Direction: ""  + direction + ""     cells: "" + cells);

        System.out.println(command.indexOf(""["")+1);
        System.out.println(command.substring(command.indexOf(""["")+1,command.indexOf("","")));
        System.out.println(command.substring(command.indexOf("","")+1,command.indexOf(""]"")));
    }

}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",12555,262,62.08585858585859,185,0.3282442748091603,0.04580152671755725,0.015267175572519083,0.0,0.2786259541984733,0.003816793893129771,0.2099236641221374,0.022900763358778626,False,True,True,False,False,False,7,0.026717557251908396,0.04198473282442748,0.015267175572519083,0.019083969465648856,0.2480916030534351,0.29389312977099236,0.06870229007633588,6.375,17,60.670731707317074,113
student69,student,,,"package thkoeln.st.st2praktikum.exercise;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Exercise0 implements Moveable {

    List<String> tmp = new ArrayList<>();

    int x = 0;
    int y = 2;

    @Override
    public String move(String moveCommandString) {
        tmp.clear();
        String[] random = moveCommandString.split("","");

        String richtung = random[0].replace(""["", """");
        int anzahl = Integer.parseInt(random[1].replace(""]"", """"));

        List<String> HORIZONTAL = new ArrayList<>(Arrays.asList(""(3,0)"", ""(3,1)"", ""(3,2)"", ""(5,0)"", ""(5,1)"", ""(5,2)"", ""(5,3)"",
                ""(7,5)"", ""(7,6)"", ""(7,7)"", ""(7,8)""));
        List<String> VERTIKAL = new ArrayList<>(Arrays.asList(""(4,5)"", ""(5,5)"", ""(6,5)""));

        switch (richtung) {
            case ""no"":
                norden(VERTIKAL, anzahl);
                break;
            case ""so"":
                süden(VERTIKAL, anzahl);
                break;
            case ""ea"":
                osten(HORIZONTAL, anzahl);
                break;
            case ""we"":
                westen(HORIZONTAL, anzahl);
                break;
        }
        System.out.println(moveCommandString);
        System.out.println(""("" + x + "","" + y + "")"");
        return ""("" + x + "","" + y + "")"";
    }

    private void westen(List<String> HORIZONTAL, int anzahl) {
        /*
        Potentielle Wände raussuchen
         */
        for (int i = 0; i < HORIZONTAL.size(); i++) {
            String temporaer = HORIZONTAL.get(i); // -> (0,3)
            String[] abc = temporaer.split("",""); // -> String bei ',' aufteilen -> [""(0"", ""3)""]
            String def = abc[1].replace("")"", """"); // -> Index 1 aus Array und Klammer entfernen -> ""3""

            if (Integer.parseInt(def) == y && // schauen ob potentielle wand selbe Höhe ist
                    Integer.parseInt(abc[0].replace(""("", """")) <= x && // schauen ob x von potentieller Wand kleiner gleich als aktuelles x ist
                    (x - anzahl) < Integer.parseInt(abc[0].replace(""("", """"))) {  // schauen ob neue position größer als x von potentieller Wand ist
                tmp.add(temporaer); //Falls Bedingungen zutreffen, füge die Wand der Temporären Liste hinzu
            }
        }
        if (tmp.size() == 0) { // falls keine Wände gefunden wurden -> Neue position kann ohne Probleme gesetzt werden
            x = x - anzahl;
        } else {
            // Liste mit den Potentiellen Wänden durchgehen und die größte X Koordinate davon finden
            int max = Integer.parseInt(tmp.get(0).split("","")[0].replace(""("", """")); // Beispiel -> (""0,3"") -> 3
            for (int i = 0; i < tmp.size(); i++) {
                if (max < Integer.parseInt(tmp.get(i).split("","")[0].replace(""("", """"))) {
                    max = Integer.parseInt(tmp.get(i).split("","")[0].replace(""("", """"));
                }
            }
            x = max; // x = Der Koordinate der Wand setzen (Da man da stoppt)
        }
        if (x < 0) {
            x = 0;
        }
    }

    private void osten(List<String> HORIZONTAL, int anzahl) {
        /*
        Potentielle Wände raussuchen
         */
        for (int i = 0; i < HORIZONTAL.size(); i++) {
            String temporaer = HORIZONTAL.get(i); // -> (0,3)
            String[] abc = temporaer.split("",""); // -> String bei ',' aufteilen -> [""(0"", ""3)""]
            String def = abc[1].replace("")"", """"); // -> Index 1 aus Array und Klammer entfernen -> ""3""

            if (Integer.parseInt(def) == y && // schauen ob potentielle wand selbe Höhe ist
                    Integer.parseInt(abc[0].replace(""("", """")) > x && // schauen ob x von potentieller Wand kleiner gleich als aktuelles x ist
                    (x + anzahl) >= Integer.parseInt(abc[0].replace(""("", """"))) {  // schauen ob neue position größer als x von potentieller Wand ist
                tmp.add(temporaer); //Falls Bedingungen zutreffen, füge die Wand der Temporären Liste hinzu
            }
        }
        if (tmp.size() == 0) { // falls keine Wände gefunden wurden -> Neue position kann ohne Probleme gesetzt werden
            x = x + anzahl;
        } else {
            // Liste mit den Potentiellen Wänden durchgehen und die größte X Koordinate davon finden
            int max = Integer.parseInt(tmp.get(0).split("","")[0].replace(""("", """")); // Beispiel -> (""0,3"") -> 3
            for (int i = 0; i < tmp.size(); i++) {
                if (max > Integer.parseInt(tmp.get(i).split("","")[0].replace(""("", """"))) {
                    max = Integer.parseInt(tmp.get(i).split("","")[0].replace(""("", """"));
                }
            }
            x = max - 1; // x = Der Koordinate der Wand setzen (Da man da stoppt)
        }
        if (x > 12 - 1) {
            x = 12 - 1;
        }
    }


    private void süden(List<String> VERTIKAL, int anzahl) {
        for (int i = 0; i < VERTIKAL.size(); i++) {
            String temporaer = VERTIKAL.get(i); // -> (0,3)
            String[] abc = temporaer.split("",""); // -> String bei ',' aufteilen -> [""(0"", ""3)""]
            String def = abc[0].replace(""("", """"); // -> Index 1 aus Array und Klammer entfernen -> ""3""

            if (Integer.parseInt(def) == x && // schauen ob potentielle wand selbe Höhe ist
                    Integer.parseInt(abc[1].replace("")"", """")) <= y && // schauen ob x von potentieller Wand kleiner gleich als aktuelles x ist
                    (y - anzahl) < Integer.parseInt(abc[1].replace("")"", """"))) {  // schauen ob neue position größer als x von potentieller Wand ist
                tmp.add(temporaer); //Falls Bedingungen zutreffen, füge die Wand der Temporären Liste hinzu
            }
        }
        if (tmp.size() == 0) { // falls keine Wände gefunden wurden -> Neue position kann ohne Probleme gesetzt werden
            y = y - anzahl;
        } else {
            // Liste mit den Potentiellen Wänden durchgehen und die größte X Koordinate davon finden
            int max = Integer.parseInt(tmp.get(1).split("","")[1].replace("")"", """")); // Beispiel -> (""0,3"") -> 3
            for (int i = 0; i < tmp.size(); i++) {
                if (max > Integer.parseInt(tmp.get(i).split("","")[1].replace("")"", """"))) {
                    max = Integer.parseInt(tmp.get(i).split("","")[1].replace("")"", """"));
                }
            }
            y = max; // x = Der Koordinate der Wand setzen (Da man da stoppt)
        }
        if (y < 0) {
            y = 0;
        }
        System.out.println(y);

    }

    private void norden(List<String> VERTIKAL, int anzahl) {


        for (int i = 0; i < VERTIKAL.size(); i++) {
            String temporaer = VERTIKAL.get(i); // -> (0,3)
            String[] abc = temporaer.split("",""); // -> String bei ',' aufteilen -> [""(0"", ""3)""]
            String def = abc[0].replace(""("", """"); // -> Index 1 aus Array und Klammer entfernen -> ""3""

            if (Integer.parseInt(def) == x && // schauen ob potentielle wand selbe Höhe ist
                    Integer.parseInt(abc[1].replace("")"", """")) > y && // schauen ob x von potentieller Wand kleiner gleich als aktuelles x ist
                    (y + anzahl) >= Integer.parseInt(abc[1].replace("")"", """"))) {  // schauen ob neue position größer als x von potentieller Wand ist
                tmp.add(temporaer); //Falls Bedingungen zutreffen, füge die Wand der Temporären Liste hinzu
            }
        }
        if (tmp.size() == 0) { // falls keine Wände gefunden wurden -> Neue position kann ohne Probleme gesetzt werden
            y = y + anzahl;
        } else {
            // Liste mit den Potentiellen Wänden durchgehen und die größte X Koordinate davon finden
            int max = Integer.parseInt(tmp.get(1).split("","")[1].replace("")"", """")); // Beispiel -> (""0,3"") -> 3
            for (int i = 0; i < tmp.size(); i++) {
                if (max > Integer.parseInt(tmp.get(i).split("","")[1].replace("")"", """"))) {
                    max = Integer.parseInt(tmp.get(i).split("","")[1].replace("")"", """"));
                }
            }
            y = max - 1; // x = Der Koordinate der Wand setzen (Da man da stoppt)
        }
        if (y > 9 - 1) {
            y = 9 - 1;
        }

    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String move(String moveCommandString);
}
",8299,178,52.39354838709677,148,0.25842696629213485,0.0898876404494382,0.0449438202247191,0.0056179775280898875,0.7134831460674157,0.0,0.11797752808988764,0.016853932584269662,False,True,False,False,False,False,2,0.033707865168539325,0.016853932584269662,0.11797752808988764,0.0056179775280898875,0.6573033707865169,0.6179775280898876,0.016853932584269662,5.846153846153846,17,52.43478260869565,85
student7,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Moveable {
    int[] limit = new int[]{12,9};
    int[] robot = {8, 3};
    int[][] walls = {{4, 1, 4, 7}, {6, 2, 6, 5}, {6, 2, 9, 2} ,{6, 5, 9, 5}};

    @Override
    public String move(String moveCommandString) {
        String result = result = ""(""+robot[0]+"",""+robot[1]+"")"";
        String[] command = moveCommandString.substring(1,moveCommandString.length()-1).split("","");
        int[]movement;
        switch (command[0]){    //direction
            case ""no"":
                movement = new int[]{0, 1};
                break;
            case ""ea"":
                movement = new int[]{1, 0};
                break;
            case ""so"":
                movement = new int[]{0, -1};
                break;
            case ""we"":
                movement = new int[]{-1, 0};
                break;
            default:
                return result;
        }
        for (int i = 0; i < Integer.parseInt(command[1]); i++){ //walls
            if(movement[1] == 1){
                int dest = robot [1] + movement[1];
                for (int[] elem: walls) {
                    if(elem[1] == elem[3] && elem[3]  == dest
                            && robot[0] >= elem[0] && robot[0] < elem[2]){
                        return result;
                    }
                }
            }if(movement[1] == -1){
                for (int[] elem: walls) {
                    if(elem[1] == elem[3] && elem[3]  == robot[1]
                            && robot[0] >= elem[0] && robot[0] < elem[2]){
                        return result;
                    }
                }
            }if(movement[0] == 1){
                int dest = robot [0] + movement[0];
                for (int[] elem: walls) {
                    if(elem[0] == elem[2] && elem[2]  == dest
                            && robot[1] >= elem[1] && robot[1] < elem[3]){
                        return result;
                    }
                }
            }if(movement[0] == -1){
                for (int[] elem: walls) {
                    if(elem[0] == elem[2] && elem[2]  == robot[0]
                            && robot[1] >= elem[1] && robot[1] < elem[3]){
                        return result;
                    }
                }
            }
            if(robot[0] + movement[0] < 0 || robot[0] + movement[0] > limit[0]-1 || robot[1] + movement[1] < 0 || robot[1] + movement[1] > limit[1]-1)
                return result;  //boundary
            robot[0] += movement[0];
            robot[1] += movement[1];
            result = ""(""+robot[0]+"",""+robot[1]+"")"";
        }
        return result;
    }
}


package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String move(String moveCommandString);
}
",2797,76,38.32394366197183,150,0.039473684210526314,0.11842105263157894,0.06578947368421052,0.013157894736842105,1.3289473684210527,0.0,0.05263157894736842,0.0,False,False,False,False,False,False,2,0.02631578947368421,0.039473684210526314,0.06578947368421052,0.013157894736842105,1.0394736842105263,0.05263157894736842,0.0,5.0,8,7.333333333333333,9
student70,student,,,"package thkoeln.st.st2praktikum.exercise;

import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

public class Exercise0 implements Walkable {

    @Override
    public String walk(String walkCommandString) {
        String command[]=walkCommandString.replace(""["","""")
                .replace(""]"","""").split("","");
        String dir=command[0];
        int move =Integer.parseInt(command[1]);



        startmove(dir,move);
        return dvice.toString();
    }


    Point dvice;
    int max_x = 10, max_y = 7;
    List<Wall> wallList = new ArrayList<>();

    public Exercise0() {
        dvice = new Point(7, 7);

        Point wallpoint1 = new Point(10, 8);
        Point wallpoint2 = new Point(10, 1);
        Point wallpoint3 = new Point(2, 1);
        Point wallpoint4 = new Point(2, 6);
        Point wallpoint5 = new Point(7, 6);
        wallList.add(new Wall(wallpoint2, wallpoint1));
        wallList.add(new Wall(wallpoint3, wallpoint2));
        wallList.add(new Wall(wallpoint3, wallpoint4));
        wallList.add(new Wall(wallpoint4, wallpoint5));

    }

    String startmove(String dir,int movment) {

        switch (dir) {
            case ""no"":
                vertical(movment, 1);
                break;
            case ""so"":vertical(movment, -1);
                break;
            case ""ea"":horizontally(movment,1);
                break;
            case ""we"":horizontally(movment,-1);
                break;
        }
        return """";
    }

    private void horizontally (int movment, int dr) {
        int correct=0;if(dr>0)correct=1;

        for (int i = 1; i <= movment; i++) {
            boolean move = true;
            // check if dvice rich the end of map
            if (dvice.x + dr <= max_x && dvice.x + dr >= 0) {
                for (Wall wall : wallList) {
                    // check if wall vertically
                    if (wall.getStart().getX() == wall.getEnd().getX()) {
                        if (dvice.getX()+correct == wall.getStart().getX() && dvice.getY() >= wall.getStart().getY() && dvice.getY() < wall.getEnd().getY()) {
                            move = false;
                            break;
                        }
                    }


                }
            }else move = false;
            if (move) dvice.setX(dvice.getX()+dr);
            else break;

        }


    }



    private void vertical(int movment, int dr) {
        int correct=0;if(dr>0)correct=1;
        for (int i = 1; i <= movment; i++) {
            boolean move = true;
            // check if dvice rich the end of map
            if (dvice.y + dr <= max_y && dvice.y + dr >= 0) {
                for (Wall wall : wallList) {
                    // check if wall horizontally
                    if (wall.getStart().getY() == wall.getEnd().getY()) {
                        if (dvice.getY()+correct == wall.getStart().getY() && dvice.getX() >= wall.getStart().getX() && dvice.getX() < wall.getEnd().getX()) {
                            move = false;
                            break;
                        }
                    }


                }
            } else move = false;
            if (move) dvice.setY(dvice.getY()+dr);
            else break;

        }


    }


}

package thkoeln.st.st2praktikum.exercise;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
@AllArgsConstructor
@NoArgsConstructor
public class Point {

    @Setter
    @Getter
    int x,y;




    @Override
    public String toString() {
        return ""("" + x +"","" + y +')';
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}

package thkoeln.st.st2praktikum.exercise;


import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@NoArgsConstructor
public class Wall {

    @Setter
    @Getter
    Point start,end;

}
",3994,161,33.043103448275865,158,0.024844720496894408,0.08695652173913043,0.024844720496894408,0.006211180124223602,0.32298136645962733,0.0,0.2111801242236025,0.0,True,True,False,True,False,False,4,0.037267080745341616,0.049689440993788817,0.07453416149068323,0.018633540372670808,0.32298136645962733,0.2732919254658385,0.06832298136645963,5.4,10,29.5,34
student71,student,,,"package thkoeln.st.st2praktikum.exercise;

import org.springframework.data.util.Pair;

import java.util.*;

public class Exercise0 implements GoAble {

    private enum rotation{
        North,
        west,
        south,
        east
    }

    private class obstacle{
        public int x1,x2;
        public int y1,y2;

        public obstacle(int x1,int y1,int x2,int y2){
            this.x1 = x1;
            this.x2 = x2;
            this.y1 = y1;
            this.y2 = y2;
        }
    }

    private class Map{
        public ArrayList<obstacle> obstacles = new ArrayList();
        
        public int sizeX = 11;
        public int sizeY = 8;
        
        public Map(){
            obstacles.add(new obstacle(4,1,4,6));
            obstacles.add(new obstacle(6,2,8,2));
            obstacles.add(new obstacle(6,5,8,5));
            obstacles.add(new obstacle(6,2,6,4));
        }
    }

    private int positionX = 8;
    private int positionY = 3;

    @Override
    public String go(String goCommandString) {

        if(goCommandString.toCharArray()[0] != '[' || goCommandString.toCharArray()[goCommandString.length()-1] != ']')
            return null;

        var rawString = goCommandString.substring(1,goCommandString.length()-1);

        var rawRotation = rawString.split("","")[0];
        var rawLength = rawString.split("","")[1];

        rotation tempRotation;
        Integer tempLength = Integer.parseInt(rawLength);
        Map map = new Map();

        
        switch(rawRotation) {
            case ""no"":
                tempRotation = rotation.North;
                break;
            case ""ea"":
                tempRotation = rotation.east;
                break;
            case ""so"":
                tempRotation = rotation.south;
                break;
            case ""we"":
                tempRotation = rotation.west;
                break;
            default:
                throw new IllegalStateException(""Unexpected value: "" + rawRotation);
        }

        switch (tempRotation) {
            case south:
                for (int i = 0; i < tempLength; i++) {
                    for (var obstacle: map.obstacles ) {

                        if(obstacle.x1 == obstacle.x2)
                            continue;

                        if(!(positionX >= obstacle.x1 && positionX <= obstacle.x2))
                            continue;

                        if(positionY == obstacle.y1)
                            return String.format(""(%d,%d)"",positionX,positionY);
                    }
                    positionY--;

                    if(positionY == 0)
                        return String.format(""(%d,%d)"",positionX,positionY);
                }
                break;
            case North:

                for (int i = 0; i < tempLength; i++) {
                    for (var obstacle: map.obstacles ) {

                        if(obstacle.x1 == obstacle.x2)
                            continue;

                        if(!(positionX >= obstacle.x1 && positionX <= obstacle.x2))
                            continue;

                        if(positionY +1 == obstacle.y1)
                            return String.format(""(%d,%d)"",positionX,positionY);
                    }
                    positionY++;

                    if(positionY == map.sizeY)
                        return String.format(""(%d,%d)"",positionX,positionY);
                }
                break;

            case west:

                for (int i = 0; i < tempLength; i++) {
                    for (var obstacle: map.obstacles ) {

                        if(obstacle.y1 == obstacle.y2)
                            continue;

                        if(!(positionY >= obstacle.y1 && positionY <= obstacle.y2))
                            continue;

                        if(positionX == obstacle.x1)
                            return String.format(""(%d,%d)"",positionX,positionY);
                    }
                    positionX--;

                    if(positionX == 0)
                        return String.format(""(%d,%d)"",positionX,positionY);
                }
                break;

            case east:

                for (int i = 0; i < tempLength; i++) {
                    for (var obstacle: map.obstacles ) {

                        if(obstacle.y1 == obstacle.y2)
                            continue;

                        if(!(positionY >= obstacle.y1 && positionY <= obstacle.y2))
                            continue;

                        if(positionX +1 == obstacle.x1)
                            return String.format(""(%d,%d)"",positionX,positionY);
                    }
                    positionX++;

                    if(positionX == map.sizeX)
                        return String.format(""(%d,%d)"",positionX,positionY);
                }
                break;
        }
        
        
        
        return String.format(""(%d,%d)"",positionX,positionY);
    }


}

package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String go(String goCommandString);
}
",5083,174,36.634328358208954,119,0.0,0.09770114942528736,0.09770114942528736,0.011494252873563218,0.42528735632183906,0.005747126436781609,0.22413793103448276,0.0,False,False,True,False,True,False,2,0.011494252873563218,0.05172413793103448,0.034482758620689655,0.017241379310344827,0.5517241379310345,0.1206896551724138,0.011494252873563218,5.888888888888889,12,0.0,0
student73,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Moveable {

    public int[][] grid = new int[12][9];

    //public int[] startPosition = {8,3};
    public int[] currentPosition = {8,3};


    public int[][] fillGrid (int x, int y) {
        for (int i = 0; i < x; i++) {
            for (int j = 0; j < y; j++) {
                grid[i][j] = 1;
            }
        }
        for (int i = 1; i <= 7; i++) {
            grid[4][i] = 0;
        }
        for (int i = 2; i <= 5; i++) {
            grid[6][i] = 0;
        }
        for (int i = 6; i <= 9; i++) {
            grid[i][2] = 0;
        }
        for (int i = 6; i <= 9; i++) {
            grid[i][5] = 0;
        }
        return grid;
    }

    public void showGrid (int[][] grid1) {
        for (int i = 0; i < 12; i++) {
            for (int j = 0; j< 9; j++) {
                System.out.println(grid1[i][j]);
            }
        }
    }

    public void tellPosition() {
        System.out.println(""My x-position is "" + currentPosition[0]);
        System.out.println(""My y-position is "" + currentPosition[1]);
    }

    @Override
    public String moveTo(String moveCommandString) {

        int[][] room = fillGrid(12, 9);
        //showGrid(room);
        int stepsToDo = Integer.parseInt(moveCommandString.substring(moveCommandString.indexOf(',')+1,moveCommandString.indexOf(']'))); //vielleicht noch mit substring testen
        String richtung = moveCommandString.substring(moveCommandString.indexOf('[')+1,moveCommandString.indexOf(','));
        //tellPosition();
        switch (richtung) {
            case ""no"":
                for(int i = 0; i < stepsToDo; i++) {
                    if (currentPosition[1] == 8) {
                        return ""("" + Integer.toString(currentPosition[0]) + "","" + Integer.toString(currentPosition[1]) + "")"";
                    }
                    if (room[currentPosition[0]][currentPosition[1] + 1] == 1) {
                        currentPosition[1]++;
                    } else if (room[currentPosition[0]+1][currentPosition[1]+1] == 1) {
                        currentPosition[1]++;
                    } else return ""("" + Integer.toString(currentPosition[0]) + "","" + Integer.toString(currentPosition[1]) + "")"";
                } break;
            case ""ea"":
                for (int i = 0; i < stepsToDo; i++) {
                    if (currentPosition[0] == 11) {
                        return ""("" + Integer.toString(currentPosition[0]) + "","" + Integer.toString(currentPosition[1]) + "")"";
                    }
                    if (room[currentPosition[0]+1][currentPosition[1]] == 1) {
                        currentPosition[0]++;
                    } else if (room[currentPosition[0]+1][currentPosition[1]+1] == 1) {
                        currentPosition[0]++;
                    } else return ""("" + Integer.toString(currentPosition[0]) + "","" + Integer.toString(currentPosition[1]) + "")"";
                } break;
            case ""so"":
                if (room[currentPosition[0]][currentPosition[1]] == 1 || room[currentPosition[0]+1][currentPosition[1]] == 1) {
                    for (int i = 0; i < stepsToDo; i++) {
                        if (currentPosition[1] == 0) {
                            return ""("" + Integer.toString(currentPosition[0]) + "","" + Integer.toString(currentPosition[1]) + "")"";
                        }
                        if (room[currentPosition[0]][currentPosition[1] - 1] == 1) {
                            currentPosition[1]--;
                        } else if (room[currentPosition[0]][currentPosition[1] - 1] != 1) {
                            currentPosition[1]--;
                            if (room[currentPosition[0]+1][currentPosition[1]] != 1) {
                                return ""("" + Integer.toString(currentPosition[0]) + "","" + Integer.toString(currentPosition[1]) + "")"";
                            }
                        }
                     }
                } else return ""("" + Integer.toString(currentPosition[0]) + "","" + Integer.toString(currentPosition[1]) + "")"";
                break;
            case ""we"":
                if (room[currentPosition[0]][currentPosition[1]] == 1 || room[currentPosition[0]][currentPosition[1]+1] == 1) {
                    for (int i = 0; i < stepsToDo; i++) {
                        if (currentPosition[0] == 0) {
                            return ""("" + Integer.toString(currentPosition[0]) + "","" + Integer.toString(currentPosition[1]) + "")"";
                        }
                        if(room[currentPosition[0]-1][currentPosition[1]] == 1) {
                            currentPosition[0]--;
                        } else if (room[currentPosition[0]-1][currentPosition[1]] != 1) {
                            currentPosition[0]--;
                            if(room[currentPosition[0]][currentPosition[1]+1] != 1) {
                                return ""("" + Integer.toString(currentPosition[0]) + "","" + Integer.toString(currentPosition[1]) + "")"";
                            }
                        }
                    }
                } else return ""("" + Integer.toString(currentPosition[0]) + "","" + Integer.toString(currentPosition[1]) + "")"";
                break;
            default: break;
        }
        //tellPosition();
        return ""("" + Integer.toString(currentPosition[0]) + "","" + Integer.toString(currentPosition[1]) + "")"";
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String moveTo(String moveCommandString);
}
",5565,121,49.49090909090909,174,0.04132231404958678,0.1322314049586777,0.09917355371900827,0.008264462809917356,1.1735537190082646,0.0,0.08264462809917356,0.024793388429752067,False,False,False,False,False,False,2,0.04132231404958678,0.01652892561983471,0.024793388429752067,0.008264462809917356,1.024793388429752,0.2727272727272727,0.0,4.9,15,23.2,36
student76,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Walkable {

    int x=1,y=7;
    @Override
    public String walkTo(String walkCommandString) {

        int steps = Integer.parseInt(String.valueOf(walkCommandString.charAt(4)));

        if(walkCommandString.charAt(1)=='n'){
            if( (x < 3 && y <9) || ( x >= 5 && y < 9)){
                if( y+steps > 8) y=8;
                else y += steps;
            }
            else if((x < 5 && x >= 3) && y < 3){
                if(y+steps > 2) y=2;
                else y += steps;
            }
            else {
                if(y+steps > 8) y=8;
                else y += steps;
            }
        }

        if(walkCommandString.charAt(1)=='s'){
            if( (x < 3 && y >= 0) || (x >= 5 && y >= 0)){
                if( y-steps < 0) y=0;
                else y -= steps;
            }
            else if((x < 5 && x >= 3) ){
                if( y >= 3) {
                    if (y - steps < 3) y = 3;
                    else y -= steps;
                }
                else{
                    if (y - steps < 0) y = 0;
                    else y -= steps;

                }

            }
        }

        if(walkCommandString.charAt(1)=='e'){
            if( (x>=6 && x<=11) && (y>=0 && y<=3)){
                if( x+steps > 11) x=11;
                else x+=steps;
            }

            else if( (x>=3 && x<=11) && (y>=4 && y<=8)){
                if( x+steps > 11) x=11;
                else x+=steps;
            }

            else if(x==5 && (y>=0 && y<=1)){
               x+=steps;
               x=5;
            }

            else if((x>=3 && x<=5) && y==3 ){
                if( x+steps > 5) x=5;
                else x+=steps;
            }

            else if((x>=0 && x<=4) && (y>=0 && y<=1)){
                if( x+steps > 4) x=4;
                else x+=steps;
            }
            else if((x>=0 && x<=5) && y==2){
                if( x+steps > 5) x=5;
                else x+=steps;
            }

            else if((x>=0 && x<=2) && (y>=3 && y<=8)){
                if( x+steps > 2) x=2;
                else x+=steps;
            }
        }

        if(walkCommandString.charAt(1)=='w'){

            if( (x>=6 && x<=11) && (y>=0 && y<=3)){
                if( x-steps < 6) x=6;
                else x-=steps;
            }

            else if( (x>=3 && x<=11) && (y>=4 && y<=8)){
                if( x-steps < 3) x=3;
                else x-=steps;
            }

            else if(x==5 && (y>=0 && y<=1)){
                //x-=steps;
                x=5;
            }

            else if((x>=3 && x<=5) && y==3 ){
                if( x-steps < 3) x=3;
                else x-=steps;
            }

            else if((x>=0 && x<=4) && (y>=0 && y<=1)){
                if( x-steps < 0) x=0;
                else x-=steps;
            }
            else if((x>=0 && x<=5) && y==2){
                if( x-steps < 0) x=0;
                else x-=steps;
            }

            else if((x>=0 && x<=2) && (y>=3 && y<=8)){
                if( x-steps < 0) x=0;
                else x-=steps;
            }
        }


        return ""(""+x+"",""+y+"")"";
    }

}


package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);
}
",3322,129,31.0,82,0.007751937984496124,0.3178294573643411,0.0,0.0,0.9302325581395349,0.0,0.18604651162790697,0.0,False,False,False,False,False,False,2,0.015503875968992248,0.015503875968992248,0.007751937984496124,0.007751937984496124,1.2403100775193798,0.05426356589147287,0.0,2.3333333333333335,5,9.0,9
student77,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Walkable {
    private static double round (double value) {
        int scale = (int) Math.pow(10, 2);
        return (double) Math.round(value * scale) / scale;
    }
    public  double roombaPosition=8.3;
    double[] wallArray ={4.1,4.2,4.3,4.4,4.5,4.6,4.7,6.2,6.3,6.4,6.5,7.2,7.5,8.2,8.5,9.2,9.5};

    @Override
    public String walkTo(String walkCommandString) {

        int c=0;
        String check = walkCommandString.substring(1,3);
    int x = Integer.parseInt(walkCommandString.substring(4,5));
        for (int y =0; y < x; y++){

    switch (check){
        case ""no"":
            c = 0;
            for (int i =0; i < wallArray.length; i++){
                if (wallArray[i]== round(roombaPosition+0.1)){
                    c++;
                }
                if (wallArray[i]==round(roombaPosition+1.1)){
                    c++;
                }
            }
            if(c!=2) roombaPosition = round(roombaPosition+0.1);
            break;
        case ""so"":
            c= 0;
            for (int i =0; i < wallArray.length; i++){

                if (wallArray[i]== round(roombaPosition)){
                    c++;
                }
                if (wallArray[i]==round(roombaPosition+1)){
                    c++;
                }
            }

            if (c!=2) roombaPosition = round(roombaPosition-0.1);
            break;
        case ""ea"":
            c= 0;
            for (int i =0; i < wallArray.length; i++){
                if (wallArray[i]== round(roombaPosition+1.1)){
                    c++;
                }
                if (wallArray[i]==round(roombaPosition+1)){
                    c++;
                }
            }
            if (c!=2) roombaPosition = roombaPosition+1;
            break;
        case ""we"":
            c = 0;
            for (int i =0; i < wallArray.length; i++){
                if (wallArray[i]== round(roombaPosition)){
                    c++;
                }
                if (wallArray[i]==round(roombaPosition+0.1)){
                    c++;
                }
            }
            if (c!=2) roombaPosition = round(roombaPosition-1);
            break;
    }
        }
    return (""(""+ Math.round(roombaPosition) +"",""+ Math.round((roombaPosition-Math.round(roombaPosition))*10) +"")"");
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);
}
",2490,80,33.47222222222222,115,0.0,0.15,0.0625,0.0125,0.975,0.0,0.1,0.0,False,False,False,False,False,False,2,0.0375,0.025,0.05,0.0125,0.875,0.2375,0.0,4.8,14,0.0,0
student79,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Moveable {
    int x= 3;
    int y= 0;

    @Override
    public String moveTo(String moveCommandString) {
        // moveCommandString= [we,3]
        String move= moveCommandString.substring(1,moveCommandString.length()-1);
        String[] moving= move.split("","");
        String richtung= moving[0];
        int steps= Integer.parseInt(moving[1]);



        if (""no"".equals(richtung)) {
            if ((x == 0 || x==8 ||x==9 ||x==10 || x == 11)){
                if ((y + steps) > 7)
                    y = 7;
                else
                    y += steps;
            }
            if (( x== 1 || x==2 || x == 3|| x == 7) && 0 <= y && y <= 3){
                if ((y + steps) > 3)
                    y = 3;
                else
                    y += steps;
            }
            if ((x==4 || x==5 ||x == 6) && 0<=y && y<=2){
                if ((y + steps) > 2)
                    y = 2;
                else
                    y += steps;
            }

            if ((x==4 || x==5 ||x == 6) && y == 3){
                y = 3;
            }

            if (1 <= x && x <= 7 && y >= 4){
                if ((y + steps) > 7)
                    y = 7;
                else
                    y += steps;}

                System.out.println(""x =""+x + ""y=""+y);
        } else if (""so"".equals(richtung)) {
            if ((x == 0 || x==8 ||x==9 ||x==10 || x == 11) && y >= 0){
                if ((y - steps) < 0)
                    y = 0;
                else
                    y -= steps;}

            if (( x== 1 || x==2 || x == 3|| x == 7) && 0 <= y && y <= 3){
                if ((y - steps) < 0)
                    y = 0;
                else
                    y -= steps;}
            if (4 <= x && x <= 6 && 0 <= y && y <= 2){
                if ((y - steps) < 0)
                    y = 0;
                else
                    y -= steps;}

            if ((x==4 || x==5 ||x == 6) && y == 3){
                y = 3;}
            if (1 <= x && x <= 7 && y >= 4){
                if ((y - steps) < 4)
                    y = 4;
                else
                    y -= steps;}
            System.out.println(""x =""+x + ""y=""+y);
        } else if (""ea"".equals(richtung)) {
            if (0 <= x && 3 <= y){
                if ((x + steps) > 11)
                    x = 11;
                else
                    x += steps;}
            if (0 <= x && x <= 2 && 0 <= y && y <= 2){
                if ((x + steps) > 2)
                    x = 2;
                else
                    x += steps;}
            if (3 <= x && x <= 6 && (y == 0 || y == 1)){
                if ((x + steps) > 6)
                    x = 6;
                else
                    x += steps;}
            if (x >= 7 && (y == 0 || y == 1)){
                if ((x + steps) > 11)
                    x = 11;
                else
                    x += steps;}
            if (x >= 3 && y == 2){
                if ((x + steps) > 11)
                    x = 11;
                else
                    x += steps;}
            System.out.println(""x =""+x + ""y=""+y);
        } else if (""we"".equals(richtung)) {
            if (0 <= x && 3 <= y){
                if ((x - steps) < 0)
                    x = 0;
                else
                    x -= steps;}
            if (0 <= x && x <= 2 && 0 <= y && y <= 2){
                if ((x - steps) < 0)
                    x = 0;
                else
                    x -= steps;}

            if (3 <= x && x <= 6 && (y == 0 || y == 1)){
                if ((x - steps) > 3)
                    x = 3;
                else
                    x -= steps;}
            if (x >= 7 && (y == 0 || y == 1)){
                if ((x - steps) < 7)
                    x = 7;
                else
                    x -= steps;}

            if (x >= 3 && y == 2){
                if ((x - steps) < 3)
                    x = 3;
                else
                    x -= steps;}
            System.out.println(""x =""+x + ""y=""+y);
        }

    return ""(""+ this.x +"",""+ this.y+"")"";

    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String moveTo(String moveCommandString);

}
",4268,142,33.008,81,0.007042253521126761,0.29577464788732394,0.0,0.0,0.9436619718309859,0.0,0.11267605633802817,0.028169014084507043,False,False,False,False,False,False,2,0.014084507042253521,0.014084507042253521,0.028169014084507043,0.007042253521126761,1.295774647887324,0.08450704225352113,0.0,4.2,8,25.0,25
student8,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Moveable {

    private int coordinateX = 3, coordinateY = 0;

    public void setCoordinateX(int coordinateX) {
        this.coordinateX = coordinateX;
    }

    public void setCoordinateY(int coordinateY) {
        this.coordinateY = coordinateY;
    }

    private void checkIterationNorthWallSmash(int coordinateX, int coordinateY, int actionCount)
    {
        // under the first wall
        if (coordinateY <= 3 && (coordinateX >= 4 && coordinateX <=7))
        {
            coordinateY+=actionCount;

            if (coordinateY >= 3)
                coordinateY = 2;
            setCoordinateY(coordinateY);

            // between wall 1 & 2
        }else if (coordinateY == 3 && coordinateX >= 1 && coordinateX <= 7)
        {
            coordinateY = 3;
            setCoordinateY(coordinateY);


        }else if (coordinateY <= 3 && (coordinateX >= 1 && coordinateX <= 7) && !(coordinateX >= 4 && coordinateX <=7) )
        {
          coordinateY +=actionCount;
          if (coordinateY > 3)
          {
              coordinateY = 3;
          }
          setCoordinateY(coordinateY);

        } else if (coordinateY == 3 && !(coordinateX >= 1 && coordinateX <= 8))
        {

            coordinateY+=actionCount;
            if (coordinateY > 11)
                coordinateY = 11;
                setCoordinateY(coordinateY);
        } else
        {
            // abroad the two walls ==> boundary check
            coordinateY += actionCount;
            if (coordinateY > 7)
                coordinateY = 7;
                setCoordinateY(coordinateY);
        }
    }


    private void checkIterationEastWallSmash(int coordinateX, int coordinateY, int actionCount)
    {
        // before the first wall
        if (coordinateX <= 2 && (coordinateY >= 0 && coordinateY <= 2))
        {
            coordinateX += actionCount;

            if (coordinateX >= 3)
            {
                coordinateX = 2;

            }

            setCoordinateX(coordinateX);
            // between wall 1 & 2
        }else if (coordinateX >= 3 && coordinateX <= 7 &&  (coordinateY >= 0 && coordinateY <= 1))
        {

            coordinateX+=actionCount;

            if (coordinateX >= 7 )
            {
                coordinateX = 6;

            }
            setCoordinateX(coordinateX);

            // abroad the walls ==> boundary check
        }else
        {
            coordinateX += actionCount;
            if (coordinateX >= 11)
                coordinateX = 11;

            setCoordinateX(coordinateX);
        }
    }

    private void checkIterationSouthWallSmash(int coordinateX, int coordinateY, int actionCount)
    {
        if (coordinateY >= 4 && (coordinateX >= 1 && coordinateX <= 7))
        {
            coordinateY-=actionCount;
            if (coordinateY <= 4)
            {
                coordinateY = 4;
            }
            setCoordinateY(coordinateY);

        }else if (coordinateY == 3 && (coordinateX >= 4 && coordinateX <=6) )
        {

            coordinateY = 3;
            setCoordinateY(coordinateY);

        }else if (coordinateY == 3 && !(coordinateX >= 4 && coordinateX <=7))
        {
            coordinateY-=actionCount;
            if (coordinateY < 0)
                coordinateY = 0;

            setCoordinateY(coordinateY);
        }else
        {
            coordinateY-=actionCount;
            if (coordinateY < 0)
                coordinateY = 0;

            setCoordinateY(coordinateY);
        }

    }

    private void checkIterationWestWallSmash(int coordinateX, int coordinateY, int actionCount)
    {
        if (coordinateX >= 7 && (coordinateY >= 0 && coordinateY <= 1))
        {
            coordinateX -= actionCount;

            if (coordinateX <= 7)
            {
                coordinateX = 7;
            }

            setCoordinateX(coordinateX);

        }else if (coordinateX <= 7 && coordinateX >= 3 && (coordinateY <= 2))
        {
            coordinateX -= actionCount;

            if (coordinateX <= 3)
            {
                coordinateX = 3;
            }

            setCoordinateX(coordinateX);



        }else if (coordinateX <= 7 && coordinateX >= 3 && coordinateY == 3)
        {

            coordinateX -= actionCount;

            if (coordinateX <= 0)
            {
                coordinateX = 0;
            }

            setCoordinateX(coordinateX);
        } else if (coordinateX <= 7 && coordinateX >= 3 && !(coordinateY >= 0 && coordinateY <= 3))
        {
            coordinateX-=actionCount;

            setCoordinateX(coordinateX);
        }else
        {
            coordinateX-=actionCount;
            if (coordinateX < 0)
            {
                coordinateX = 0;
            }

            setCoordinateX(coordinateX);
        }


    }

    @Override
    public String moveTo(String moveCommandString)
    {

        moveCommandString = moveCommandString.replace(""["","""");

        moveCommandString = moveCommandString.replace(""]"","""");

        String[] movementCommand = moveCommandString.split("","");

        String count = movementCommand[1];

        int actionCount = Integer.parseInt(count);

        String movementOrientation = movementCommand[0];


        switch (movementOrientation)
        {
            case ""no"":
                checkIterationNorthWallSmash(coordinateX,coordinateY,actionCount);
                break;
            case ""ea"":
                checkIterationEastWallSmash(coordinateX,coordinateY,actionCount);
                break;
            case ""so"":
                checkIterationSouthWallSmash(coordinateX,coordinateY,actionCount);
                break;
            case ""we"":
                checkIterationWestWallSmash(coordinateX,coordinateY,actionCount);
                break;
        }





          return ""(""+coordinateX+"",""+coordinateY+"")"";

    }

}


package thkoeln.st.st2praktikum.exercise;

public interface Moveable
{
    String moveTo(String moveCommandString);
}
",6063,238,33.285714285714285,120,0.025210084033613446,0.1134453781512605,0.004201680672268907,0.004201680672268907,0.3697478991596639,0.0,0.23109243697478993,0.0,False,False,False,False,False,False,2,0.03361344537815126,0.008403361344537815,0.01680672268907563,0.004201680672268907,0.6050420168067226,0.10504201680672269,0.0,12.714285714285714,19,25.166666666666668,39
student80,student,,,"package thkoeln.st.st2praktikum.exercise;


public class Exercise0 implements Walkable {
    String robotPosition = ""3,0"";

    @Override
    public String walk(String walkCommandString) {
        int xMax = 11;
        int yMax = 7;
        Boolean theBreak = false;

        int commandsAmount = walkCommandString.length();

        String[] verticalWallPostions = new String[]{
                ""3,0"",
                ""3,1"",
                ""3,2"",
                ""3,3"",
                ""7,0"",
                ""7,1"",
                ""7,2"",
        };
        String[] horizontalWallPostions = new String[]{
                ""4,3"",
                ""5,3"",
                ""6,3"",
                ""7,3"",
                ""1,4"",
                ""2,4"",
                ""3,4"",
                ""4,4"",
                ""5,4"",
                ""6,4"",
                ""7,4"",
                ""8,4"",
        };

        if (walkCommandString.charAt(1) == 'n') {
            StringBuilder intXRobotPosition = new StringBuilder();
            StringBuilder intYRobotPosition = new StringBuilder();
            StringBuilder integerString = new StringBuilder();
            for (int i = 4; i < walkCommandString.length() - 1; i++) {
                integerString.append(walkCommandString.charAt(i));
            }
            int steps = Integer.parseInt(integerString.toString());
            for (int i = 2; i < robotPosition.length(); i++) {
                intYRobotPosition.append(robotPosition.charAt(i));
            }
            int robotYPosition = Integer.parseInt(intYRobotPosition.toString());
            if (robotPosition.charAt(1) == ',') {
                intXRobotPosition.append(robotPosition.charAt(0));
            } else {
                intXRobotPosition.append(robotPosition.charAt(0));
                intXRobotPosition.append(robotPosition.charAt(1));
            }
            int robotXPosition = Integer.parseInt(intXRobotPosition.toString());


            for (int j = 1; j <= steps; j++) {
                int temp = robotYPosition + 1;
                String tempString = robotXPosition + "","" + temp;
                for (String horizontalWallPostion : horizontalWallPostions) {
                    if (tempString.equals(horizontalWallPostion)) {
                        theBreak = true;

                    }
                }
                if (temp <= yMax && !theBreak) {
                    robotYPosition += 1;
                } else {
                    break;
                }
            }
            robotPosition = +robotXPosition + "","" + robotYPosition;

        }
        if (walkCommandString.charAt(1) == 'e') {
            StringBuilder intXRobotPosition = new StringBuilder();
            StringBuilder intYRobotPosition = new StringBuilder();
            StringBuilder integerString = new StringBuilder();
            for (int i = 4; i < walkCommandString.length() - 1; i++) {
                integerString.append(walkCommandString.charAt(i));
            }
            int steps = Integer.parseInt(integerString.toString());
            for (int i = 2; i < robotPosition.length(); i++) {
                intYRobotPosition.append(robotPosition.charAt(i));
            }
            int robotYPosition = Integer.parseInt(intYRobotPosition.toString());
            if (robotPosition.charAt(1) == ',') {
                intXRobotPosition.append(robotPosition.charAt(0));
            } else {
                intXRobotPosition.append(robotPosition.charAt(0));
                intXRobotPosition.append(robotPosition.charAt(1));
            }
            int robotXPosition = Integer.parseInt(intXRobotPosition.toString());

            for (int j = 1; j <= steps; j++) {
                int temp = robotXPosition + 1;
                String tempString = temp + "","" + robotYPosition;
                for (String verticalWallPostion : verticalWallPostions) {
                    if (tempString.equals(verticalWallPostion)) {
                        theBreak = true;

                    }
                }
                if (temp <= xMax && !theBreak) {
                    robotXPosition += 1;
                } else {
                    break;
                }
            }
            robotPosition = +robotXPosition + "","" + robotYPosition;

        }
        if (walkCommandString.charAt(1) == 's') {
            StringBuilder intXRobotPosition = new StringBuilder();
            StringBuilder intYRobotPosition = new StringBuilder();
            StringBuilder integerString = new StringBuilder();
            for (int i = 4; i < walkCommandString.length() - 1; i++) {
                integerString.append(walkCommandString.charAt(i));
            }
            int steps = Integer.parseInt(integerString.toString());
            for (int i = 2; i < robotPosition.length(); i++) {
                intYRobotPosition.append(robotPosition.charAt(i));
            }
            int robotYPosition = Integer.parseInt(intYRobotPosition.toString());
            if (robotPosition.charAt(1) == ',') {
                intXRobotPosition.append(robotPosition.charAt(0));
            } else {
                intXRobotPosition.append(robotPosition.charAt(0));
                intXRobotPosition.append(robotPosition.charAt(1));
            }
            int robotXPosition = Integer.parseInt(intXRobotPosition.toString());

            for (int j = 1; j <= steps; j++) {
                int temp = robotYPosition - 1;
                String tempString = robotXPosition + "","" + temp;
                for (String horizontalWallPostion : horizontalWallPostions) {
                    if (tempString.equals(horizontalWallPostion)) {
                        theBreak = true;
                        robotYPosition -= 1;

                    }
                }
                if (temp >= 0 && !theBreak) {
                    robotYPosition -= 1;
                } else {
                    break;
                }
            }
            robotPosition = +robotXPosition + "","" + robotYPosition;

        }
        if (walkCommandString.charAt(1) == 'w') {
            StringBuilder intXRobotPosition = new StringBuilder();
            StringBuilder intYRobotPosition = new StringBuilder();
            StringBuilder integerString = new StringBuilder();
            for (int i = 4; i < walkCommandString.length() - 1; i++) {
                integerString.append(walkCommandString.charAt(i));
            }
            int steps = Integer.parseInt(integerString.toString());
            for (int i = 2; i < robotPosition.length(); i++) {
                intYRobotPosition.append(robotPosition.charAt(i));
            }
            int robotYPosition = Integer.parseInt(intYRobotPosition.toString());
            if (robotPosition.charAt(1) == ',') {
                intXRobotPosition.append(robotPosition.charAt(0));
            } else {
                intXRobotPosition.append(robotPosition.charAt(0));
                intXRobotPosition.append(robotPosition.charAt(1));
            }
            int robotXPosition = Integer.parseInt(intXRobotPosition.toString());

            for (int j = 1; j <= steps; j++) {
                int temp = robotXPosition - 1;
                String tempString = temp + "","" + robotYPosition;
                for (String verticalWallPostion : verticalWallPostions) {
                    if (tempString.equals(verticalWallPostion)) {
                        theBreak = true;
                        robotXPosition -= 1;

                    }
                }
                if (temp >= 0 && !theBreak) {
                    robotXPosition -= 1;
                } else {
                    break;
                }
            }
            robotPosition = +robotXPosition + "","" + robotYPosition;


        }


        return ""("" + robotPosition + "")"";
    }
}




package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",7943,208,42.73480662983425,80,0.0,0.07692307692307693,0.07692307692307693,0.0,0.4519230769230769,0.0,0.10096153846153846,0.0,False,False,False,False,False,True,2,0.009615384615384616,0.004807692307692308,0.18269230769230768,0.004807692307692308,0.42788461538461536,0.40865384615384615,0.0,10.714285714285714,22,0.0,0
student82,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Moveable {


    int px = 5;
    int py = 3;
    String[] mO = {""(1,6)"",""(2,6)"",""(3,6)"",""(4,6)"",""(5,6)"",""(3,3)"",""(4,3)"",""(5,3)"",""(6,3)"",""(7,3)"",""(8,3)""};
    String[] mU = {""(1,5)"",""(2,5)"",""(3,5)"",""(4,5)"",""(5,5)"",""(3,2)"",""(4,2)"",""(5,2)"",""(6,2)"",""(7,2)"",""(8,2)""};
    String[] mL = {""(5,7)"",""(5,6)"",""(5,5)"",""(5,4)"",""(5,3)"",""(5,2)"",""(3,2)"",""(3,1)""};
    String[] mR = {""(6,7)"",""(6,6)"",""(6,5)"",""(6,4)"",""(6,3)"",""(6,2)"",""(4,2)"",""(4,1)""};



    public String getDirection(String moveCommandString) {
        return  moveCommandString.substring(1,3);

    }

    public int getPower(String moveCommandString) {
        int i = moveCommandString.length();
        return  Integer.parseInt(moveCommandString.substring(4,i-1));

    }

    @Override
    public String move(String moveCommandString) {
        System.out.println(moveCommandString);

        int power = getPower(moveCommandString);
        String direction = getDirection(moveCommandString);

        for(int i = 0; i<power; i++){
            if(py == 0 && direction.equals(""so"")) {direction = """";}
            if(py == 7 && direction.equals(""no"")) {direction = """";}
            if(px == 0 && direction.equals(""we"")) {direction = """";}
            if(px == 11 && direction.equals(""ea"")) {direction = """";}

            for (String s : mU) {
                if (direction.equals(""so"") && s.equals(""(""+px+"",""+(py-1)+"")"")){
                    direction = """";
                    break;
                }
            }


            for (String s : mO) {
                if (direction.equals(""no"") && s.equals(""(""+px+"",""+(py+1)+"")"")){
                    direction = """";
                    break;
                }
            }


            for (String s : mL) {
                if (direction.equals(""we"") && s.equals(""(""+(px-1)+"",""+py+"")"")) {
                    direction = """";
                    break;
                }
            }

            for (String s : mR) {
                if (direction.equals(""ea"") && s.equals(""(""+(px+1)+"",""+py+"")"")){
                    direction = """";
                    break;
                }
            }


            switch(direction){
                case ""no"":
                    py = py +1;
                    break;
                case ""ea"":
                    px = px +1;
                    break;
                case ""so"":
                    py = py -1;
                    break;
                case ""we"":
                    px = px -1;
                    break;
                default:

                    break;
            }
        }


        System.out.println(px);
        System.out.println(py);
        return ""(""+px+"",""+py+"")"";
    }

    
}

package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String move(String moveCommandString);
}
",2866,102,36.36842105263158,108,0.0,0.0784313725490196,0.049019607843137254,0.00980392156862745,0.9705882352941176,0.0,0.19607843137254902,0.029411764705882353,False,False,False,False,False,False,2,0.0392156862745098,0.058823529411764705,0.029411764705882353,0.00980392156862745,0.43137254901960786,0.20588235294117646,0.0,4.4,17,0.0,0
student83,student,,,"package thkoeln.st.st2praktikum.exercise;

import java.util.ArrayList;

public class Exercise0 implements Walkable {
    int x=11;
    int y=7;
    @Override
    public String walkTo(String walkCommandString) {

        String movement=walkCommandString.substring(1,walkCommandString.length()-1);
        String[] walking=movement.split("","");
        String direction=walking[0];
        int steps= Integer.parseInt(walking[1]);

        switch (direction){
            case ""no"":
                //1)
                if (0<=x && x<=4 && 0<=y && y<=7){
                    if ( (y+steps)>7)
                        y=7;
                    else
                        y+=steps;
                }
                //2)
                if (x==5 && 0<=y && y<=4){
                    if ((y+steps)>4)
                        y=4;
                    else
                        y+=steps;
                }
                //3)
                if (x==5 && y==5){
                    y=5;
                }
                //4)
                if (6<=x && x<=11 && 0<=y && y<=5){
                    if ((y+steps)>5)
                        y=5;
                    else
                        y+=steps;
                }
                //5)
                if (x>=5 &&x<=11 && y>=6 &&y<=7){
                    if ((y+steps)>7)
                        y=7;
                    else
                        y+=steps;
                }break;

            case ""so"":

                if (0<=x && x<=4 && 0<=y && y<=7){
                    if ( (y-steps)<0)
                        y=0;
                    else
                        y-=steps;
                }

                if (x==5 && 0<=y && y<=4){
                    if ((y-steps)<0)
                        y=0;
                    else
                        y-=steps;
                }

                if (x==5 && y==5){
                    y=5;
                }

                if (6<=x && x<=11 && 0<=y && y<=5){
                    if ((y-steps)<0)
                        y=0;
                    else
                        y-=steps;
                }
                //5)
                if (x>=5 &&x<=11 && y>=6 &&y<=7){
                    if ((y-steps)<6)
                        y=6;
                    else
                        y-=steps;
                }break;
            case ""ea"":

                if (0<=x && x<=11 && (y==6 || y==7 ||y==0 || y==1)){
                    if ( (x+steps)>11)
                        x=11;
                    else
                        x+=steps;
                }

                if (y==5 && 0<=x && x<=4){
                    if ((x+steps)>4)
                        x=4;
                    else
                        x+=steps;
                }
                if ((y==4||y==3||y==2) && 0<=x && x<=5){
                    if ((x+steps)>5)
                        x=5;
                    else
                        x+=steps;
                }
                if (5<=x&&x>=11 && y==5){
                    if ((x+steps)>11)
                        x=11;
                    else
                        x+=steps;
                }
                if (6<=x&&x>=11 && 0<=y&&y<=4){
                    if ((x+steps)>11)
                        x=11;
                    else
                        x+=steps;
                }
                break;
            case ""we"":

                if (0<=x && x<=11 && (y==6 || y==7 ||y==0 || y==1)){
                    if ( (x-steps)<0)
                        x=0;
                    else
                        x-=steps;
                }
                //2)
                if (y==5 && 0<=x && x<=4){
                    if ((x-steps)<0)
                        x=0;
                    else
                        x-=steps;
                }
                if ((y==4||y==3||y==2) && 0<=x && x<=5){
                    if ((x-steps)<0)
                        x=0;
                    else
                        x-=steps;
                }
                if (5<=x&&x>=11 && y==5){
                    if ((x-steps)<5)
                        x=5;
                    else
                        x-=steps;
                }
                if (6<=x&&x>=11 && 0<=y&&y<=4){
                    if ((x-steps)<6)
                        x=6;
                    else
                        x-=steps;
                }
                break;
        }
        return ""("" + this.x+"",""+ this.y+ "")"" ;
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);
}",4595,160,30.17687074829932,84,0.04375,0.2375,0.0,0.00625,0.91875,0.0,0.08125,0.0,False,False,False,False,False,False,2,0.0125,0.0125,0.025,0.00625,1.08125,0.025,0.00625,4.6,9,2.0,2
student84,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Barrier {
    Coordinate start;
    Coordinate end;

    public Barrier(Coordinate start, Coordinate end) {
        this.start = start;
        this.end = end;
    }
}

package thkoeln.st.st2praktikum.exercise;

public class Coordinate {
    int x;
    int y;

    public Coordinate(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public String toString() {
        return ""("" + this.x + "","" + this.y + "")"";
    }
}

package thkoeln.st.st2praktikum.exercise;

import com.sun.istack.Nullable;

import java.util.Arrays;

public class Exercise0 implements Walkable {

    Coordinate robotPosition = new Coordinate(1, 7);
    Barrier[] barriers = {
            new Barrier(new Coordinate(0,0), new Coordinate(12, 0)),
            new Barrier(new Coordinate(0, 0), new Coordinate(0, 9)),
            new Barrier(new Coordinate(0, 9), new Coordinate(12, 9)),
            new Barrier(new Coordinate(12, 0), new Coordinate(12, 9)),
            new Barrier(new Coordinate(3, 3), new Coordinate(3, 9)),
            new Barrier(new Coordinate(3, 3), new Coordinate(5, 3)),
            new Barrier(new Coordinate(5, 0), new Coordinate(5, 2)),
            new Barrier(new Coordinate(6, 0), new Coordinate(6, 4))
    };

    public Barrier[] getHorizontalBarriers() {
       return Arrays.stream(this.barriers).filter(barrier -> barrier.start.y == barrier.end.y).toArray(size -> new Barrier[size]);
    }

    public Barrier[] getVerticalBarriers() {
        return Arrays.stream(this.barriers).filter(barrier -> barrier.start.x == barrier.end.x).toArray(size -> new Barrier[size]);
    }

    public enum Direction {
        no,
        ea,
        so,
        we
    }

    @Override
    public String walk(String walkCommandString) {
        String[] walkCommands = walkCommandString.replace(""["", """").replace(""]"", """").split("","");
        Direction direction = Direction.valueOf(walkCommands[0]);
        int steps = Integer.parseInt(walkCommands[1]);

        Coordinate newPosition = new Coordinate(robotPosition.x, robotPosition.y);

        switch (direction) {
            case no:
                newPosition.y += steps;
                break;
            case ea:
                newPosition.x += steps;
                break;
            case so:
                newPosition.y -= steps;
                break;
            case we:
                newPosition.x -= steps;
                break;
        }

        Coordinate wallCoordinateBetween = coordinateOfBarrierBetween(robotPosition, newPosition);

        if(wallCoordinateBetween != null) {
            newPosition = wallCoordinateBetween;
            if (direction == Direction.ea) {
                newPosition.x--;
            } else if (direction == Direction.no) {
                newPosition.y--;
            }
        }

        this.robotPosition = newPosition;

        System.out.println(""Set robot position to "" + this.robotPosition.toString());
        return this.robotPosition.toString();
    }

    @Nullable
    public Coordinate coordinateOfBarrierBetween(Coordinate start, Coordinate end) {
        if(start.x == end.x) {
            // vertical movement
            if (start.y > end.y) {
                Coordinate tmp = start;
                start = end;
                end = tmp;
            }
            for(Barrier barrier: this.getHorizontalBarriers()) {
                if((barrier.start.y > start.y && barrier.start.y <= end.y)) {
                    // There is a barrier between start and end. Now we have to check if it is in the direct path
                    if((barrier.start.x <= start.x && barrier.end.x > start.x)) {
                        System.out.println(""Something Between "" + start.toString() + "" and "" + end.toString());
                        System.out.println(""Wall coordinates: "" + barrier.start.toString() + "", "" + barrier.end.toString());
                        return new Coordinate(start.x, barrier.start.y);
                    }
                }
            }
        } else {
            // horizontal movement
            if (start.x > end.x) {
                Coordinate tmp = start;
                start = end;
                end = tmp;
            }
            for(Barrier barrier: this.getVerticalBarriers()) {
                if((barrier.start.x > start.x && barrier.start.x <= end.x)) {
                    // There is a barrier between start and end. Now we have to check if it is in the direct path
                    if((barrier.start.y <= start.y && barrier.end.y > start.y)) {
                        System.out.println(""Something Between "" + start.toString() + "" and "" + end.toString());
                        System.out.println(""Wall coordinates: "" + barrier.start.toString() + "", "" + barrier.end.toString());
                        return new Coordinate(barrier.start.x, start.y);
                    }
                }
            }
        }

        return null;
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",5105,150,39.64,131,0.02666666666666667,0.08,0.013333333333333334,0.006666666666666667,0.3,0.0,0.16666666666666666,0.03333333333333333,False,False,False,False,False,False,4,0.04,0.04,0.04666666666666667,0.02,0.5733333333333334,0.19333333333333333,0.013333333333333334,5.85,21,54.0,90
student85,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Dam {


    Position from, to;

    public Dam() {
    }

    public Dam(Position from, Position to) {
        this.from = from;
        this.to = to;
    }

    public Position getFrom() {
        return from;
    }

    public void setFrom(Position from) {
        this.from = from;
    }

    public Position getTo() {
        return to;
    }

    public void setTo(Position to) {
        this.to = to;
    }
}
package thkoeln.st.st2praktikum.exercise;

import java.util.ArrayList;
import java.util.List;

public class Exercise0 implements GoAble {

    Position cleaningdvice;
    int endof_x = 11, endof_y = 8;
    List<Dam> damList = new ArrayList<>();
    public Exercise0() {
        cleaningdvice = new Position(1, 7);
        Position damposition1 = new Position(3, 3);
        Position damposition2 = new Position(3, 9);
        Position damposition3 = new Position(5, 3);
        Position damposition4 = new Position(5, 0);
        Position damposition5 = new Position(5, 2);
        Position damposition6 = new Position(6, 0);
        Position damposition7 = new Position(6, 4);
        damList.add(new Dam(damposition1, damposition2));
        damList.add(new Dam(damposition1, damposition3));
        damList.add(new Dam(damposition4, damposition5));
        damList.add(new Dam(damposition6, damposition7));
    }


    String run_commend(String direction, int steps) {
        switch (direction) {
            case ""no"":
                up_and_down(steps, 1);
                break;
            case ""so"":
                up_and_down(steps, -1);
                break;
            case ""ea"":
                right_and_left(steps,1);
                break;
            case ""we"":
                right_and_left(steps,-1);
                break;
        }
        return """";
    }

    private void right_and_left(int movment, int right_or_left) {
        int right=0;if(right_or_left>0)right=1;
        for (int i = 1; i <= movment; i++) {
            boolean can_move = true;
            if (cleaningdvice.getX() + right_or_left <= endof_x && cleaningdvice.getX() + right_or_left >= 0) {
                for (Dam dam : damList) {
                    if (dam.getFrom().getX() == dam.getTo().getX()) {
                        if (cleaningdvice.getX()+right == dam.getFrom().getX() && cleaningdvice.getY() >= dam.getFrom().getY() && cleaningdvice.getY() < dam.getTo().getY()) {
                            can_move = false;
                            break;
                        }
                    }
                }
            }else can_move = false;
            if (can_move) cleaningdvice.setX(cleaningdvice.getX()+right_or_left);
            else break;
        }
    }



    private void up_and_down(int movment, int up_or_down) {
        int up=0;if(up_or_down>0)up=1;
        for (int i = 1; i <= movment; i++) {
            boolean can_move = true;
            if (cleaningdvice.getY() + up_or_down <= endof_y && cleaningdvice.getY() + up_or_down >= 0) {
                for (Dam dam : damList) {
                    if (dam.getFrom().getY() == dam.getTo().getY()) {
                        if (cleaningdvice.getY()+up == dam.getFrom().getY() && cleaningdvice.getX() >= dam.getFrom().getX() && cleaningdvice.getX() < dam.getTo().getX()) {
                            can_move = false;
                            break;
                        }
                    }
                }
            } else can_move = false;
            if (can_move) cleaningdvice.setY(cleaningdvice.getY()+up_or_down);
            else break;
        }
    }


    @Override
    public String goTo(String walkCommandString) {
        String newcommand[]=walkCommandString.replace(""["","""").replace(""]"","""").split("","");
        String direction=newcommand[0];
        int steps =Integer.parseInt(newcommand[1]);



        run_commend(direction,steps);
        return cleaningdvice.toString();
    }



}

package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String goTo(String goCommandString);
}

package thkoeln.st.st2praktikum.exercise;

public class Position {


    int x,y;

    public Position() {
    }

    public Position(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return x;
    }

    public void setX(int x) {
        this.x = x;
    }

    public int getY() {
        return y;
    }

    public void setY(int y) {
        this.y = y;
    }

    @Override
    public String toString() {
        return ""("" + x +"","" + y +')';
    }
}

",4588,175,32.68888888888889,174,0.0,0.05714285714285714,0.022857142857142857,0.005714285714285714,0.32,0.0,0.18857142857142858,0.0,True,True,False,False,False,False,4,0.08,0.045714285714285714,0.08,0.017142857142857144,0.38857142857142857,0.2742857142857143,0.011428571428571429,7.84,13,0.0,0
student86,student,,,"package thkoeln.st.st2praktikum.exercise;

import java.util.ArrayList;
import java.util.List;

class Coord {
    public Coord (Integer x, Integer y) {
        this.x = x;
        this.y = y;
    }
    public Integer x, y;

    public Integer pathLength (Coord target) {
        return  Math.abs(x - target.x) +
                Math.abs(y - target.y);
    }
}

class Obstacle {
    public Obstacle (Coord start, Coord end) {
        this.start = start;
        this.end = end;
    }
    public Coord start, end;

    public Boolean isHorizontal () { return start.y.equals(end.y); }
    public Boolean isVertical () { return start.x.equals(end.x); }

    public Integer possibleSteps (Coord pathStart, Coord pathEnd) {
        // Vertikale Bewegung und horizontales Hindernis
        if (pathStart.x.equals(pathEnd.x) && isHorizontal()) {
            Integer pathLine = pathStart.x;
            Integer obstLine = start.y;
            Integer pathMin = Math.min(pathStart.y, pathEnd.y);
            Integer pathMax = Math.max(pathStart.y, pathEnd.y);
            Integer obstMin = Math.min(start.x, end.x);
            Integer obstMax = Math.max(start.x, end.x);

            if (pathLine >= obstMin && pathLine < obstMax &&
                    pathMax >= obstLine && pathMin < obstLine) {
                Integer steps = Math.abs(pathStart.y - obstLine);
                return (pathStart.y < pathEnd.y) ? steps - 1 : steps;
            }
        }
        // Horizontale Bewegung und vertikales Hindernis
        else if (pathStart.y.equals(pathEnd.y) && isVertical()) {
            Integer pathLine = pathStart.y;
            Integer obstLine = start.x;
            Integer pathMin = Math.min(pathStart.x, pathEnd.x);
            Integer pathMax = Math.max(pathStart.x, pathEnd.x);
            Integer obstMin = Math.min(start.y, end.y);
            Integer obstMax = Math.max(start.y, end.y);

            if (pathLine >= obstMin && pathLine < obstMax &&
                    pathMax >= obstLine && pathMin < obstLine) {
                Integer steps = Math.abs(pathStart.x - obstLine);
                return (pathStart.x < pathEnd.x) ? steps - 1 : steps;
            }
        }

        return pathStart.pathLength(pathEnd);
    }
}

class Space {
    public Space (Integer width, Integer height) {
        this.width = width;
        this.height = height;
        obstacles = new ArrayList<>();
        cleanerPosition = new Coord(0,0);
    }

    Integer width, height;
    List<Obstacle> obstacles;
    Coord cleanerPosition;

    public void addObstacle (Obstacle obstacle) {
        obstacles.add(obstacle);
    }

    public void setCleanerPosition (Coord coord) {
        cleanerPosition = coord;
    }

    public Coord moveCleaner (Integer horSteps, Integer verSteps) {
        Coord destination = new Coord(
                cleanerPosition.x + horSteps,
                cleanerPosition.y + verSteps
        );

        destination.x = Math.min(width-1, Math.max(0, destination.x));
        destination.y = Math.min(height-1, Math.max(0, destination.y));

        Integer minSteps = cleanerPosition.pathLength(destination);

        for (Obstacle o : obstacles) {
            Integer possibleSteps = o.possibleSteps(cleanerPosition, destination);
            minSteps = Math.min(minSteps, possibleSteps);
        }

        cleanerPosition = new Coord(
                (int) (cleanerPosition.x + Math.signum(horSteps) * minSteps),
                (int) (cleanerPosition.y + Math.signum(verSteps) * minSteps)
        );

        return cleanerPosition;
    }
}

public class Exercise0 implements Walkable {

    public Exercise0 () {
        space = new Space(11, 8);
        space.addObstacle(new Obstacle(new Coord( 2, 1), new Coord(10 ,1)));
        space.addObstacle(new Obstacle(new Coord( 2, 1), new Coord( 2 ,6)));
        space.addObstacle(new Obstacle(new Coord(10 ,1), new Coord(10, 8)));
        space.addObstacle(new Obstacle(new Coord( 2 ,6), new Coord( 7, 6)));

        space.setCleanerPosition(new Coord( 7, 7));
    }

    Space space;

    @Override
    public String walk (String walkCommandString) {
        String direction = walkCommandString.substring(1, 3);
        int horSteps = 0, verSteps = 0;
        int steps = Integer.parseInt(
                walkCommandString.substring(4, walkCommandString.length() - 1)
        );

        switch (direction) {
            case ""no"": verSteps = steps; break;
            case ""ea"": horSteps = steps; break;
            case ""so"": verSteps = -steps; break;
            case ""we"": horSteps = -steps; break;
            default:
                return """";
        }

        Coord coord = space.moveCleaner(horSteps, verSteps);

        return ""("" + coord.x.toString() + "","" + coord.y.toString() + "")"";
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walk(String walkCommandString);
}
",4906,151,38.97540983606557,82,0.013245033112582781,0.026490066225165563,0.006622516556291391,0.006622516556291391,0.2781456953642384,0.0,0.19205298013245034,0.0,False,True,True,False,False,False,2,0.059602649006622516,0.059602649006622516,0.1456953642384106,0.026490066225165563,0.7350993377483444,0.271523178807947,0.013245033112582781,7.04,15,45.0,45
student89,student,,,"package thkoeln.st.st2praktikum.exercise;

import javassist.bytecode.stackmap.BasicBlock;

import java.io.Console;

public class Exercise0 implements Moveable {

    public static String [][] position = new String[11][8];
    int xstart=7;
    int ystart=7;
    /*Wand1
    String wall1_1=""(9,1)-(9,7)"";
    String wall2_1=""(9,1)-(2,1)"";
    String wall3_1=""(2,1)-(2,5)"";
    String wall4_1=""(2,5)-(6,5)"";
    Wand2
    String wall1=""(10,0)-(10,7)"";
    String wall2=""(10,0)-(1,0)"";
    String wall3=""(1,0)-(1,6)"";
    String wall4=""(1,6)-(6,6)"";*/


    @Override
    public String move(String moveCommandString) {
        String direction=""""+moveCommandString.toCharArray()[1]+moveCommandString.toCharArray()[2]+"""";
        char c =(moveCommandString.charAt(4));
        int moves= Integer.parseInt(moveCommandString.replaceAll(""\\D"", """"));
        System.out.println(moves);
        Waendebauen();

        int takensteps=0;
        System.out.println(moves);

        try {

            if (direction.equals(""no"")) {
                if (moves>position[0].length-1-ystart)
                {
                    moves=position[0].length-1-ystart;
                }

                while (takensteps < moves) {
                    if (position[xstart][ystart + takensteps] == ""Wand1"" && position[xstart][ystart + takensteps + 1] == ""Wand2"") {
                        ystart = ystart + takensteps;
                        return ""("" + xstart + "","" + ystart + "")"";
                    }


                    if (position[xstart][ystart + takensteps] == ""Wand2"" && position[xstart][ystart + takensteps + 1] == ""Wand1"") {
                        ystart = ystart + takensteps;
                        return ""("" + xstart + "","" + ystart + "")"";
                    } else {
                        takensteps += 1;
                    }
                }

                    ystart = ystart + takensteps;

                }

            if (direction.equals(""ea"")) {

                if (moves>position.length-1-xstart)
                {
                    moves=position.length-1-xstart;
                }
                while (takensteps < moves ) {
                    if (position[xstart + takensteps ][ystart] == ""Wand1""&&position[xstart + takensteps + 1][ystart] == ""Wand2"")
                    {
                        xstart=xstart+takensteps;
                        return ""("" + xstart + "","" + ystart + "")"";
                    }
                    if (position[xstart + takensteps ][ystart] == ""Wand2""&&position[xstart + takensteps + 1][ystart] == ""Wand1"")
                    {
                        xstart=xstart+takensteps;
                        return ""("" + xstart + "","" + ystart + "")"";
                    }
                    else{
                        takensteps += 1;
                    }
                }
                xstart = xstart + takensteps;

            }
            if (direction.equals(""so"")) {

                if (ystart-moves<0)
                {
                    moves=ystart;
                }
                while (takensteps < moves ) {
                    if (position[xstart][ystart - takensteps ] == ""Wand1""&&position[xstart][ystart - takensteps - 1] == ""Wand2"")
                    {
                        ystart = ystart - takensteps;
                        return ""("" + xstart + "","" + ystart + "")"";
                    }
                    if (position[xstart][ystart - takensteps ] == ""Wand2""&&position[xstart][ystart - takensteps - 1] == ""Wand1"")
                    {
                        ystart = ystart - takensteps;
                        return ""("" + xstart + "","" + ystart + "")"";
                    }

                    else {
                        takensteps += 1;
                    }
                }
                ystart = ystart - takensteps;


            }
            if (direction.equals(""we"")) {
                if (xstart-moves<0)
                {
                    moves=xstart;
                }

                while (takensteps < moves ) {
                    if (position[xstart - takensteps ][ystart] == ""Wand1""&&position[xstart - takensteps - 1][ystart] == ""Wand2"")
                    {
                        xstart=xstart-takensteps;
                        return ""("" + xstart + "","" + ystart + "")"";
                    }
                    if (position[xstart - takensteps ][ystart] == ""Wand2""&&position[xstart - takensteps - 1][ystart] == ""Wand1"")
                    {
                        xstart=xstart-takensteps;
                        return ""("" + xstart + "","" + ystart + "")"";
                    }
                    else
                    {
                        takensteps += 1;
                    }
                }
                xstart = xstart - takensteps;

            }
            return ""("" + xstart + "","" + ystart + "")"";

        } catch(java.lang.ArrayIndexOutOfBoundsException use)
        {
            switch (direction) {
                case ""no"": ystart = ystart + takensteps;
                    return ""("" + xstart + "","" + ystart + "")"";
                case ""ea"": xstart = xstart + takensteps;
                    return ""("" + xstart + "","" + ystart + "")"";
                case ""so"": ystart = ystart - takensteps;
                    return ""("" + xstart + "","" + ystart + "")"";
                case ""we"": xstart = xstart - takensteps;
                    return ""("" + xstart + "","" + ystart + "")"";
            }
            return ""("" + xstart + "","" + ystart + "")"";
        }
    }



    public static void Waendebauen() {
        //Wand1
        String wall1_1=""(9,1)-(9,7)"";
        String wall2_1=""(9,1)-(2,1)"";
        String wall3_1=""(2,1)-(2,5)"";
        String wall4_1=""(2,5)-(6,5)"";
        //Wand2
        String wall1=""(10,0)-(10,7)"";
        String wall2=""(10,0)-(1,0)"";
        String wall3=""(1,0)-(1,6)"";
        String wall4=""(1,6)-(6,6)"";
//wand 1
        for (int j = 1; j <= 7; j++) {
            position[9][j] = ""Wand1"";
        }


        for (int j = 2; j <= 9; j++) {
            position[j][1] = ""Wand1"";
        }


        for (int j = 1; j <= 5; j++) {
            position[2][j] = ""Wand1"";
        }


        for (int j = 2; j <= 6; j++) {
            position[j][5] = ""Wand1"";
        }





        //wand 2
        for (int j = 0; j <= 7; j++) {
            position[10][j] = ""Wand2"";
        }


        for (int j = 1; j <= 10; j++) {
            position[j][0] = ""Wand2"";
        }


        for (int j = 0; j <= 6; j++) {
            position[1][j] = ""Wand2"";
        }


        for (int j = 1; j <= 6; j++) {
            position[j][6] = ""Wand2"";
        }


    }public static void main(String[] args) {
        Waendebauen();
        System.out.println(position[1][1]);

      /*  for ( int zeile = 0; zeile < position.length; zeile++ )
        {
            System.out.print(""Zeile "" + zeile + "": "");
            for ( int spalte=0; spalte < position[zeile].length; spalte++ )
                System.out.print( position[zeile][spalte] + "" "");
            System.out.println();

        }*/


    }


}

package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String move(String moveCommandString);
}
",7210,236,38.31868131868132,131,0.025423728813559324,0.06779661016949153,0.0423728813559322,0.00423728813559322,0.788135593220339,0.0,0.1652542372881356,0.025423728813559324,False,False,False,False,False,False,2,0.01694915254237288,0.012711864406779662,0.05084745762711865,0.00423728813559322,0.8898305084745762,0.059322033898305086,0.00847457627118644,6.375,10,22.772727272727273,63
student90,student,,,"package thkoeln.st.st2praktikum.exercise;

import java.util.Arrays;
import java.util.List;

public class Exercise0 implements Walkable {

    //initialisieren und deklarieren der Startwerte x und y
    private int x = 4;
    private int y = 0;

    //Initialiesieren der Barrieren als listen
    private List<String> firstBarrier = Arrays.asList(""(1,0)"", ""(1,1)"", ""(1,2)"", ""(1,3)"", ""(1,4)"", ""(1,5)"");
    private List<String> secondBarrier = Arrays.asList(""(1,6)"",""(2,6)"", ""(3,6)"");
    private List<String> thirdBarrier = Arrays.asList(""(5,6)"",""(6,6)"");
    private List<String> fourthBarrier = Arrays.asList(""(7,1)"", ""(7,2)"", ""(7,3)"", ""(7,4)"", ""(7,5)"");


    //Implementierung der Methode walkTo()
    @Override
    public String walkTo(String walkCommandString) {
        //throw new UnsupportedOperationException();


        StringBuilder numberOfSteps = new StringBuilder();

        String finalStringValue = ""(""+ x + "","" + y + "")"";



        //prüft die richtung in der der Bagger fährt
        if(walkCommandString.contains(""no"") || walkCommandString.contains(""ea"") || walkCommandString.contains(""so"")
            || walkCommandString.contains(""we"")){



            //liest die Zahlen im string
            for(char s : walkCommandString.toCharArray()){
                if(Character.isDigit(s))
                    numberOfSteps.append(s);

            }
            String stringSteps = numberOfSteps.toString();
            int intSteps = Integer.parseInt(stringSteps);


            if(walkCommandString.contains(""no"")){   // wird ausgeführt wenn der string 'no' enthält
                if(intSteps == 0){return finalStringValue;}

                if(intSteps == 1){
                    y++;
                    finalStringValue = ""("" + x + "","" + y + "")"";
                    if(!secondBarrier.contains(finalStringValue) && !thirdBarrier.contains(finalStringValue)){
                        return finalStringValue;
                    }else{
                        y--;
                        finalStringValue = ""("" + x + "","" + y + "")"";
                        return finalStringValue;
                    }
                }

                y++;
                finalStringValue = ""("" + x + "","" + y + "")"";
                for(int i=0; i<intSteps-1; i++){
                    if(!secondBarrier.contains(finalStringValue) && !thirdBarrier.contains(finalStringValue)){
                        y++;
                        finalStringValue = ""("" + x + "","" + y + "")"";
                    } else {
                        y--;
                        finalStringValue = ""("" + x + "","" + y + "")"";
                        break;
                    }
                }

                if(y > 7){
                    y=7;
                    finalStringValue = ""("" + x + "","" + y + "")"";
                }

            } else if (walkCommandString.contains(""so"")){   //wird ausgeführt wenn der string so enthält

                for(int iterator=0; iterator<intSteps; iterator++){
                    if(!secondBarrier.contains(finalStringValue) && !thirdBarrier.contains(finalStringValue)){
                        y--;
                        finalStringValue = ""("" + x + "","" + y + "")"";
                    } else
                        break;
                }

                if(y<0){
                    y=0;
                    finalStringValue = ""("" + x + "","" + y + "")"";
                }


            } else if (walkCommandString.contains(""ea"")){   // wird ausgeführt wenn der string ea enthält
                if(intSteps ==0){return finalStringValue;}

                if(intSteps == 1){
                    x++;
                    finalStringValue = ""("" + x + "","" + y + "")"";
                    if(!firstBarrier.contains(finalStringValue) && !fourthBarrier.contains(finalStringValue)){
                        return finalStringValue;
                    }else{
                        x--;
                        finalStringValue = ""("" + x + "","" + y + "")"";
                        return finalStringValue;
                    }
                }

                x++;
                finalStringValue = ""("" + x + "","" + y + "")"";
                for(int iterator=0; iterator<intSteps-1; iterator++){


                    if(!firstBarrier.contains(finalStringValue) && !fourthBarrier.contains(finalStringValue)){
                        x++;
                        finalStringValue = ""("" + x + "","" + y + "")"";
                    } else {
                        x--;
                        finalStringValue = ""("" + x + "","" + y + "")"";
                        break;//
                    }
                }


                if(x > 10){
                    x=10;
                    finalStringValue = ""("" + x + "","" + y + "")"";
                }

            } else if(walkCommandString.contains(""we"")){ //Wird ausgeführt, wenn der String 'we' enthält

                for(int iterator=0; iterator<intSteps; iterator++){
                    if(!firstBarrier.contains(finalStringValue) && !fourthBarrier.contains(finalStringValue)){
                        x--;
                        finalStringValue = ""("" + x + "","" + y + "")"";
                    } else
                        break;
                }

                if(x<0){
                    x=0;
                    finalStringValue = ""("" + x + "","" + y + "")"";
                }
            }


        }


        return finalStringValue;
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);
}
",5551,160,45.30252100840336,115,0.06875,0.125,0.03125,0.0,0.35625,0.00625,0.19375,0.0,False,True,False,False,False,True,2,0.0125,0.0375,0.025,0.00625,0.675,0.18125,0.0125,5.875,16,37.45454545454545,53
student92,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Moveable {

    int startX = 1;
    int startY = 7;

    @Override
    public String moveTo(String moveCommandString) {

        int steps = moveCommandString.charAt(4) - '0';
        String richtung = moveCommandString.substring(1,3);
        int marker = 0;

        switch(richtung){
            case ""no"":
                if (startY <= 2)
                    marker = 1;
                startY = startY + steps;
                if (marker == 1 && startX == 3 && startY > 2)
                    startY = 2;
                if (marker == 1 && startX == 4 && startY > 2)
                    startY = 2;
                break;
            case ""ea"":
                if (startX <= 2 && startY >= 3) {
                    startX = startX + steps;
                    if (startX >= 3)
                        startX = 2;
                    break;
                }
                if (startX <= 4 && startY <= 1) {
                    startX = startX + steps;
                    if (startX >= 5)
                        startX = 4;
                    break;
                }
                if (startX <= 5 && startY <= 3) {
                    startX = startX + steps;
                    if (startX >= 6)
                        startX = 5;
                    break;
                }
                startX = startX + steps;
                break;
            case ""so"":
                if (startY >= 3)
                    marker = 1;
                startY = startY - steps;
                if (marker == 1 && startX == 3 && startY < 3)
                    startY = 3;
                if (marker == 1 && startX == 4 && startY < 3)
                    startY = 3;
                if (startY < 0)
                    startY = 0;
                break;
            case ""we"":
                if (startX >= 6 && startY <= 3) {
                    startX = startX - steps;
                    if (startX <= 5)
                        startX = 6;
                    break;
                }
                if (startX >= 5 && startY <= 1) {
                    startX = startX - steps;
                    if (startX <= 4)
                        startX = 5;
                    break;
                }
                if (startX >= 3 && startY >= 3) {
                    startX = startX - steps;
                    if (startX <= 2)
                        startX = 3;
                    break;
                }
                startX = startX - steps;
                break;
        }
        return ""(""+startX+"",""+startY+"")"";
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String moveTo(String moveCommandString);
}
",2739,87,33.15,61,0.0,0.21839080459770116,0.0,0.011494252873563218,0.6436781609195402,0.0,0.08045977011494253,0.0,False,False,False,False,False,False,2,0.022988505747126436,0.022988505747126436,0.034482758620689655,0.011494252873563218,0.9080459770114943,0.022988505747126436,0.0,6.2,8,0.0,0
student94,student,,,"package thkoeln.st.st2praktikum.exercise;
public class Exercise0 implements Walkable {
    int x = 7;
    int y = 7;
    String initialPosition=""(7,7)"";

    String obstaclesAndWalls=""(0,0)-(0,8),(11,0)-(11,8),(2,1)-(2,6),(10,1)-(10,8),(0,8)-(11,8),(0,0)-(11,0),(2,6)-(7,6),(2,1)-(10,1)"";

    @Override
    public String walkTo(String walkCommandString) {
        // [no, 6]

        String movement=walkCommandString.substring(1,walkCommandString.length()-1);
        String[] walking=movement.split("","");
        String directionMove=walking[0];
        int stepToMove= Integer.parseInt(walking[1]);

        switch (directionMove){
            case ""no"":
                if (x==0||x==1 || x==10){
                    if ( (y+stepToMove)>7)
                        y=7;
                    else
                        y+=stepToMove;
                }
                if (2<=x && x<=9 && y==0){
                    y=0;
                }

                //top line
                if (2<=x && x<=6 && 1<=y && y<=5){
                    if ((y+stepToMove)>5)
                        y=5;
                    else
                        y+=stepToMove;
                }
                if (7<=x && x<=9 && 1<=y){
                    if ((y+stepToMove)>7)
                        y=7;
                    else
                        y+=stepToMove;
                }

                if (2<=x && x<=6 && (y==6 || y==7)){
                    if ((y+stepToMove)>7)
                        y=7;
                    else
                        y+=stepToMove;
                }break;

            case ""so"":
                if(x==0 || x==1 || x==10){
                    if ((y-stepToMove)<0)
                        y=0;
                    else
                        y-=stepToMove;
                }
                //Bottom line
                if(2<=x && x<=9 && y==0){
                        y=0;
                }

                if(2<=x && x<=6 && (1<=y && y<=5)){
                    if ((y-stepToMove)<1)
                        y=1;
                    else
                        y-= stepToMove;
                 }

                //top
                if(7<=x && x<=9 && 1<=y){
                    if ((y-stepToMove)<1)
                        y=1;
                    else
                        y-= stepToMove;
                }
                if(2<=x && x<=6 && 6<=y){
                    if ((y-stepToMove)<6)
                        y=6;
                    else
                        y-= stepToMove;
                }break;

            case ""ea"":
                if ((x==0 || x==1) && 1<=y && y<=5){
                    if ((x+stepToMove)>1)
                        x=1;
                    else
                        x+=stepToMove;
                }

                //secondline
                if (2<=x && x<=9 && 1<=y && y<=5){
                    if ((x+stepToMove)>9)
                        x=9;
                    else
                        x+=stepToMove;
                }
                if (0<=x && x<=9 && 6<=y){
                    if ((x+stepToMove)>9)
                        x=9;
                    else
                        x+=stepToMove;
                }
                if (x==10 ){
                    x=10;
                }

                if (y==0){
                    if ((x+stepToMove)>10)
                        x=10;
                    else
                        x+=stepToMove;
                }break;

            case ""we"":
                //2ndWvertical
                if (9<x && 1<=y){
                    x=10;
                }
                if (2<=x && x<= 9 && 1<=y && y<=5){
                    if((x-stepToMove)<2)
                        x=2;
                    else
                        x-=stepToMove;
                }
                if (x<= 9 && 6<=y ){
                    if((x-stepToMove)<0)
                        x=0;
                    else
                        x-=stepToMove;
                }

                if ((x== 0 || x==1 )&& 1<=y && y<=5){
                    if((x-stepToMove)<0)
                        x=0;
                    else
                        x-=stepToMove;
                }

                if (y==0 ){
                    if((x-stepToMove)<0)
                        x=0;
                    else
                        x-=stepToMove;
                }break;
        }

        return ""("" + this.x+"",""+ this.y+ "")"" ;
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);

}
",4578,158,31.798561151079138,134,0.0379746835443038,0.22784810126582278,0.0,0.006329113924050633,0.9746835443037974,0.0,0.12025316455696203,0.0,False,False,False,False,False,False,2,0.012658227848101266,0.02531645569620253,0.02531645569620253,0.006329113924050633,0.9367088607594937,0.02531645569620253,0.0,6.4,13,8.5,12
student96,student,,,"package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements GoAble {

    //Initialize coordinates x+y and distance d
    int[][][] horizontalBarriers = {
            {{-1, -1}, {10, -1}},
            {{-1, 7}, {10, 7}},
            {{-1, 5}, {1, 5}},
            {{1, 4}, {8, 4}}
    };

    int[][][] verticalBarriers = {
            {{-1, -1}, {-1, 7}},
            {{10, -1}, {10, 7}},
            {{2, 6}, {2, 7}},
            {{8, 1}, {8, 4}}
    };

    int x = 1;
    int y = 6;



    public String barrierDetected(){
        //System.out.println(""Barrier detected"");
        //System.out.println( currentPosition() + "" abort mission"");
        return currentPosition();
    }

    public String step(int steps, int i){
        //System.out.println(""Steps "" + (steps - i) +"" left"");
        //System.out.println(""New position "" + currentPosition());
        return currentPosition();
    }

    public String currentPosition(){
        return ""("" + x + "","" + y + "")"";
    }


    @Override
    public String goTo(String goCommandString) {
        System.out.println(goCommandString);
       int steps = Integer.parseInt(goCommandString.replaceAll(""[^0-9]"", """"));

        // Determine direction in if statement

        // going up
        if (goCommandString.contains(""no"")) {

            //Make a step while i < steps
            for (int i = 0; i < steps; i++) {

                // Check Barriers

                // Iterate over barriers
                for (int[][] horizontalBarrier : horizontalBarriers) {
                    //System.out.println(""Check for barrier: "" + j + "" at "" + currentPosition());
                    // Check if y Position is at hight of a barrier
                    if (y == horizontalBarrier[0][1]) {
                        // Check if x position is in between start and end of barrier
                        if (horizontalBarrier[0][0] <= x && x <= horizontalBarrier[1][0]) {
                            return barrierDetected();
                        }
                    }
                }
                y++;
                step(steps, i );
            }
            return currentPosition();

        } else if (goCommandString.contains(""so"")) {
            //Make a step while d
            for (int i = 0; i < steps; i++) {

                // Check Barriers

                // Iterate over barriers
                for (int[][] horizontalBarrier : horizontalBarriers) {
                    //System.out.println(""Check for barrier: "" + j + "" at "" + currentPosition());

                    // Check if y Position is at hight of a barrier
                    if (y == horizontalBarrier[0][1] + 1) {
                        // Check if x position is in between start and end of barrier
                        if (horizontalBarrier[0][0] <= x && x <= horizontalBarrier[1][0]) {
                            return barrierDetected();
                        }
                    }
                }
                y--;
                step(steps, i );
            }
            return currentPosition();


        } else if (goCommandString.contains(""ea"")) {
            //System.out.println(""Going RIGHT from "" + currentPosition());
            //Make a step while i < steps
            for (int i = 0; i < steps; i++) {

                // Check Barriers

                // Iterate over barriers
                for (int[][] verticalBarrier : verticalBarriers) {
                    //System.out.println(""Check for barrier: "" + j + "" at "" + currentPosition());

                    // Check if x Position is at hight of a barrier

                    if (x == verticalBarrier[0][0] && x != 0) {
                        // Check if y position is in between start and end of barrier
                        if (verticalBarrier[0][1] <= y && y <= verticalBarrier[1][1]) {
                            return barrierDetected();
                        }
                    }
                }
                // Make a step
                x++;
                step(steps, i);
            }
            return currentPosition();


        // Go LEFT
        } else if (goCommandString.contains(""we"")) {
            //System.out.println(""Going LEFT from "" + currentPosition());
            for (int i = 0; i < steps; i++) {

                // Check Barriers

                // Iterate over barriers
                for (int[][] verticalBarrier : verticalBarriers) {

                    // Check if x Position is at hight of a barrier
                    if (x == verticalBarrier[0][0] + 1) {
                        //System.out.println(""Check for barrier: "" + i);
                        // Check if y position is in between start and end of barrier
                        if (verticalBarrier[0][1] <= y && y <= verticalBarrier[1][1]) {
                            return barrierDetected();
                        }
                    }
                }
                // Make a step
                x--;
                step(steps, i);
            }
            return currentPosition();
        }

        return currentPosition();


    }


}
package thkoeln.st.st2praktikum.exercise;

public interface GoAble {
    String goTo(String goCommandString);
}
",5241,161,40.96774193548387,97,0.21739130434782608,0.13043478260869565,0.07453416149068323,0.0,0.45962732919254656,0.0,0.19254658385093168,0.06832298136645963,False,False,False,False,False,False,2,0.031055900621118012,0.024844720496894408,0.006211180124223602,0.006211180124223602,0.34782608695652173,0.13664596273291926,0.0,9.88888888888889,18,37.97142857142857,75
student97,student,,,"package thkoeln.st.st2praktikum.exercise;


public class Exercise0 implements Walkable {
    int[] currentPosition = new int[] {1,7};
    int[][] obstacles = new int[][] {
        // vertical     0,x,x,y,y
        // horizontal   1,y,y,x,x
        {0,2,3,3,9},
        {0,5,6,0,3},
        {0,4,5,0,1},
        {0,-1,0,0,9},
        {0,12,13,0,9},
        {1,2,3,3,4},
        {1,-1,0,0,12},
        {1,9,10,0,12}
    };


    @Override
    public String walkTo(String walkCommandString) {

        String direction = walkCommandString.split("","")[0].replace(""["", """");
        int steps = Integer.parseInt(walkCommandString.split("","")[1].replace(""]"", """"));


        moveloop:
        for(int i = 0; i < steps; i++) {


            if(direction.equals(""we"")) {
                for(int a = 0; a < obstacles.length; a++) {
                    if(
                        // if obstacle is relevant for move
                        (obstacles[a][0] == 0)
                        // if current position is in range of obstacle
                        && (currentPosition[1] >= obstacles[a][3] && currentPosition[1] <= obstacles[a][4])
                        // if collision is ahead
                        && (currentPosition[0] == obstacles[a][2])
                    ) break moveloop;
                }

                currentPosition[0]--;
            }


            else if(direction.equals(""ea"")) {
                for(int a = 0; a < obstacles.length; a++) {
                    if(
                        (obstacles[a][0] == 0)
                        && (currentPosition[1] >= obstacles[a][3] && currentPosition[1] <= obstacles[a][4])
                        && (currentPosition[0] == obstacles[a][1])
                    ) break moveloop;
                }

                currentPosition[0]++;
            }
            

            else if(direction.equals(""no"")) {
                for(int a = 0; a < obstacles.length; a++) {
                    if(
                        (obstacles[a][0] == 1)
                        && (currentPosition[0] >= obstacles[a][3] && currentPosition[0] <= obstacles[a][4])
                        && (currentPosition[1] == obstacles[a][1])
                    ) break moveloop;
                }

                currentPosition[1]++;
            }


            else if(direction.equals(""so"")) {
                for(int a = 0; a < obstacles.length; a++) {
                    if(
                        (obstacles[a][0] == 1)
                        && (currentPosition[0] >= obstacles[a][3] && currentPosition[0] <= obstacles[a][4])
                        && (currentPosition[1] == obstacles[a][2])
                    ) break moveloop;
                }

                currentPosition[1]--;
            }
        }
        
        System.out.println(walkCommandString);
        System.out.println(""current Position: ("" + currentPosition[0] + "","" + currentPosition[1] + "")"");
        return ""("" + currentPosition[0] + "","" + currentPosition[1] + "")"";
    }
}
package thkoeln.st.st2praktikum.exercise;

public interface Walkable {
    String walkTo(String walkCommandString);
}
",3127,95,39.89473684210526,107,0.05263157894736842,0.11578947368421053,0.06315789473684211,0.0,1.0421052631578946,0.0,0.1368421052631579,0.021052631578947368,False,False,False,False,False,False,2,0.021052631578947368,0.021052631578947368,0.021052631578947368,0.010526315789473684,0.7157894736842105,0.11578947368421053,0.0,7.714285714285714,17,28.0,43
student98,student,,,"package thkoeln.st.st2praktikum.exercise;

abstract public class AbstractMove {

    abstract public Position moveUntilBlocked(Matrix Coordinates, Position position, int length);

    protected Boolean validateStep(Matrix Coordinates, Position position, Orientation orientation) {
        return Coordinates.validatePosition(position, orientation);
    }
}

package thkoeln.st.st2praktikum.exercise;

import lombok.Getter;

public class CommandParser {

    @Getter
    private Orientation orientation;

    @Getter
    private Integer stepLength;

    private CommandParser(Orientation orientation, Integer stepLength) {
        this.orientation = orientation;
        this.stepLength = stepLength;
    }

    public static CommandParser StringToCommand(String command) {
        int stepLength;
        Orientation orientation;
        String commandNoBraces = command.replaceAll(""[\\[\\]]"", """");
        String[] commandSplit = commandNoBraces.split("","");

        switch (commandSplit[0]) {
            case ""no"": orientation = Orientation.NO; break;
            case ""ea"": orientation = Orientation.EA; break;
            case ""so"": orientation = Orientation.SO; break;
            case ""we"": orientation = Orientation.WE; break;
            default: orientation = null;
        }
        stepLength = Integer.parseInt(commandSplit[1]);
        return new CommandParser(orientation, stepLength);
    }
}

package thkoeln.st.st2praktikum.exercise;

public class Exercise0 implements Moveable {

    private Position CurrentPos;
    private Matrix Coordinates;

    public Exercise0() {
        this.CurrentPos = new Position(8, 3);
        this.Coordinates = Matrix.createMatrix();
    }

    @Override
    public String moveTo(String moveCommandString) {
        AbstractMove Move = null;
        CommandParser Command = CommandParser.StringToCommand(moveCommandString);

//        System.out.println(CurrentPos);

        switch (Command.getOrientation()) {
            case NO: Move = new MoveNorth();    break;
            case EA: Move = new MoveEast();     break;
            case SO: Move = new MoveSouth();    break;
            case WE: Move = new MoveWest();     break;
        }
        CurrentPos = Move.moveUntilBlocked(Coordinates, CurrentPos, Command.getStepLength());

//        System.out.println(moveCommandString);
//        System.out.println(CurrentPos.toString());
//        System.out.println("""");
        return CurrentPos.toString();
    }
}

package thkoeln.st.st2praktikum.exercise;

public class Matrix {

    private final Boolean[][] matrix;
    private final int xLen;
    private final int yLen;

    private Matrix(Boolean[][] matrix, int xLen, int yLen) {
        this.matrix = matrix;
        this.xLen = xLen;
        this.yLen = yLen;
    }

    public static Matrix createMatrix() {
        int xLen = 13;
        int yLen = 10;
        Boolean[][] matrix = new Boolean[xLen][yLen];
        for (int i = 0; i < xLen; i++) {
            for (int j = 0; j < yLen; j++) {
                matrix[i][j] = false;
            }
        }
            matrix[4][1] = true;
            matrix[4][2] = true;
            matrix[4][3] = true;
            matrix[4][4] = true;
            matrix[4][5] = true;
            matrix[4][6] = true;
            matrix[4][7] = true;

            matrix[6][2] = true;
            matrix[7][2] = true;
            matrix[8][2] = true;
            matrix[9][2] = true;

            matrix[6][2] = true;
            matrix[6][3] = true;
            matrix[6][4] = true;
            matrix[6][5] = true;

            matrix[6][5] = true;
            matrix[7][5] = true;
            matrix[8][5] = true;
            matrix[9][5] = true;
        return new Matrix(matrix, xLen, yLen);
    }

    public Boolean validatePosition(Position newPosition, Orientation orientation) {
        if (!validateOutOfBounds(newPosition))
            return false;
        if (!validateMovement(newPosition, orientation))
            return false;
        return true;
    }

    private Boolean validateOutOfBounds(Position newPosition) {
        if (newPosition.getXPos() < 0)
            return false;
        if (newPosition.getXPos() >= xLen - 1)     // minus 1 because of tile definition
            return false;
        if (newPosition.getYPos() < 0)
            return false;
        if (newPosition.getYPos() >= yLen - 1)
            return false;
        return true;
    }

    private Boolean validateMovement(Position newPosition, Orientation orientation) {
        switch (orientation) {
            case NO: return validateNorthMovement(newPosition);
            case EA: return validateEastMovement(newPosition);
            case SO: return validateSouthMovement(newPosition);
            case WE: return validateWestMovement(newPosition);
        }
        return false;
    }

    private Boolean validateNorthMovement(Position newPosition) {
//        System.out.println(""x: "" + newPosition.getXPos() + "", y: "" + newPosition.getYPos() + "", "" + matrix[newPosition.getXPos()][newPosition.getYPos()]);
//        System.out.println(""x: "" + (newPosition.getXPos() + 1) + "", y: "" + newPosition.getYPos() + "", "" + matrix[newPosition.getXPos() + 1][newPosition.getYPos()]);

        if (matrix[newPosition.getXPos()][newPosition.getYPos()]) {
            if (matrix[newPosition.getXPos() + 1][newPosition.getYPos()]) {
                return false;
            }
        }
        return true;
    }

    private Boolean validateEastMovement(Position newPosition) {
        if (matrix[newPosition.getXPos()][newPosition.getYPos()]) {
            if (matrix[newPosition.getXPos()][newPosition.getYPos() + 1]) {
                return false;
            }
        }
        return true;
    }

    private Boolean validateSouthMovement(Position newPosition) {
        if (matrix[newPosition.getXPos()][newPosition.getYPos() + 1]) {
            if (matrix[newPosition.getXPos() + 1][newPosition.getYPos() + 1]) {
                return false;
            }
        }
        return true;
    }

    private Boolean validateWestMovement(Position newPosition) {
        if (matrix[newPosition.getXPos() + 1][newPosition.getYPos()]) {
            if (matrix[newPosition.getXPos() + 1][newPosition.getYPos() + 1]) {
                return false;
            }
        }
        return true;
    }

    public String MatrixToString() {
        String output = """";
        for (int j = yLen - 1; j >= 0; j--) {
            for (int i = 0; i < xLen; i++) {
                output += (matrix[i][j] ? ""1"" : ""0"");
                if (i + 1 >= xLen) {
                    output += ""\n"";
                }
            }
        }
        return output;
    }
}

package thkoeln.st.st2praktikum.exercise;

public interface Moveable {
    String moveTo(String moveCommandString);
}

package thkoeln.st.st2praktikum.exercise;

public class MoveEast extends AbstractMove {

    @Override
    public Position moveUntilBlocked(Matrix Coordinates, Position startPosition, int stepLength) {
        Position currentPosition = new Position(startPosition.getXPos(), startPosition.getYPos());

        while (stepLength > 0) {
            Position newPosition = new Position(currentPosition.getXPos() + 1, currentPosition.getYPos());

            if (!validateStep(Coordinates, newPosition, Orientation.EA))
                return currentPosition;

            currentPosition.setXPos(newPosition.getXPos());
            stepLength--;
        }
        return currentPosition;
    }
}

package thkoeln.st.st2praktikum.exercise;

public class MoveNorth extends AbstractMove {

    @Override
    public Position moveUntilBlocked(Matrix Coordinates, Position startPosition, int stepLength) {
        Position currentPosition = new Position(startPosition.getXPos(), startPosition.getYPos());

        while (stepLength > 0) {
            Position newPosition = new Position(currentPosition.getXPos(), currentPosition.getYPos() + 1);

            if (!validateStep(Coordinates, newPosition, Orientation.NO))
                return currentPosition;

            currentPosition.setYPos(newPosition.getYPos());
            stepLength--;
        }
        return currentPosition;
    }
}

package thkoeln.st.st2praktikum.exercise;

public class MoveSouth extends AbstractMove {

    @Override
    public Position moveUntilBlocked(Matrix Coordinates, Position startPosition, int stepLength) {
        Position currentPosition = new Position(startPosition.getXPos(), startPosition.getYPos());

        while (stepLength > 0) {
            Position newPosition = new Position(currentPosition.getXPos(), currentPosition.getYPos() - 1);

            if (!validateStep(Coordinates, newPosition, Orientation.SO))
                return currentPosition;

            currentPosition.setYPos(newPosition.getYPos());
            stepLength--;
        }
        return currentPosition;
    }
}

package thkoeln.st.st2praktikum.exercise;

public class MoveWest extends AbstractMove {

    @Override
    public Position moveUntilBlocked(Matrix Coordinates, Position startPosition, int stepLength) {
        Position currentPosition = new Position(startPosition.getXPos(), startPosition.getYPos());

        while (stepLength > 0) {
            Position newPosition = new Position(currentPosition.getXPos() - 1, currentPosition.getYPos());

            if (!validateStep(Coordinates, newPosition, Orientation.WE))
                return currentPosition;

            currentPosition.setXPos(newPosition.getXPos());
            stepLength--;
        }
        return currentPosition;
    }
}

package thkoeln.st.st2praktikum.exercise;

public enum Orientation {
    NO,
    EA,
    SO,
    WE
}

package thkoeln.st.st2praktikum.exercise;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@NoArgsConstructor
@AllArgsConstructor
public class Position {
    @Getter
    @Setter
    private int xPos;

    @Getter
    @Setter
    private int yPos;

    public String toString() {
        return ""(""+xPos+"",""+yPos+"")"";
    }
}
",10099,332,37.136882129277566,166,0.02108433734939759,0.0572289156626506,0.012048192771084338,0.009036144578313253,0.2710843373493976,0.0,0.20783132530120482,0.018072289156626505,False,False,True,False,False,False,11,0.0572289156626506,0.02710843373493976,0.05421686746987952,0.02710843373493976,0.39457831325301207,0.1927710843373494,0.015060240963855422,8.13953488372093,17,67.14285714285714,156
